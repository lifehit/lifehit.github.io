<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>以libtinyxml为例了解C++的make使用</title>
      <link href="/2023/04/13/bian-cheng-zhi-dao/yi-libtinyxml-wei-li-liao-jie-c-de-make-shi-yong/"/>
      <url>/2023/04/13/bian-cheng-zhi-dao/yi-libtinyxml-wei-li-liao-jie-c-de-make-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>最近想在C/C++中解析xml文件，本来开始的时候xml的模式比较简单，通过一些C语言中的字符串处理API就可以了，但是后续因为一些原因需要解析整个xml文档，考虑到代码库中已有的xml解析模块，有：</p><ul><li>libtinyxml：c++编写；</li><li>libxml：C语言编写；</li></ul><p>考虑到后续的发展，决定使用C++的xml解析库——libtinyxml。在开发代码的过程中，发现自己对C++的理解有漏洞，趁此机会查缺补漏一下。</p><h1 id="如何编译libtinyxml库？"><a href="#如何编译libtinyxml库？" class="headerlink" title="如何编译libtinyxml库？"></a>如何编译libtinyxml库？</h1><p>因为之前从未使用C++进行开发，因此对于C++的编译和构建过程极为模糊，而libtinyxml下载源码后，需要自己来编译，我简单看了一下，发现其代码不多，且makefile很短，可以帮助理解makefile。</p><h2 id="认识makefile"><a href="#认识makefile" class="headerlink" title="认识makefile"></a>认识makefile</h2><p>开发人员使用的多数都是高级语言，这些高级语言可以分为两种：</p><ul><li>编译型语言：典型如C和C++；</li><li>解释型语言：如Python等；</li></ul><p>如果让这些高级语言可运行的话，需要将它们转换为机器语言，这个过程称为编译（compile）。不同的文件之间存在着各种依赖关系，在进行编译时，如何安排不同文件之间的编译依赖顺序，称为一个构建（build）过程。</p><p>不同编程语言都有自己的构建工具，比如Java中的Maven和Gradle等，这些工具可以根据特定的场景、文件类型、依赖关系等等，设置不同的profile，来满足开发者的需求。而在C/C++语言中，常用的是用make工具。</p><p>make简单来说是一个命令，在linux/MacOS中，make如果不加以说明的话，指的是GNU make utility。</p><blockquote><p>make - GNU make utility to maintain groups of programs.</p></blockquote><p>该工具不仅可以用来进行构建工程的，<strong>其规定，当指定文件发生变化时，可以运行特定的指令</strong>。</p><blockquote><p>按照<a href="https://makefiletutorial.com/">theicfire</a>的说法，Make can also be used beyond compilation too, when you need a series of instructions to run depending on what files have changed.</p></blockquote><p>如果要执行make命令，需要一个makefile，这里会有点概念上的混乱，make指什么？</p><ul><li>狭义上，指的是GNU make utility；</li><li>广义上，针对C/C++语言的make构建工具有很多，如QT的qmake ，微软的MS nmake等，它们都可以叫make；</li></ul><p>但是，它们都需要一个makefile，make本身不会执行编译，而是执行编译规则，通过写在makefile中编译命令，所以make更多的可以理解为一个makefile解析器，解析该文件并执行对应的命令。</p><blockquote><p>与make类似的工具有Google的Ninja，在Android和Chrome的开发中有使用，相比make而言，ninja功能没有那么强大，但是正因为功能有限，所以启动编译的速度很快！</p></blockquote><p>本文不会对make进行详述，因为这样的文章太多了，之后在后续的libtinyxml例子中说明，可以参考如下资料：</p><ul><li><a href="https://www.ruanyifeng.com/blog/2015/02/make.html">Make命令教程</a></li><li><a href="https://makefiletutorial.com/">Learn Makefiles</a></li><li><a href="https://seisman.github.io/how-to-write-makefile/introduction.html">跟我一起写Makefile</a></li></ul><p>不同的make工具支持的makefile格式可能略有差别。因此，我们自己编写的makefile可能移植性不高，这也是一些跨平台的构建工具的目的，比如CMake和SCons，它们产生可移植的makefile，并简化动手写makefile时的巨大工作量，它们都是make的上层工具，可以用来产生makefile，与make等不冲突。</p><h2 id="了解libtinyxml的makefile"><a href="#了解libtinyxml的makefile" class="headerlink" title="了解libtinyxml的makefile"></a>了解libtinyxml的makefile</h2><p>根据libtinyxml中的makefile可以了解一下行常用的规则。</p><pre class=" language-makefile"><code class="language-makefile"><span class="token comment" spellcheck="true"># 用':='定义变量</span>DEBUG          <span class="token operator">:=</span> NOPROFILE        <span class="token operator">:=</span> NOTINYXML_USE_STL <span class="token operator">:=</span> NOCC     <span class="token operator">:=</span> gccCXX    <span class="token operator">:=</span> g++LD     <span class="token operator">:=</span> g++AR     <span class="token operator">:=</span> ar rcRANLIB <span class="token operator">:=</span> ranlibDEBUG_CFLAGS     <span class="token operator">:=</span> -Wall -Wno-format -g -DDEBUGRELEASE_CFLAGS   <span class="token operator">:=</span> -Wall -Wno-unknown-pragmas -Wno-format -O3LIBS         <span class="token operator">:=</span><span class="token comment" spellcheck="true"># 用${}调用变量</span>DEBUG_CXXFLAGS   <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>DEBUG_CFLAGS<span class="token punctuation">}</span> RELEASE_CXXFLAGS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>RELEASE_CFLAGS<span class="token punctuation">}</span>DEBUG_LDFLAGS    <span class="token operator">:=</span> -gRELEASE_LDFLAGS  <span class="token operator">:=</span><span class="token comment" spellcheck="true"># 使用判断语句</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span>YES, <span class="token variable">$</span><span class="token punctuation">{</span>DEBUG<span class="token punctuation">}</span><span class="token punctuation">)</span>   CFLAGS       <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>DEBUG_CFLAGS<span class="token punctuation">}</span>   CXXFLAGS     <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>DEBUG_CXXFLAGS<span class="token punctuation">}</span>   LDFLAGS      <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>DEBUG_LDFLAGS<span class="token punctuation">}</span><span class="token keyword">else</span>   CFLAGS       <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>RELEASE_CFLAGS<span class="token punctuation">}</span>   CXXFLAGS     <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>RELEASE_CXXFLAGS<span class="token punctuation">}</span>   LDFLAGS      <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>RELEASE_LDFLAGS<span class="token punctuation">}</span><span class="token keyword">endif</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span>YES, <span class="token variable">$</span><span class="token punctuation">{</span>PROFILE<span class="token punctuation">}</span><span class="token punctuation">)</span>   CFLAGS   <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>CFLAGS<span class="token punctuation">}</span> -pg -O3   CXXFLAGS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>CXXFLAGS<span class="token punctuation">}</span> -pg -O3   LDFLAGS  <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>LDFLAGS<span class="token punctuation">}</span> -pg<span class="token keyword">endif</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span>YES, <span class="token variable">$</span><span class="token punctuation">{</span>TINYXML_USE_STL<span class="token punctuation">}</span><span class="token punctuation">)</span>  DEFS <span class="token operator">:=</span> -DTIXML_USE_STL<span class="token keyword">else</span>  DEFS <span class="token operator">:=</span><span class="token keyword">endif</span>INCS <span class="token operator">:=</span>CFLAGS   <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>CFLAGS<span class="token punctuation">}</span>   <span class="token variable">$</span><span class="token punctuation">{</span>DEFS<span class="token punctuation">}</span>CXXFLAGS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>CXXFLAGS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>DEFS<span class="token punctuation">}</span>OUTPUT <span class="token operator">:=</span> xmltest<span class="token comment" spellcheck="true"># 声明第一个target为all，其含义在于：如果要构建all，必须执行${OUTPUT}</span><span class="token comment" spellcheck="true"># 默认情况下，make会找第一个target执行</span><span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">{</span>OUTPUT<span class="token punctuation">}</span>SRCS <span class="token operator">:=</span> tinyxml.cpp tinyxmlparser.cpp xmltest.cpp tinyxmlerror.cpp tinystr.cppSRCS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">{</span>SRCS<span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 使用函数addsuffix将所有源文件的后缀名变为.o</span>OBJS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">addsuffix</span> .o,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">basename</span> <span class="token variable">$</span><span class="token punctuation">{</span>SRCS<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 声明第二个目标${OUTPUT}，这个是一个对变量的调用；</span><span class="token comment" spellcheck="true"># 当${OBJS}发生变化后（包括开始没有这些文件），会触发${OUTPUT}下的commands的执行，即重新进行编译。</span><span class="token comment" spellcheck="true"># 如果此时${OBJS}中的文件不存在，则会找到对应的target执行，如下下边%.o所示。</span><span class="token comment" spellcheck="true"># 这里用到了$@，其代表target ${OUTPUT}自身。</span><span class="token symbol"><span class="token variable">$</span>{OUTPUT}</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">{</span>OBJS<span class="token punctuation">}</span>    <span class="token variable">$</span><span class="token punctuation">{</span>LD<span class="token punctuation">}</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">{</span>LDFLAGS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>OBJS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>LIBS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>EXTRA_LIBS<span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 使用模式匹配，确定了所有的.c/.cpp生成相应的.o文件的规则</span><span class="token comment" spellcheck="true"># $&lt; 指定target的前置条件中的第一个</span><span class="token symbol">%.o </span><span class="token punctuation">:</span> %.cpp    <span class="token variable">$</span><span class="token punctuation">{</span>CXX<span class="token punctuation">}</span> -c <span class="token variable">$</span><span class="token punctuation">{</span>CXXFLAGS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>INCS<span class="token punctuation">}</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token symbol">%.o </span><span class="token punctuation">:</span> %.c    <span class="token variable">$</span><span class="token punctuation">{</span>CC<span class="token punctuation">}</span> -c <span class="token variable">$</span><span class="token punctuation">{</span>CFLAGS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>INCS<span class="token punctuation">}</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token symbol">dist</span><span class="token punctuation">:</span>    bash makedistlinux<span class="token comment" spellcheck="true"># 这是一个伪目标，即目标本身不是文件</span><span class="token symbol">clean</span><span class="token punctuation">:</span>    -rm -f core <span class="token variable">$</span><span class="token punctuation">{</span>OBJS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>OUTPUT<span class="token punctuation">}</span><span class="token symbol">depend</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#makedepend ${INCS} ${SRCS}</span><span class="token comment" spellcheck="true"># 说明下面4个target分别需要两个前提条件才能运行，没有这些也是可以编译的</span><span class="token symbol">tinyxml.o</span><span class="token punctuation">:</span> tinyxml.h tinystr.h<span class="token symbol">tinyxmlparser.o</span><span class="token punctuation">:</span> tinyxml.h tinystr.h<span class="token symbol">xmltest.o</span><span class="token punctuation">:</span> tinyxml.h tinystr.h<span class="token symbol">tinyxmlerror.o</span><span class="token punctuation">:</span> tinyxml.h tinystr.h</code></pre><p>简单总结一下：</p><p>makefile的核心是一个构建规则，包括3个组件：</p><ul><li><p>target：构建的目标</p><ul><li>可以是文件；也可以是伪目标，即一个label；</li><li>默认，make执行第一个target all；</li></ul><blockquote><p><a href="https://stackoverflow.com/questions/2514903/what-does-all-stand-for-in-a-makefile">What does “all” stand for in a makefile? </a>专门针对all进行了解释。</p></blockquote></li><li><p>prerequisites</p><ul><li>设置一组条件，用来判断是否重新构建target；</li><li>只要有一个前置条件不存在或者时间比target新，就会触发重新构建；</li><li>如果一个前置条件（文件）不存在，需要写一个新的构建规则，生成该文件；</li><li>一个target没有任何前置条件，说明其独立于任何条件；</li></ul></li><li><p>commands：表明如何更新目标文件，是构建目标的指令；</p><ul><li>与prerequisites两者之间，必须有一个；</li></ul></li></ul><h2 id="编译libtinyxml"><a href="#编译libtinyxml" class="headerlink" title="编译libtinyxml"></a>编译libtinyxml</h2><p>如果理解了makefile运行的逻辑，执行libtinyxml编译的过程也能大概了解了：</p><ul><li>执行make或者make all；</li><li>all依赖OUTPUT，发现OUTPUT不存在，执行该target；</li><li>OUTPUT依赖OBJS，发现OBJS不存在，执行对应的target，得到.o文件；</li><li>然后再回头执行OUTPUT</li></ul><p>运行过程也如预期一样：</p><pre class=" language-shell"><code class="language-shell">g++ -c -Wall -Wno-unknown-pragmas -Wno-format -O3   tinyxml.cpp -o tinyxml.og++ -c -Wall -Wno-unknown-pragmas -Wno-format -O3   tinyxmlparser.cpp -o tinyxmlparser.og++ -c -Wall -Wno-unknown-pragmas -Wno-format -O3   tinyxmlerror.cpp -o tinyxmlerror.og++ -c -Wall -Wno-unknown-pragmas -Wno-format -O3   tinystr.cpp -o tinystr.oar rc -o libtinyxml.a  tinyxml.o tinyxmlparser.o tinyxmlerror.o tinystr.o</code></pre><p>tinyxml的使用可以分为静态链接库和动态链接库，对这两个部分的说明超出了本文的范围，下面简单说一下如何更改makefile进行编译。</p><blockquote><p>如果不需要xmltest.cpp，可以在SRCS中删除。</p></blockquote><h3 id="编译静态链接库"><a href="#编译静态链接库" class="headerlink" title="编译静态链接库"></a>编译静态链接库</h3><p>在这种模式下，只需修改两处即可：</p><pre class=" language-makefile"><code class="language-makefile">OUTPUT <span class="token operator">:=</span> libtinyxml.a<span class="token symbol"><span class="token variable">$</span>{OUTPUT}</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">{</span>OBJS<span class="token punctuation">}</span>    <span class="token variable">$</span><span class="token punctuation">{</span>AR<span class="token punctuation">}</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">{</span>LDFLAGS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>OBJS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>LIBS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>EXTRA_LIBS<span class="token punctuation">}</span></code></pre><p>这里需要注意：</p><ul><li><p>库的命名：libXXX.a</p></li><li><p>静态链接库的链接：使用ar命令，该命令在Ubuntu和MacOS中是不同的</p><ul><li>这里是将之前编译得到的.o文件链接为静态链接库libtinyxml.a。</li></ul></li></ul><h3 id="编译动态链接库"><a href="#编译动态链接库" class="headerlink" title="编译动态链接库"></a>编译动态链接库</h3><p>编译动态链接库相比于静态的方式要复杂一些。</p><pre class=" language-makefile"><code class="language-makefile"><span class="token comment" spellcheck="true"># 加-fPIC</span>DEBUG_CFLAGS     <span class="token operator">:=</span> -Wall -Wno-format -g -DDEBUG -fPICRELEASE_CFLAGS   <span class="token operator">:=</span> -Wall -Wno-unknown-pragmas -Wno-format -O3 -fPICOUTPUT <span class="token operator">:=</span> libtinyxml.so<span class="token comment" spellcheck="true"># 加 -shared和-fPIC</span><span class="token symbol"><span class="token variable">$</span>{OUTPUT}</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">{</span>OBJS<span class="token punctuation">}</span>    <span class="token variable">$</span><span class="token punctuation">{</span>LD<span class="token punctuation">}</span> -shared -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">{</span>LDFLAGS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>OBJS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>LIBS<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>EXTRA_LIBS<span class="token punctuation">}</span> -fPIC</code></pre><blockquote><p>这里还有一个趣事，我在添加-shared的时候出现了问题，误用了短横线，导致命令一直执行错误，没想到这个短横线还有不同，如<a href="https://www.thetype.com/2019/03/14918/">文章</a>所示，这些Unicode符号看起来真的很像。</p></blockquote><h1 id="如何使用静态链接库和动态链接库？"><a href="#如何使用静态链接库和动态链接库？" class="headerlink" title="如何使用静态链接库和动态链接库？"></a>如何使用静态链接库和动态链接库？</h1><p>完成静态连接和动态连接库的构建后，如何使用它们呢？两者的区别是链接的方式不同。</p><p>这准备一个小的demo演示一下如何使用tinyxml。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// demo.cpp</span><span class="token macro property">#<span class="token directive keyword">define</span> TIXML_USE_STL</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"tinyxml.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    TiXmlDocument doc<span class="token punctuation">;</span>    <span class="token keyword">bool</span> loadOkay <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">LoadFile</span><span class="token punctuation">(</span><span class="token string">"utf8test.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>loadOkay<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"load error"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    doc<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>另外一些需要主要的地方是，保证<code>#define TIXML_USE_STL</code>，如果没有这个宏会出现如下错误：</p><blockquote><p>.text._ZN11TiXmlString4quitEv[<em>ZN11TiXmlString4quitEv]+0x16): undefined reference to `TiXmlString::nullrep</em>‘</p></blockquote><p>源文件的目录结构如下：</p><pre class=" language-makedown"><code class="language-makedown">|——tinyxml|   |——tinyxml.h|   |——libtinyxml.so|   |——libtinyxml.a|   |——demo.cpp</code></pre><h2 id="使用静态链接库"><a href="#使用静态链接库" class="headerlink" title="使用静态链接库"></a>使用静态链接库</h2><p>为了通过静态链接来使用tinyxml，可以有两种方式：</p><ul><li><p>第一种：直接指定静态链接库libtinyxml.a</p><pre class=" language-shell"><code class="language-shell">g++ -static demo.cpp libtinyxml.a -o demo</code></pre></li><li><p>第二种</p><pre class=" language-shell"><code class="language-shell">g++ -static demo.cpp -L . -ltinyxml -o demo</code></pre><p>  这种是通过指定库的加载位置和库的名称实现的：</p><ul><li><code>-L .</code>：表明会在当前目录搜索静态链接库；</li><li><code>-ltinyxml</code>：表示加载名称为libtinyxml.a的静态链接库，这里加载的是静态链接库还是动态链接库取决于是否有<code>-static</code>参数；</li></ul></li></ul><p>对于生成的可执行文件，如何判断是静态链接还是动态链接，这里可以使用两个命令：</p><ul><li><p><code>file demo</code>：判断是否为静态链接；</p><blockquote><p>demo: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=8319f8bcb8d2217e10d165b27c402fa5470a61ba, not stripped</p></blockquote></li><li><p><code>ldd demo</code>：通过分析动态链接库的依赖关系，判断是否是动态链接；</p><blockquote><p>not a dynamic executable.</p></blockquote></li></ul><h2 id="使用动态链接库"><a href="#使用动态链接库" class="headerlink" title="使用动态链接库"></a>使用动态链接库</h2><p>使用动态链接库进行编译时，使用如下命令：</p><pre class=" language-shell"><code class="language-shell">g++ demo.cpp -L . -ltinyxml  -o demo</code></pre><p>但是实际运行时会报出如下错误：</p><blockquote><p>./demo: error while loading shared libraries: libtinyxml.so: cannot open shared object file: No such file or directory.</p></blockquote><p>根据错误信息发现，缺少对应的so库，可以通过<code>ldd</code>查看少了哪些so：</p><pre class=" language-ini"><code class="language-ini">linux-vdso.so.1 (0x00007ffc2c7c7000)<span class="token constant">libtinyxml.so</span> <span class="token attr-value"><span class="token punctuation">=</span>> not found</span><span class="token constant">libstdc++.so.6</span> <span class="token attr-value"><span class="token punctuation">=</span>> /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f365757f000)</span><span class="token constant">libgcc_s.so.1</span> <span class="token attr-value"><span class="token punctuation">=</span>> /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f3657367000)</span><span class="token constant">libc.so.6</span> <span class="token attr-value"><span class="token punctuation">=</span>> /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3656f76000)</span><span class="token constant">libm.so.6</span> <span class="token attr-value"><span class="token punctuation">=</span>> /lib/x86_64-linux-gnu/libm.so.6 (0x00007f3656bd8000)</span>/lib64/ld-linux-x86-64.so.2 (0x00007f3657b0b000)</code></pre><p>明显是libtinyxml.so找不到，说明在编译demo可执行文件的时候，找到了对应的so，但是在demo可执行文件中并没有保存该so的路径信息，因此在运行时会找不到，这里可以通过设置一个环境变量来解决：</p><pre class=" language-shell"><code class="language-shell"># 将当前目录添加到动态链接库的搜索路径中export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.</code></pre><p>此时重新执行./demo就发现正常运行了。这个环境变量说明的是在运行中dynamic link loader如何链接该动态链接库，如<a href="https://linuxhint.com/what-is-ld-library-path/">文章</a>所述，当然解决这个问题的不止一种方法，甚至该方法只能算是临时方法，不是最推荐的方法，但是本文不打算详述所有方法，那是另一个话题了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文的内容主要包括以下内容：</p><ul><li>初步认识&amp;了解make和makefile；</li><li>完成了libtinyxml的编译；</li><li>学习了如何编译和使用静态链接库和动态链接库；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> make </tag>
            
            <tag> makefile </tag>
            
            <tag> 静态链接库 </tag>
            
            <tag> 动态链接库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用vulkan绘制一个三角形</title>
      <link href="/2023/02/12/ji-suan-ji-tu-xing-xue/vulkan/shi-yong-vulkan-hui-zhi-yi-ge-san-jiao-xing/"/>
      <url>/2023/02/12/ji-suan-ji-tu-xing-xue/vulkan/shi-yong-vulkan-hui-zhi-yi-ge-san-jiao-xing/</url>
      
        <content type="html"><![CDATA[<p>学习一门技术，总是从最简单的方式入手，逐步理解这门技术的基本组成和运行过程，对于Vulkan也不例外，但是由于Vulkan本身的特点，即所有的设置都需要显式给出，因此即便一个非常简单的hello world程序，在Vulkan中也颇为复杂。</p><p>Vulkan tutorials中通过绘制三角形，描述了Vulkan中的各种对象，以及整个程序的运行流程，但是这种方式很容易让人陷入到API的细节中，导致只见树木不见森林，因此，本篇文章是在学完了Vulkan tutorials的绘制三角形部分后，重新查看代码，梳理过程得到的回顾性文章。</p><p>通过本文章，你可以：</p><ul><li>了解Vulkan运行所需的基本对象；</li><li>Vulkan程序运行的一般流程；</li></ul><p>你不会知道：</p><ul><li>Vulkan API使用的详细方式；</li><li>文中每个涉及到的API中字段的具体含义；</li></ul><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>对于一个Vulkan程序，在初始化阶段需要完成几件工作：</p><ul><li>检查并开启validation layers</li><li>检查并开启extensions</li><li>创建instance</li><li>检查可用的physical devices</li><li>创建代表physical devices的logical devices</li></ul><h2 id="检查并开启validation-layers-optional"><a href="#检查并开启validation-layers-optional" class="headerlink" title="检查并开启validation layers(optional)"></a>检查并开启validation layers(optional)</h2><p>这一步不是必须的，但是为了检查检查和处理错误，一般在debug阶段都需要开启，其作为函数调用过程的hook存在，可以起到profiling/replay等很多作用。</p><p>检查可用的validation layers的伪代码如下：</p><pre class=" language-cpp"><code class="language-cpp">uint32_t layerCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// query available layers</span><span class="token function">vkEnumerateInstanceLayerProperties</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>layerCount<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// return layers name</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>VkLayerProperties<span class="token operator">></span> <span class="token function">availableLayers</span><span class="token punctuation">(</span>layerCount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkEnumerateInstanceLayerProperties</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>layerCount<span class="token punctuation">,</span> availableLayers<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>一般需要找到对应<code>VK_LAYER_KHRONOS_validation</code>的layer才可以。</p><h2 id="检查开启extensions-optional"><a href="#检查开启extensions-optional" class="headerlink" title="检查开启extensions(optional)"></a>检查开启extensions(optional)</h2><p>这个步骤对于Vulkan程序甚至也不是必须的，如果是为了渲染任务，需要将渲染结果显示在屏幕上，则需要和Window系统打交道，则需要开启一系列的extension，如<code>VK_KHR_surface</code>；或者在MacOS等原生不支持Vulkan的平台上开发程序，则需要<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_metal_surface.html"><code>VK_EXT_metal_surface</code></a>。</p><p>但是渲染不一定要展现，或者Vulkan程序执行的是computer任务，因此这一步也是可选的。</p><p>检查可用的extensions与validation layers的步骤类似：</p><pre class=" language-cpp"><code class="language-cpp">uint32_t extensionCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">vkEnumerateInstanceExtensionProperties</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>extensionCount<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>VkExtensionProperties<span class="token operator">></span> <span class="token function">extensions</span><span class="token punctuation">(</span>extensionCount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkEnumerateInstanceExtensionProperties</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>extensionCount<span class="token punctuation">,</span> extensions<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其实，extensions是针对特定的layer的，因为这里将<code>pLayerName</code>设置为<code>nullptr</code>，所以只会返回Vulkan提供的extensions实现。</p><h2 id="创建Instance"><a href="#创建Instance" class="headerlink" title="创建Instance"></a>创建Instance</h2><p>上述两个步骤都是为了创建instance做准备，<code>VkInstance</code>存储着每个application的state信息，即每个application都要有一个对应的instance实例。</p><p>在创建<code>VkInstance</code>实例时，除了一般的信息，其中最重要的就是对上述的validation layer和extension的验证，创建instance的代码如下：</p><pre class=" language-cpp"><code class="language-cpp">VkInstanceCreateInfo createInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>createInfo<span class="token punctuation">.</span>enabledExtensionCount <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>uint32_t<span class="token operator">></span><span class="token punctuation">(</span>extensions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>createInfo<span class="token punctuation">.</span>ppEnabledExtensionNames <span class="token operator">=</span> extensions<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>createInfo<span class="token punctuation">.</span>enabledLayerCount <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>uint32_t<span class="token operator">></span><span class="token punctuation">(</span>validationLayers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>createInfo<span class="token punctuation">.</span>ppEnabledLayerNames <span class="token operator">=</span> validationLayers<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkCreateInstance</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>createInfo<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>此时，针对一个application，我们配置好了相关的信息。之后，为了让GPU做事，需要对相关的组件进行配置。</p><h2 id="查询Physical-devices"><a href="#查询Physical-devices" class="headerlink" title="查询Physical devices"></a>查询Physical devices</h2><p>在Vulkan中，GPU硬件是通过Physical devices表示的。</p><blockquote><p>A physical device usually represents a single complete implementation of Vulkan (excluding instance-level functionality) available to the host, of which there are a finite number.</p></blockquote><p>因为代表具体的硬件，所以是真实存在并且有限的，为了在程序中使用需要查询具体有多少physical devices。在Vulkan中physical devices通过<code>VkPhysicalDevice</code>来表示。</p><pre class=" language-cpp"><code class="language-cpp">uint32_t deviceCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">vkEnumeratePhysicalDevices</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token operator">&amp;</span>deviceCount<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>VkPhysicalDevice<span class="token operator">></span> <span class="token function">devices</span><span class="token punctuation">(</span>deviceCount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkEnumeratePhysicalDevices</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token operator">&amp;</span>deviceCount<span class="token punctuation">,</span> devices<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>因为physical devices是对应物理组件的，因此我们是check，而不是create。</p><h2 id="创建logical-devices"><a href="#创建logical-devices" class="headerlink" title="创建logical devices"></a>创建logical devices</h2><p>虽然GPU硬件通过physical devices可以表示，但是在真实使用过程中，我们一般使用其lgocal representation，即logical devices，通过<code>VkDevice</code>表示。</p><blockquote><p>A logical device represents an instance of that implementation(physical devices) with its own state and resources independent of other logical devices.</p></blockquote><p><code>VkDevice</code>实例是几乎所有Vulkan API使用的核心对象，而后续使用的如<code>queue</code>等核心对象也是根据其构建出来的。</p><p>为了创建<code>VkDevice</code>需要完成以下工作：</p><ul><li>查询符合条件的queue</li><li>检查可用的validation layer和extensions</li></ul><h3 id="查询可用的queue"><a href="#查询可用的queue" class="headerlink" title="查询可用的queue"></a>查询可用的queue</h3><p><a href="https://github.com/KhronosGroup/Vulkan-Guide/blob/master/chapters/queues.adoc">queue是application向GPU提交任务的渠道</a>，作为application和GPU之间的中介，决定了任务如何被提交以及执行的顺序。</p><p>类似于沟通不同车站的各种道路，queue也被划分为不同的类型，比如用于渲染的graphics pipeline command和用于compute的compute pipeline等。我的理解是这样可以提高效率，就像自行车道和高速通道不能合并一样，否则两个都做不好。</p><p>对于渲染任务，需要<code>VK_QUEUE_GRAPHICS_BIT</code>类型的queue，因此需要首先找到该queue。</p><pre class=" language-cpp"><code class="language-cpp">uint32_t queueFamilyCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queueFamilyCount<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>VkQueueFamilyProperties<span class="token operator">></span> <span class="token function">queueFamilies</span><span class="token punctuation">(</span>queueFamilyCount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queueFamilyCount<span class="token punctuation">,</span> queueFamilies<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>然后对所有的queue families遍历得到对应的index，然后从该device中得到对应的queue。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">vkGetDeviceQueue</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>graphicsQueue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="检查可用的validation-layer和extensions"><a href="#检查可用的validation-layer和extensions" class="headerlink" title="检查可用的validation layer和extensions"></a>检查可用的validation layer和extensions</h3><p>在创建instance时，会检查并开启对应的validation layers和extensions，在创建device时也会有类似的操作。</p><p>Vulkan中提供了两种类型的extensions：</p><ul><li>Instance-specific: This provides global-level extensions </li><li>Device-specific: This provides physical-device-specific extensions</li></ul><p>伪代码如下：</p><pre class=" language-cpp"><code class="language-cpp">VkDeviceCreateInfo createInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>createInfo<span class="token punctuation">.</span>ppEnabledExtensionNames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"VK_KHR_swapchain"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>createInfo<span class="token punctuation">.</span>ppEnabledLayerNames <span class="token operator">=</span> validationLayers<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkCreateDevice</span><span class="token punctuation">(</span>physicalDevice<span class="token punctuation">,</span> <span class="token operator">&amp;</span>createInfo<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>device<span class="token punctuation">)</span></code></pre><blockquote><p>其中要注意一点，根据<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Logical_device_and_queues">此文</a>，device-specific的validation layer已经在最新版中被忽略了，即可以不用考虑了，但是为了兼容旧版本，还是建议加上。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个过程总结如下图：hexo</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/1.png" alt="初始化的过程以及涉及到的Vulkan对象"></p><h1 id="Presentation-optional"><a href="#Presentation-optional" class="headerlink" title="Presentation(optional)"></a>Presentation(optional)</h1><p>对于渲染结果的显示并不是必须的，但是为了查看Vulkan程序是否运行正常，一般都需要加上对于显示的支持。由于不是必需的操作，所以关于渲染结果的呈现，一般是通过extension实现的。</p><p>在初始化阶段，有两个地方涉及到extensions的开启：</p><ul><li>一个是创建instance时；</li><li>另一个是创建logical devices时；</li></ul><p>因此，为了实现渲染结果的展示，需要借用上述的步骤，完成相关WSI extensions的开启。</p><p>为了presentation，需要完成以下几件事情：</p><ul><li>开启相关的extensions</li><li>检查并创建window和surface</li><li>创建用于presentation的queue</li><li>创建swapchain并添加关联的images</li><li>获取swapchain中的image并创建对应的imageview</li></ul><h2 id="开启presentation使用的extensions"><a href="#开启presentation使用的extensions" class="headerlink" title="开启presentation使用的extensions"></a>开启presentation使用的extensions</h2><p>首先需要开启<code>VK_KHR_surface</code> extension，需要在instance创建时指定。</p><pre class=" language-cpp"><code class="language-cpp">VkInstanceCreateInfo createInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>createInfo<span class="token punctuation">.</span>enabledExtensionCount <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>uint32_t<span class="token operator">></span><span class="token punctuation">(</span>extensions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>createInfo<span class="token punctuation">.</span>ppEnabledExtensionNames <span class="token operator">=</span> extensions<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果使用glfw的话，为了创建window，这个extension是必须的，因此可以直接从glfw的API中获得：</p><pre class=" language-cpp"><code class="language-cpp">uint32_t glfwExtensionCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> glfwExtensions<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// glfw require vulkan extension</span>glfwExtensions <span class="token operator">=</span> <span class="token function">glfwGetRequiredInstanceExtensions</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>glfwExtensionCount<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>另外，还需要开启<code>VK_KHR_swapchain</code>，这是一个device-level的extension，需要在创建logical device时开启，如上文已经在<strong>检查可用的validation layer和extensions</strong>部分给出。</p><h2 id="检查并创建window和surface"><a href="#检查并创建window和surface" class="headerlink" title="检查并创建window和surface"></a>检查并创建window和surface</h2><p>vulkan API均为平台独立的，即与任意平台均解耦，但是为了将渲染的结果显示在window，必须处理平台特定的操作，这是十分繁杂的。而glfw library为我们处理好一切细节问题，因此我们可以直接使用glfw创建window。</p><pre class=" language-cpp"><code class="language-cpp">GLFWwindow <span class="token operator">*</span>window <span class="token operator">=</span> <span class="token function">glfwCreateWindow</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token string">"Vulkan"</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>完成了window的创建后，在开启上述相关extensions的基础上，需要创建<code>VkSurfaceKHR</code>对象，这个对象是一个对native platform的抽象表示，用来将渲染的结果呈现在上面。</p><pre class=" language-cpp"><code class="language-cpp">VkSurfaceKHR surface<span class="token punctuation">;</span><span class="token function">glfwCreateWindowSurface</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> window<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>surface<span class="token punctuation">)</span></code></pre><p>这里也可以直接调用glfw的API直接完成创建。</p><h2 id="创建用于presentation的queue"><a href="#创建用于presentation的queue" class="headerlink" title="创建用于presentation的queue"></a>创建用于presentation的queue</h2><p>虽然vulkan 支持 window system integration，但是并不意味着底层的device在硬件的level上支持WSI，因此需要对device上的每个queue进行检查，找到支持presentation的queue。</p><pre class=" language-cpp"><code class="language-cpp">VkBool32 presentSupport <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>for_each queue in queues_in_device<span class="token operator">:</span>    <span class="token function">vkGetPhysicalDeviceSurfaceSupportKHR</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> queuefamily<span class="token punctuation">.</span>index<span class="token punctuation">,</span> surface<span class="token punctuation">,</span> <span class="token operator">&amp;</span>presentSupport<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当确认了存在这样的一个queue，就需要从device中得到该queue。</p><pre class=" language-cpp"><code class="language-cpp">VkQueue presentQueue<span class="token punctuation">;</span><span class="token function">vkGetDeviceQueue</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> queueFamily<span class="token punctuation">.</span>index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>presentQueue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="创建swapchain"><a href="#创建swapchain" class="headerlink" title="创建swapchain"></a>创建swapchain</h2><p>在vulkan中没有类似openGL中<a href="https://www.khronos.org/opengl/wiki/Default_Framebuffer">default framebuffer</a>概念，与之对应的是swapchain，用来存储待显示到屏幕的渲染结果，其本质上就是一个image queue，用来暂存一系列渲染结果。</p><p>在前面，我们已经开启swapchain对应的extension了，但是这样并不够，还要确认swapchain的一系列特性，包括以下：</p><pre class=" language-cpp"><code class="language-cpp">VkSurfaceCapabilitiesKHR capabilities<span class="token punctuation">;</span><span class="token function">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> surface<span class="token punctuation">,</span> <span class="token operator">&amp;</span>details<span class="token punctuation">.</span>capabilities<span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>VkSurfaceFormatKHR<span class="token operator">></span> formats<span class="token punctuation">;</span>uint32_t formatCount<span class="token punctuation">;</span><span class="token function">vkGetPhysicalDeviceSurfaceFormatsKHR</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> surface<span class="token punctuation">,</span> <span class="token operator">&amp;</span>formatCount<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkGetPhysicalDeviceSurfaceFormatsKHR</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> surface<span class="token punctuation">,</span> <span class="token operator">&amp;</span>formatCount<span class="token punctuation">,</span> formats<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>VkPresentModeKHR<span class="token operator">></span> presentModesuint32_t presentModeCount<span class="token punctuation">;</span><span class="token function">vkGetPhysicalDeviceSurfacePresentModesKHR</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> surface<span class="token punctuation">,</span> <span class="token operator">&amp;</span>presentModeCount<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkGetPhysicalDeviceSurfacePresentModesKHR</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> surface<span class="token punctuation">,</span> <span class="token operator">&amp;</span>presentModeCount<span class="token punctuation">,</span> presentModes<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>VkSwapchainCreateInfoKHR createInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">vkCreateSwapchainKHR</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>createInfo<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>swapChain<span class="token punctuation">)</span></code></pre><h2 id="获取swapchain中的image并创建对应的imageview"><a href="#获取swapchain中的image并创建对应的imageview" class="headerlink" title="获取swapchain中的image并创建对应的imageview"></a>获取swapchain中的image并创建对应的imageview</h2><p>在创建完成swapchain之后，需要取出其中的image，这些image在渲染过程中需要作为渲染对象使用。</p><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>VkImage<span class="token operator">></span> swapChainImages<span class="token punctuation">;</span>uint32_t imageCount<span class="token punctuation">;</span><span class="token function">vkGetSwapchainImagesKHR</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> swapChain<span class="token punctuation">,</span> <span class="token operator">&amp;</span>imageCount<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>swapChainImages<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>imageCount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkGetSwapchainImagesKHR</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> swapChain<span class="token punctuation">,</span> <span class="token operator">&amp;</span>imageCount<span class="token punctuation">,</span> swapChainImages<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>为了在渲染过程中使用这些image，需要创建imageview，可以将imageview视为数据库中的关系表的视图（可以用来进行权限隔离），确定了访问哪部分image数据，怎么访问image中的数据。</p><pre class=" language-cpp"><code class="language-cpp">VkImageView imageView<span class="token punctuation">;</span>VkImageViewCreateInfo createInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">vkCreateImageView</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>createInfo<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>imageView<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/2.png" alt="为渲染对象进行presentation的准备工作"></p><h1 id="准备renderpass"><a href="#准备renderpass" class="headerlink" title="准备renderpass"></a>准备renderpass</h1><p>在之前，我们已经完成了初始化，并且知道要将最终的渲染结果显示到哪里去。但是在渲染过程中，涉及到很多的步骤，每个步骤都需要输出中间结果，这个中间结果可能被后续的步骤使用，那么如何设置这些中间结果呢？首先，要明确的是，这些中间结果都需要存储在内存中，以便被后续的步骤读取，Vulkan中提出了一个概念——<strong>renderpass</strong>，专门用来设置中间渲染结果的存储位置以及如何使用这些存储，它描述了整个渲染过程中数据的流向是怎样的。</p><p>renderpass的创建，完全依赖于<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo.html">VkRenderPassCreateInfo</a>，其中需要三类信息，但是归根到底，涉及两类对象：</p><ul><li>subpass：出于优化的考虑，将renderpass可以划分为不同的subpass；</li><li>attachments：本质是一系列的image，用来在渲染过程中使用。这个术语有点意思，不直接叫images，而是作为attachments，放到renderpass中。</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/3.png" alt="创建renderpass需要的信息"></p><p>因此，我们需要完成以下工作：</p><ul><li>考虑需要的attachments</li><li>构建subpass</li><li>创建framebuffer</li></ul><h2 id="添加attachments"><a href="#添加attachments" class="headerlink" title="添加attachments"></a>添加attachments</h2><p>因为attachments本质上是images，就是用来存储渲染过程中的中间结果的。一般在渲染前和渲染后都可以指定相应的操作，如代码所示：</p><pre class=" language-cpp"><code class="language-cpp">VkAttachmentDescription colorAttachment<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指定image view的format</span>colorAttachment<span class="token punctuation">.</span>format <span class="token operator">=</span> swapChainImageFormat<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指定在渲染开始时，先将attachment对应的image内容clear</span>colorAttachment<span class="token punctuation">.</span>loadOp <span class="token operator">=</span> VK_ATTACHMENT_LOAD_OP_CLEAR<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指定在渲染结束后，将attachment对应的image存储到对应的内存中以便后续读取</span>colorAttachment<span class="token punctuation">.</span>storeOp <span class="token operator">=</span> VK_ATTACHMENT_STORE_OP_STORE<span class="token punctuation">;</span></code></pre><p>可以分别为color与depth信息建立各自的attachments。</p><p>注意，这里的attachments还未与真正的image view建立关联，这需要通过framebuffer来实现。</p><h2 id="设置renderpass的subpass"><a href="#设置renderpass的subpass" class="headerlink" title="设置renderpass的subpass"></a>设置renderpass的subpass</h2><blockquote><p>A subpass represents <strong>a phase of rendering that reads and writes a subset of the attachments</strong> in a render pass. Rendering commands are recorded into a particular subpass of a render pass instance.</p></blockquote><p>为了优化操作，renderpass进一步分为了subpass。subpass也是需要使用attachments，方式如下：</p><pre class=" language-cpp"><code class="language-cpp">VkAttachmentReference colorAttachmentRef<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>VkSubpassDescription subpass<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>subpass<span class="token punctuation">.</span>colorAttachmentCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>subpass<span class="token punctuation">.</span>pColorAttachments <span class="token operator">=</span> <span class="token operator">&amp;</span>colorAttachmentRef<span class="token punctuation">;</span></code></pre><p>另外，subpass之间可以存在依赖关系，类似于execution dependencies和memory dependencies，只不过不用Vulkan中的sync primitives而已。</p><pre class=" language-cpp"><code class="language-cpp">VkSubpassDependency dependency<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>完成了上述两个步骤后，就可以创建renderpass对象了：</p><pre class=" language-cpp"><code class="language-cpp">VkRenderPassCreateInfo renderPassInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">vkCreateRenderPass</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>renderPassInfo<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>renderPass<span class="token punctuation">)</span></code></pre><h2 id="创建framebuffer"><a href="#创建framebuffer" class="headerlink" title="创建framebuffer"></a>创建framebuffer</h2><blockquote><p><strong>Framebuffers represent a collection of specific memory attachments</strong> that a render pass instance uses.</p></blockquote><p>上述renderpass中的attachments中只提供了各种描述信息，那么如何访问这些attachments，需要和memory建立关系，这就需要通过framebuffer。</p><p>创建一个framebuffer，需要绑定到特定的renderpass中，这保证该framebuffer只在该renderpass中使用。因为，framebuffer是将renderpass中的attachments与memory建立关系，因此需要在创建过程中直接引用。</p><pre class=" language-cpp"><code class="language-cpp">VkFramebuffer framebuffer<span class="token punctuation">;</span>VkImageView attachments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>VkFramebufferCreateInfo framebufferInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>framebufferInfo<span class="token punctuation">.</span>renderPass <span class="token operator">=</span> renderPass<span class="token punctuation">;</span>framebufferInfo<span class="token punctuation">.</span>attachmentCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在renderpass中作为attachments使用</span>framebufferInfo<span class="token punctuation">.</span>pAttachments <span class="token operator">=</span> attachments<span class="token punctuation">;</span><span class="token function">vkCreateFramebuffer</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>framebufferInfo<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> framebuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>为了创建renderpass，我们需要attachments，这些attachments指定了renderpass过程中针对中间渲染结果的配置信息，并且通过framebuffer与memory建立联系；之后renderpass细分的subpass可以利用这些attachments信息执行相关操作。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/4.png" alt="创建renderpass"></p><h1 id="创建descriptor-set"><a href="#创建descriptor-set" class="headerlink" title="创建descriptor set"></a>创建descriptor set</h1><p>这一步是创建pipeline必需的，简单来讲，作为渲染pipeline中的核心组件之一——shader，是如何访问内存资源的呢？就是通过descriptor，其告诉shader如何找到所需的内存资源。</p><p><a href="https://github.com/David-DiGioia">David-DiGioia</a>hu绘制了一张图，对于理解：</p><ul><li>如何建立shader和descriptor之间的关系；</li><li>如何创建descriptor set；</li><li>如何在pipeline中访问descriptor set；</li><li>以及如何更新；<br>非常有帮助，如下：</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/7.png" alt="Descriptor sets以及与其他对象的关系"></p><p>在这个过程中，对于desciptor set的创建，很清晰的描述。涉及不同的Vulkan对象，</p><ul><li>A descriptor is an opaque data structure representing a shader resource;</li><li>Descriptors are organized into descriptor sets, which are bound during command recording for use in subsequent drawing commands;</li><li>The arrangement of content in each descriptor set is determined by a descriptor set layout;</li></ul><p>过程总结如下：</p><ul><li>创建descriptor pool：提高desciptor的使用效率；</li><li>指定descriptor layout：提供了descriptor的type信息；</li><li>从descriptor pool中根据descriptor layout中的信息分配desciptor set；</li></ul><p>可视化的过程如<a href="https://www.reddit.com/r/vulkan/comments/b4uj52/visual_explanation_of_descriptor_sets_i_made_a/">文章</a>所示，如下图：<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/8.png" alt="descriptor set的构建过程"></p><h2 id="设置descriptor-layout"><a href="#设置descriptor-layout" class="headerlink" title="设置descriptor layout"></a>设置descriptor layout</h2><p>这个过程，简单来说，就是为pipeline中的shaders要使用的内存资源，提供type信息，例如uniform buffer，可以直接访问buffer。</p><p>创建descriptor layout的代码如下：</p><pre class=" language-cpp"><code class="language-cpp">VkDescriptorSetLayoutBinding layoutBind<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> layoutBind<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>descriptorType <span class="token operator">=</span> VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER<span class="token punctuation">;</span>layoutBind<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>binding <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> layoutBind<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>stageFlags <span class="token operator">=</span> VK_SHADER_STAGE_VERTEX_BIT<span class="token punctuation">;</span>layoutBind<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>descriptorType <span class="token operator">=</span>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER<span class="token punctuation">;</span> layoutBind<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>binding <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>layoutBind<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>stageFlags <span class="token operator">=</span> VK_SHADER_STAGE_FRAGMENT_BIT<span class="token punctuation">;</span>VkDescriptorSetLayoutCreateInfo descriptorLayout <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>descriptorLayout<span class="token punctuation">.</span>pBindings <span class="token operator">=</span> layoutBind<span class="token punctuation">;</span>VkDescriptorSetLayout descLayout<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">vkCreateDescriptorSetLayout</span> <span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>descriptorLayout<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> descLayout<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="创建descriptor-pool"><a href="#创建descriptor-pool" class="headerlink" title="创建descriptor pool"></a>创建descriptor pool</h2><p>在Vulkan中，descriptor sets不能直接创建，而是需要从descriptor pool中分配。descriptor pool的创建需要<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateInfo.html">VkDescriptorPoolCreateInfo</a>提供的信息。</p><pre class=" language-cpp"><code class="language-cpp">VkDescriptorPool descriptorPool<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// pool中有VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER类型的descriptors共10个</span>VkDescriptorPoolSize poolSize<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> poolSize<span class="token punctuation">.</span>type <span class="token operator">=</span> VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER<span class="token punctuation">;</span> poolSize<span class="token punctuation">.</span>descriptorCount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>VkDescriptorPoolCreateInfo poolInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> poolInfo<span class="token punctuation">.</span>pPoolSizes <span class="token operator">=</span> <span class="token operator">&amp;</span>poolSize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最多可以从该pool中分配3个descriptor sets</span>poolInfo<span class="token punctuation">.</span>maxSets <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token function">vkCreateDescriptorPool</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>poolInfo<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>descriptorPool<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="分配descriptor-set"><a href="#分配descriptor-set" class="headerlink" title="分配descriptor set"></a>分配descriptor set</h2><p>从descriptor pool中分配descriptor sets按照如下的方式：</p><pre class=" language-cpp"><code class="language-cpp">VkDescriptorSetAllocateInfo allocInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>allocInfo<span class="token punctuation">.</span>descriptorPool <span class="token operator">=</span> descriptorPool<span class="token punctuation">;</span>allocInfo<span class="token punctuation">.</span>pSetLayouts <span class="token operator">=</span> descLayout<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkAllocateDescriptorSets</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>allocInfo<span class="token punctuation">,</span> descriptorSets<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>之后就可以正常使用descriptor sets了。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>descriptor sets的整个创建过程总结如下：<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/9.png" alt="descriptor sets的生成过程"></p><h1 id="创建pipeline"><a href="#创建pipeline" class="headerlink" title="创建pipeline"></a>创建pipeline</h1><p>pipeline将渲染过程中的一系列操作打包在一起，从读取vertex和texture的数据，到最终将渲染的结果写到swapchain中。通过其中的每个步骤设置相关的states，使得渲染过程能够顺序进行。</p><p>Vulkan spec中将pipeline划分为以下几个阶段：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/5.png" alt="Vulkan Spec中的pipeline"></p><p>其中，pipeline中的stages具体可以分为两种类型：</p><ul><li>fixed function stage：不可编程，基本由硬件实现，但是可以设置参数；</li><li>shader stage：可编程，即通过shader改变渲染的行为；</li></ul><p>整个pipeline创建过程中的核心工作，就是为了这些stages设置合适的state参数，以便后续的command能够顺利执行。</p><h2 id="构建shader-modules"><a href="#构建shader-modules" class="headerlink" title="构建shader modules"></a>构建shader modules</h2><p>在pipeline中使用的shaders，一般是SPIR-V格式的，可以通过GLSL格式转换而来。如果在Vulkan中使用，需要嵌入VkShaderModule中，代码如下：</p><pre class=" language-cpp"><code class="language-cpp">VkShaderModuleCreateInfo createInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>createInfo<span class="token punctuation">.</span>codeSize <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 绑定SPIR-V格式的shader代码</span>createInfo<span class="token punctuation">.</span>pCode <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>VkShaderModule shaderModule<span class="token punctuation">;</span><span class="token function">vkCreateShaderModule</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>createInfo<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shaderModule<span class="token punctuation">)</span><span class="token punctuation">;</span>VkPipelineShaderStageCreateInfo shaderStage<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>shaderStage<span class="token punctuation">.</span>stage <span class="token operator">=</span> VK_SHADER_STAGE_FRAGMENT_BIT<span class="token punctuation">;</span>shaderStage<span class="token punctuation">.</span>module <span class="token operator">=</span> shaderModule<span class="token punctuation">;</span>shaderStage<span class="token punctuation">.</span>pName <span class="token operator">=</span> <span class="token string">"main"</span><span class="token punctuation">;</span></code></pre><h2 id="设置-fixed-stages的状态"><a href="#设置-fixed-stages的状态" class="headerlink" title="设置 fixed stages的状态"></a>设置 fixed stages的状态</h2><p>根据pipeline中不同的stages，需要设置不同的state，这些states在<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineCreateInfo.html">VkGraphicsPipelineCreateInfo</a> 中指明。</p><p>下图来自于<a href="https://web.engr.oregonstate.edu/~mjb/vulkan/Handouts/Intro.1pp.pdf">这里</a>，表明了创建pipleine过程中涉及到的各种state。</p><p>其中具体可以分为两类：</p><ul><li>固定的state：即设置之后就不能更改；</li><li>dynamic state：在runtime中可以动态更改，使得不必重新创建pipeline，因为创建pipelien是expensive task，viewport和scissors就属于这一类；</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/6.png" alt="创建pipeline需要设置的state"></p><p>各种状态的设置伪代码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 如何读取和解析vertex data</span>VkPipelineVertexInputStateCreateInfo vertexInputInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>VkPipelineInputAssemblyStateCreateInfo inputAssembly<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 控制viewport transformation</span>VkPipelineViewportStateCreateInfo viewportState<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如何进行光栅化</span>VkPipelineRasterizationStateCreateInfo rasterizer<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如何进行depth/stencil test</span>VkPipelineDepthStencilStateCreateInfo depthStencilState<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 控制如何进行反走样</span>VkPipelineMultisampleStateCreateInfo multisampling<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如何结合此次渲染的结果和之前已有的数据</span>VkPipelineColorBlendStateCreateInfo colorBlend<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置dynamic state, s</span>VkPipelineDynamicStateCreateInfo dynamicState<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="创建pipeline-layout"><a href="#创建pipeline-layout" class="headerlink" title="创建pipeline layout"></a>创建pipeline layout</h2><p>pipeline layout是啥？</p><blockquote><p>Access to descriptor sets from a pipeline is accomplished through a <strong>pipeline layout</strong>.</p></blockquote><p>简单来讲，在pipeline中存在可编程的shader，那么这些shader在运行时如何处理输入和输出数据呢？即，shader需要访问对应的资源，而访问操作是通过descriptor set作为中介实现的。总结下来，shader要访问内存资源，需要通过descriptor set。而shader代码本身作为state信息被绑定到pipeline中，如果想要在pipeline中让shader访问内存资源，就需要将descriptor set与pipeline建立联系，pipeline layout就是联系的中介。</p><p>在完成上文descriptor layout的设置后，就可以将其通过pipeline layout绑定到pipleine中，如下：</p><pre class=" language-cpp"><code class="language-cpp">VkPipelineLayoutCreateInfo pipelineLayoutCI<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>pipelineLayoutCI<span class="token punctuation">.</span>pSetLayouts <span class="token operator">=</span> descLayout<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkCreatePipelineLayout</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pipelineLayoutCI<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pipelineLayout<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="完成pipeline创建"><a href="#完成pipeline创建" class="headerlink" title="完成pipeline创建"></a>完成pipeline创建</h2><p>完成了各种state的设置之后，就需要将它们绑定到pipeline的创建信息中，如下所示：</p><pre class=" language-cpp"><code class="language-cpp">VkGraphicsPipelineCreateInfo pipelineInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>pipelineInfo<span class="token punctuation">.</span>pStages <span class="token operator">=</span> <span class="token operator">&amp;</span>shaderStages<span class="token punctuation">;</span>pipelineInfo<span class="token punctuation">.</span>pVertexInputState <span class="token operator">=</span> <span class="token operator">&amp;</span>vertexInputInfo<span class="token punctuation">;</span>pipelineInfo<span class="token punctuation">.</span>pInputAssemblyState <span class="token operator">=</span> <span class="token operator">&amp;</span>inputAssembly<span class="token punctuation">;</span>pipelineInfo<span class="token punctuation">.</span>pViewportState <span class="token operator">=</span> <span class="token operator">&amp;</span>viewportState<span class="token punctuation">;</span>pipelineInfo<span class="token punctuation">.</span>pRasterizationState <span class="token operator">=</span> <span class="token operator">&amp;</span>rasterizer<span class="token punctuation">;</span>pipelineInfo<span class="token punctuation">.</span>pMultisampleState <span class="token operator">=</span> <span class="token operator">&amp;</span>multisampling<span class="token punctuation">;</span>pipelineInfo<span class="token punctuation">.</span>pDepthStencilState <span class="token operator">=</span> <span class="token operator">&amp;</span>depthStencilState<span class="token punctuation">;</span>pipelineInfo<span class="token punctuation">.</span>pColorBlendState <span class="token operator">=</span> <span class="token operator">&amp;</span>colorBlend<span class="token punctuation">;</span>pipelineInfo<span class="token punctuation">.</span>pDynamicState <span class="token operator">=</span> <span class="token operator">&amp;</span>dynamicState<span class="token punctuation">;</span></code></pre><p>为了完成pipeline的创建，还需要指定pipelinecache/renderpass/pipelinelayout：</p><ul><li><p>VkPipelineCache：因为pipeline的创建是expensive task，而且一般创建pipeline时，变化的state不会很多，因此完全从头开始创建是不划算的，因此可以利用之前创建好的pipeline，提高效率；</p><pre class=" language-cpp"><code class="language-cpp">VkPipelineCache pipelineCache<span class="token punctuation">;</span> VkPipelineCacheCreateInfo pipelineCacheInfo<span class="token punctuation">;</span><span class="token function">vkCreatePipelineCache</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pipelineCacheInfo<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pipelineCache<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>之后指定renderpass，说明该pipeline用在哪个renderpass环境中，即<strong>需要将pipeline与renderpass绑定</strong>。</p><pre class=" language-cpp"><code class="language-cpp">pipelineInfo<span class="token punctuation">.</span>renderPass <span class="token operator">=</span> renderPass<span class="token punctuation">;</span></code></pre></li><li><p>指定pipeline layout；</p><pre class=" language-cpp"><code class="language-cpp">pipelineInfo<span class="token punctuation">.</span>layout <span class="token operator">=</span> pipelineLayout</code></pre></li></ul><p>之后，就可以创建pipeline对象了，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">vkCreateGraphicsPipelines</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> pipelineCache<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pipelineInfo<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pipeline<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>创建pipeline的过程可以总结如下：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/12.png" alt="创建pipeline的过程"></p><h1 id="准备command-buffer"><a href="#准备command-buffer" class="headerlink" title="准备command buffer"></a>准备command buffer</h1><p>到目前为止，我们已经完成了准备工作——初始化，设置好了渲染结果最终的显示地方，同时也设置从渲染开始到渲染结束经过的pipeline。那么之后要完成的工作，就是下达一系列的commands，让device中的queue去执行并最终显示在屏幕上。</p><p>所有要提交给GPU去执行的commands，都要记录在command buffer中，这种方式批量提交commands给GPU，提高了GPU处理commands的效率。而且，还可以利用多线程的优势，将多个command buffer同时提交给GPU去执行。</p><p>为了初始化command buffer需要两个步骤：</p><ul><li>创建command pool</li><li>分配commanbuffer</li></ul><h3 id="创建command-pool"><a href="#创建command-pool" class="headerlink" title="创建command pool"></a>创建command pool</h3><blockquote><p>Command pools manage the memory that is used to store the buffers and command buffers are allocated from them.</p></blockquote><p>类似于descriptor pool与descriptor sets的关系，command buffer也是从command pool中分配得到的，因此首先需要创建command pool。command pool的创建与具体的queue family绑定，代码如下：</p><pre class=" language-cpp"><code class="language-cpp">VkCommandPoolCreateInfo poolInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>poolInfo<span class="token punctuation">.</span>queueFamilyIndex <span class="token operator">=</span> queueFamily<span class="token punctuation">.</span>Index<span class="token punctuation">;</span><span class="token function">vkCreateCommandPool</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>poolInfo<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>commandPool<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="分配command-buffer"><a href="#分配command-buffer" class="headerlink" title="分配command buffer"></a>分配command buffer</h3><p>command buffer均是从command pool中分配得到的，代码如下：</p><pre class=" language-cpp"><code class="language-cpp">VkCommandBufferAllocateInfo allocInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>allocInfo<span class="token punctuation">.</span>commandPool <span class="token operator">=</span> commandPool<span class="token punctuation">;</span>allocInfo<span class="token punctuation">.</span>commandBufferCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">vkAllocateCommandBuffers</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>allocInfo<span class="token punctuation">,</span> <span class="token operator">&amp;</span>commandBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>从command pool中得到的command buffer只能提交到创建该command pool的queue family对应的queues中。</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>整个过程如下：<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/10.png" alt="command buffer的创建过程"></p><h1 id="准备vertex-data"><a href="#准备vertex-data" class="headerlink" title="准备vertex data"></a>准备vertex data</h1><p>为了完成渲染任务，需要向Vulkan API提供vertex data，以组成primitives。vertex data的准备，在vulkan中涉及资源的创建和管理。</p><p>在vulkan tutorials中开始的时候，直接在shader中写入vertex data以及对应的color等信息，但是在一般情况下，这些数据都是由程序写入的。为了完成这个任务，需要将数据从CPU拷贝到GPU，然后GPU才能使用这些数据。具体来说，这个过程包括：</p><ul><li>创建host memory，即CPU对应的memory；</li><li>创建device memory，也就是GPU对应的memory</li></ul><p>在Vulkan中将memory分成了上述两种类型，对于渲染任务来说，直接从device memory中读取数据更快，但是我们的程序运行在CPU侧，不能直接访问device memory，因此：</p><ul><li>需要在host memory和device memory之间建立关系</li></ul><h2 id="创建host-memory"><a href="#创建host-memory" class="headerlink" title="创建host memory"></a>创建host memory</h2><p>这里所说的创建host memory，即加载vertex data到内存中，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Vertex <span class="token punctuation">{</span>    glm<span class="token operator">::</span>vec2 pos<span class="token punctuation">;</span>    glm<span class="token operator">::</span>vec3 color<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Vertex<span class="token operator">></span> vertices <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="创建device-memory"><a href="#创建device-memory" class="headerlink" title="创建device memory"></a>创建device memory</h2><p>在Vulkan中有两类资源，</p><ul><li>buffer：即，普通的内存，这里用于vertex data的存储和传输；</li><li>image：不仅包括普通的内存，包括具体的格式和metadata；</li></ul><p>buffer的创建如下所示：</p><pre class=" language-cpp"><code class="language-cpp">VkBuffer buffer<span class="token punctuation">;</span>VkBufferCreateInfo bufferInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>bufferInfo<span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>bufferInfo<span class="token punctuation">.</span>usage <span class="token operator">=</span> VK_BUFFER_USAGE_TRANSFER_SRC_BIT<span class="token punctuation">;</span><span class="token function">vkCreateBuffer</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bufferInfo<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span></code></pre><p>其中，</p><ul><li>usage表明该buffer中的数据后续可以被copy到另外的地方。</li></ul><p>此时，即便buffer已经被创建成功，但是并没有任何的device memory与之关联，即无法让GPU使用vertex data，因此还需要创建device memory，如下：</p><pre class=" language-cpp"><code class="language-cpp">VkDeviceMemory bufferMemory<span class="token punctuation">;</span>VkMemoryRequirements memRequirements<span class="token punctuation">;</span><span class="token function">vkGetBufferMemoryRequirements</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>memRequirements<span class="token punctuation">)</span><span class="token punctuation">;</span>VkMemoryAllocateInfo allocInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>allocInfo<span class="token punctuation">.</span>allocationSize <span class="token operator">=</span> memRequirements<span class="token punctuation">.</span>size<span class="token punctuation">;</span>VkPhysicalDeviceMemoryProperties memProperties<span class="token punctuation">;</span><span class="token function">vkGetPhysicalDeviceMemoryProperties</span><span class="token punctuation">(</span>physicalDevice<span class="token punctuation">,</span> <span class="token operator">&amp;</span>memProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>allocInfo<span class="token punctuation">.</span>memoryTypeIndex <span class="token operator">=</span> memProperties<span class="token punctuation">.</span>memoryTypes<span class="token punctuation">.</span>index<span class="token punctuation">;</span><span class="token function">vkAllocateMemory</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> <span class="token operator">&amp;</span>allocInfo<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bufferMemory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkBindBufferMemory</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> bufferMemory<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种方式是创建memory的标准模式：</p><ul><li>查询对应buffer的memory创建要求；</li><li>确定memory type</li><li>完成memory的创建</li><li>将memory与resource对象绑定在一起</li></ul><h2 id="memory-mapping-from-device-to-host"><a href="#memory-mapping-from-device-to-host" class="headerlink" title="memory mapping from device to host"></a>memory mapping from device to host</h2><p>device memory不能被host直接访问，需要将device memory mapping到host上，这样对于device memory，则会有一个physical address和两个virtual address，分别对应device和host侧。</p><p>需要注意的一点是device memory默认是对host不可访问的，如果要想完成memory mapping，需要在创建buffer的时候指定<code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> data<span class="token punctuation">;</span><span class="token function">vkMapMemory</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> bufferMemory<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bufferSize<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> vertices<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> bufferSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkUnmapMemory</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> bufferMemory<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用vkMapMemory完成memory mapping后，在host侧得到了对应device memory的pointer，即这里的data，从而操作对应位置的数据。在完成CPU内存中的数据复制到GPU内存中之后，可以结束device memory在host上的mapping，这样之后就不能再通过data来读写GPU内存上的数据了。</p><h2 id="创建device-local-memory"><a href="#创建device-local-memory" class="headerlink" title="创建device-local memory"></a>创建device-local memory</h2><p>到目前为止，已经将CPU memory中的vertex data传输到GPU memory中了，但是这块memory是CPU和GPU都能读写的，并不是在GPU中使用vertex data的最优方法，而最快的内存拥有的properties是<code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>的，因为我们还需要在GPU中，再进行一次数据的搬移。</p><p>因此是在GPU上进行copy，因此所有的commands都需要记录到command buffer中，在正式下达draw call，可以先熟悉一下command buffer recording的过程，</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="token comment" spellcheck="true">// usage=VK_BUFFER_USAGE_TRANSFER_SRC_BIT</span>VkBuffer stagingBuffer<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="token comment" spellcheck="true">// usage=VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span>VkBuffer vertexBuffer<span class="token punctuation">;</span>VkCommandBuffer commandBuffer<span class="token punctuation">;</span>VkCommandBufferBeginInfo beginInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">vkBeginCommandBuffer</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>beginInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    VkBufferCopy copyRegion<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    copyRegion<span class="token punctuation">.</span>srcOffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    copyRegion<span class="token punctuation">.</span>dstOffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    copyRegion<span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token function">vkCmdCopyBuffer</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">,</span> stagingBuffer<span class="token punctuation">,</span> vertexBuffer<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>copyRegion<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkEndCommandBuffer</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>VkSubmitInfo submitInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">vkQueueSubmit</span><span class="token punctuation">(</span>graphicsQueue<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>submitInfo<span class="token punctuation">,</span> VK_NULL_HANDLE<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后将copy命令提交queue中以便GPU执行。</p><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>准备vertex data的过程，就是不断将数据在CPU和GPU之间传输，以便GPU以最优的方式使用这些vertx data，其中涉及resource的创建和内存的管理，是Vulkan中比较核心的部分之一。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/11.png" alt="传输vertex data"></p><h1 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h1><p>到现在为止，所有的设置和准备工作都已经完成，那么下边就要进行图形的绘制工作了。即，在CPU中向GPU下发各种绘制命令。在vulkan中进行渲染工作，需要一些固定的模式：</p><ol><li>获取swapchain中可用的image；</li><li>准备开启command buffers，它们记录需要提交给GPU的commands；</li><li>准备提交所需的信息并完成提交；</li></ol><h2 id="获得swapchain中的image"><a href="#获得swapchain中的image" class="headerlink" title="获得swapchain中的image"></a>获得swapchain中的image</h2><p>因为这里我们需要将渲染的结果直接输出到屏幕中显示，因此需要得到swapchain中可用的image作为渲染目标。其实，每一次的渲染过程并不会一定会输出到最终的屏幕上，有可能作为中间结果被后续的渲染操作使用，但是本文所述的任务很简单，所以直接输出到屏幕中。</p><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html">vkAcquireNextImageKHR</a>支持完成这样的操作。其中的imageIndex是vkGetSwapchainImagesKHR返回的可用image数组中的索引。当返回可用的image时，也可以触发相应的semaphore和fence。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">vkAcquireNextImageKHR</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> swapChain<span class="token punctuation">,</span> UINT64_MAX<span class="token punctuation">,</span> imageAvailableSemaphore<span class="token punctuation">,</span> VK_NULL_HANDLE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>imageIndex<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="准备command-buffer-1"><a href="#准备command-buffer-1" class="headerlink" title="准备command buffer"></a>准备command buffer</h2><p>我们前面已经介绍了，command buffer是从command pool中分配而来。所有提交到GPU执行的命令都必须要记录在command buffer中，值得说的是，command buffer也分为两种：</p><ul><li>primary command buffer;</li><li>secondary command buffer;<br>其中，只有primary command buffer才能被提交到queue，而secondary command buffer必须通过primary command buffer才能被提交执行。</li></ul><p>command buffer是存在生命周期的，具体来说，如下所示：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/command_buffer_life.png" alt="command buffer的生命周期"></p><ul><li>当每次allocate完成后，command buffer处于initial;</li><li>之后begin command buffer之后，从initial变成recording；</li><li>end command buffer之后，从recording变成executable，在这个状态下才可以被提交给queue去执行;</li><li>submmit之后，状态从executable变成pending，说明提交的任务处于执行中；<br>在下达绘制命令中，我们其实就是在begin和end之间放入相应的commands，此时全部处于recording。具体过程如下：</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 从recording变成initial</span><span class="token function">vkResetCommandBuffer</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>VkCommandBufferBeginInfo beginInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">vkBeginCommandBuffer</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>beginInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>VkRenderPassBeginInfo rpInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">vkCmdBeginRenderPass</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rpInfo<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vkCmdBindPipeline</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vkCmdBindDescriptorSets</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vkCmdBindVertexBuffers</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vkCmdSetViewport</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vkCmdSetScissor</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vkCmdDraw</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">vkCmdEndRenderPass</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vkEndCommandBuffer</span><span class="token punctuation">(</span>commandBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中，<a href="https://www.slideshare.net/tlorach/siggraph-2016-vulkan-and-nvidia-the-essentials">NVIDIA的一个ppt</a>中说明了这个过程：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/command_buffer_record.png" alt="command buffer的recording过程"></p><p>其中的工作主要分为几类：</p><ul><li>设置command buffer包括reset/begin/end等；</li><li>记录renderpass的开始和结束，因为在vulkan中所有的渲染任务都是在renderpass中进行的；</li><li>绑定pipeline，从而知道各种stages的states;</li><li>设置各种dynamic states（这些可以增加pipeline中的对应设置）；</li><li>绑定descriptorsets，以便shader读取内存资源； </li><li>绑定vertex buffer，确定输出数据；</li><li>下发绘制命令vkCmdDraw等；</li></ul><h2 id="准备提交"><a href="#准备提交" class="headerlink" title="准备提交"></a>准备提交</h2><p>当将所有的commands全都记录下来后，我们就需要将任务提交到queue中执行，这个过程其实很简单，只需要：</p><pre class=" language-cpp"><code class="language-cpp">VkSubmitInfo submitInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">vkQueueSubmit</span><span class="token punctuation">(</span>graphicsQueue<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>submitInfo<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里想要说明的是，submitInfo都有啥？即，GPU需要知道啥才能完成所有的图形渲染任务。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/%E4%BD%BF%E7%94%A8vulkan%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/queue_submit_info.png" alt="Queue的submit informations"></p><p>在这里，我们发现执行一次vkQueueSubmit，并不是只有会提交一个command buffer，而是一批，每个submitinfo中都有若干个command buffers。</p><p>除了command buffers，另外最重要的信息是同步原语，比如semaphore和fence等，用来在不同的粒度上协同host与device，command buffers之间的同步关系，这一部分内容也是vulkan种比较重要和困难的部分。</p><h2 id="呈现到屏幕上"><a href="#呈现到屏幕上" class="headerlink" title="呈现到屏幕上"></a>呈现到屏幕上</h2><p>我们之前从swapchain中得到可用的image，等待所有的命令都执行完了，就要将渲染的结果呈现到屏幕中了，如下：</p><pre class=" language-cpp"><code class="language-cpp">VkPresentInfoKHR presentInfo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">vkQueuePresentKHR</span><span class="token punctuation">(</span>presentQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>presentInfo<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="整体总结"><a href="#整体总结" class="headerlink" title="整体总结"></a>整体总结</h1><p>到目前为止，上述内容完整叙述了通过Vulkan完成绘制三角形的“简单”步骤，其实是过于复杂了。因此刚入门的开发者可能经常会困惑于各种概念，因为我也遇到了，因此vulkan对于图形学开发入门来说不是很友好，其中很多的概念是借鉴自OpenGL，相比于Vulkan，OpenGL可能中文的材料更多，而且社区更活跃。但是，vulkan这种“繁杂”的设计，才能进一步通过细粒度的控制来挤压硬件的性能，随着摩尔定律处于失效的边缘，后续可能会是主要的发展方向。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
            <tag> 三角形 </tag>
            
            <tag> device </tag>
            
            <tag> queue </tag>
            
            <tag> swapchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《制造消费者》的社会带来的挑战</title>
      <link href="/2023/01/08/du-shu-gan-wu/zhi-zao-xiao-fei-zhe-de-she-hui-dai-lai-de-tiao-zhan/"/>
      <url>/2023/01/08/du-shu-gan-wu/zhi-zao-xiao-fei-zhe-de-she-hui-dai-lai-de-tiao-zhan/</url>
      
        <content type="html"><![CDATA[<p>这本书刚出来的时候，我就在微信读书中看到了，我心里一直有一个问题：为啥一些人痴迷于消费不能自拔？恰好封面上也有一个问题：</p><blockquote><p><strong>是我们占有了商品，还是商品奴役着我们？</strong></p></blockquote><p>我觉得这个问题恰好包含了我的疑问，也是消费主义陷阱中的一个基本问题。</p><p>这本书粗粗翻看一下，其风格有点偏学术，例子很少，可能趣味性稍差一点，但是对于想要了解消费主义发展历史的人来说，确实值得一读。</p><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p><img src="/images/%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F/%E5%88%B6%E9%80%A0%E6%B6%88%E8%B4%B9%E8%80%85/1.png" alt="本书整体结构"></p><h1 id="商品社会的形成和发展"><a href="#商品社会的形成和发展" class="headerlink" title="商品社会的形成和发展"></a>商品社会的形成和发展</h1><h2 id="商品社会形成的条件"><a href="#商品社会形成的条件" class="headerlink" title="商品社会形成的条件"></a>商品社会形成的条件</h2><p>作者首先介绍了商品社会的形成，因为这是消费主义出现必需的物质基础。商品社会形成的先决条件是商品的流通，而商品的流通需要基于大规模的基础设施，这是从交通方式改变开始的。我们在历史书中学到的瓦特对蒸汽机的改善，吹响了工业革命的号角，但是这是从生产角度思考的，如果只是在生产上提高了效率，但是需求方上没有变化，工业革命的力量不可能这么强大。</p><p>因此，斯蒂芬森发明的蒸汽机车其实从需求角度上，提高了商品流通的效率。经济学的基本常识，供给和需求要匹配，如果供给过剩，价格下跌，就需要大量的市场；如果需求旺盛，价格就会提高，反过来刺激生产。</p><p>因此，开始的时候，生产的效率提升，价格下跌，使得人们自己劳动制造的物品不那么划算，因为人们开始着眼于制造那些高价的商品，这样促使了劳动分工，人们通过制造高价物品，购买工业化的低价物品，促使自给自足的经济模式解体。此时，物品的使用价值不再重要，而是其交换价值更重要，即要能卖出高价。</p><h2 id="围绕着品牌的消费主义历史"><a href="#围绕着品牌的消费主义历史" class="headerlink" title="围绕着品牌的消费主义历史"></a>围绕着品牌的消费主义历史</h2><p>但是，随着商品的逐渐复杂，人们不了解商品的真实生产过程，逐渐产生不信任感，这对于商品的销售方是极大的打击，因此品牌的建设被提出来解决这种问题。换言之：<strong>品牌提出的第一目的是解决不信任感。</strong></p><blockquote><p>为了解决信任问题，大型公司开始在品牌上做文章。品牌的首要功能就是给消费者安全感，让消费者感到产品不是来自无名的陌生公司，而是来自某个有温度的“家庭”。</p></blockquote><p>但是，随着商品社会的发展，品牌的作用不止于此，甚至可以说，整个消费主义历史，均是围绕着品牌而发展的。</p><blockquote><p>在工业化生产导致产品失去个性化的情况下，品牌在中间用一种奇妙的方式解决了这个问题，它高效而有力地让商品融入了社会。</p></blockquote><h3 id="品牌带来符号价值"><a href="#品牌带来符号价值" class="headerlink" title="品牌带来符号价值"></a>品牌带来符号价值</h3><p>资本阶级天生的自卑情结迫切需要彰显个人身份，但是凭借欧洲传统的血统道路是不可能被认可的。关于这一点，在18-19世纪时，美国的富豪均以取一个英国的贵族小姐为荣，甚至是模仿贵族的生活方式和口音。但是，这种行为被传统的贵族圈子嘲讽。</p><p>因此，资本阶级需要通过消费来彰显自己在社会中的地位，典型的，穿上了纪梵希就高人一等，背了LV就不是普通人。过去有一段时间，人们批评这是虚荣在作祟，我觉得身处特定的经济环境下的必然选择，极少有人能摆脱，只是程度不同，比如在农村穿一双乔丹的运动鞋就很有高人一等的感觉，但是在一线城市中可能再普通不过。</p><p>因为有需求，就会有供给，资产阶级的这种欲望通过品牌赋予的符号价值加以满足。而随着人群的细化，每个人群需要的符号价值不同，就会不同的商家来满足，比如购买昂贵化妆品的和购买昂贵显卡的人均认为自己与众不同，认为对方简直愚不可及。这种追求独特的符号价值的行为促进了商品的多样化，并不断更新和升级。</p><h2 id="商品社会加速发展的助推器"><a href="#商品社会加速发展的助推器" class="headerlink" title="商品社会加速发展的助推器"></a>商品社会加速发展的助推器</h2><p>商品的生产不再是核心瓶颈，当前的核心问题在于努力扩大消费，基于这一认识，各个公司不断通过各种手段，引导人们消费。</p><h3 id="图像媒体的出现提供了便利"><a href="#图像媒体的出现提供了便利" class="headerlink" title="图像媒体的出现提供了便利"></a>图像媒体的出现提供了便利</h3><p>商品的流通只通过交通的改善是不够的，图像媒体的出现将商品的形象延伸到世界的每个角落，这大大促进了人们对于商品的了解，也提升了人们购买的几率，尤其是媒体还刻意地开展以下的行为：</p><ul><li>消费教育  告诉人们一些新奇的商品，以及有何好处。</li><li>社会想象的植入  上层阶级均使用这些商品，从而举止典雅、风度翩翩，将商品与特定的美德和行为关联。</li><li>商品平常化  让商品融入人们的日常生活，增加其购买的合理性。</li></ul><h3 id="操纵人群心理的科学出现"><a href="#操纵人群心理的科学出现" class="headerlink" title="操纵人群心理的科学出现"></a>操纵人群心理的科学出现</h3><p>人群心理学最开始是针对政治学开展的研究，后来被各种公司学习来利用人群的心理特点，从而提升销量，比如：从众焦虑、独特个性的彰显。这种操纵变得越来越专业化，以至于专业的公关人员的出现，而且其宣传或者操作人群的核心里面，不在于纠缠于负面形象，而是不断重复正面形象，从而让人遗忘负面形象。</p><blockquote><p>以AT&amp;T为首的大公司，其公关的一个理念就是，并不直接反驳攻击言论，而是给大众更有意思的想法，讲述另外的故事，使他们的存在和行为显得合理。</p></blockquote><p>这一点与我们熟悉的方式很不同，因为群众都是健忘的，如果你一直提及负面形象，无疑会加强其在群众心理的印象，因此不如不提，而是不断重复正面的合理行为。</p><p>而且，在这个过程中，商家的操纵行为与人群变化的方向也是一致的，如：自给自足的经济模式解体后，人们不断追求个性独立、长相个人价值，因此商家通过宣传各种理论，为人们的”肆意“行为找理论基础。</p><blockquote><p>一战过后，弗洛伊德的理论经常出现在媒体上，比如无意识、潜意识、压抑、性本能、固着、自卑情结等。弗洛伊德理论带来了各种新名词，同时也为消费者心态提供了“科学”支持。</p></blockquote><h1 id="商品社会与人类之间的影响"><a href="#商品社会与人类之间的影响" class="headerlink" title="商品社会与人类之间的影响"></a>商品社会与人类之间的影响</h1><p>商品社会的发展需要满足人类的需求才能不断发展，而人类的需求和欲望是无止境的，因此反过来会促进商品社会不断发展。</p><h2 id="商品社会给人类带来的价值"><a href="#商品社会给人类带来的价值" class="headerlink" title="商品社会给人类带来的价值"></a>商品社会给人类带来的价值</h2><p>商品的出现，其本质上有使用价值，能够满足人们的物质要求，比如：速冻食品能够填饱肚子。其次，商品带来了交换价值，一个生产电动车的企业是看中其使用价值吗？当然不是，是因为其能出售，从而获得利润，因此商品有交换价值。</p><p>但是，当今消费主义更多是关注商品的符号价值，我买了Tesla的汽车，说明我是一个收入还不错的人，这样讲自己与其他人分割开来，或者有人真的是因为使用价值购买，但是因为符号价值购买商品的人一般不会直接说出来。</p><p>商品的符号价值奠定了人们社会上的身份，之前听了一个播客提到购买几款奔驰的人，多数是没钱的人，只是付个首付，但是他们需要奔驰汽车带来的符号价值来开展自己的事业，而如果没有，则前进的道路会很困难。</p><p>商品的符号价值在各种媒体的大肆宣传下，营造了这样一种氛围：如果不买该商品，你就成为老古董，冥顽不化，与现代生活格格不入，从而犯下了滔天大罪。</p><blockquote><p>媒体和市场的联盟就这样影响了人们的精神世界。通过与消费相关的形象，人们对支撑某种形象的典型产品产生有序联想，并将其与一种生活方式相关联，这种生活方式则代表了一种“正确”的态度，还引发人想象一种美好而兴奋的生活状态。</p></blockquote><h2 id="商品社会对于家庭的影响"><a href="#商品社会对于家庭的影响" class="headerlink" title="商品社会对于家庭的影响"></a>商品社会对于家庭的影响</h2><p>过去的家庭要从事很多的劳动，即便是现在，也有很多地方依然延续着这种模式，比如在内蒙古、新疆的各种农场和牧场。但是在多数的城市中，随着商品社会的发展，家庭已经不是劳动的场所了，而是一家人休闲的场所，大家在这里体会家庭的温暖。同时，家庭的空间也不是共享的，家庭成员之间通过不同的空间保护各自的隐私。</p><p>全家人不在一起劳动，类似过去一起下地种田这种行为在城市中几乎不可能，其原因有多种：</p><ul><li>劳动分工：这种全家劳动的自给自足的生活方式与当今社会不符；</li><li>工资制度：工资制度的完善使得外出工作的收益更高；</li><li>商品崇拜：社会的进步使得商品日益复杂，在家庭中是不可能生产出来的；</li></ul><p>基于这些原因，家庭中不同成员的角色在商品社会中也逐渐转变。</p><ul><li>孩子不在参与劳动，是家庭幸福的标志；</li><li>由于追求个性，不再有集体的儿童看护，需要母亲作为家庭主妇照顾孩子；</li><li>父亲一般在外工作，提供经济支持；</li></ul><p>综合来看，家庭的核心转移到男性和孩子身上，尤其是孩子。因此各个公司将宣传面向的对象对准孩子，从而掏空每个家庭的最后一个硬币。</p><blockquote><p>在现代家庭里，孩子和商家是天然盟友，他们一起攻克家长的钱包。</p></blockquote><blockquote><p>不需要强迫孩子买一件东西，只需要让孩子看到他们想要的东西，然后他们就会回家一直折磨他们的父母，直到他们得到那件东西。</p></blockquote><h1 id="消费自由能持续吗？"><a href="#消费自由能持续吗？" class="headerlink" title="消费自由能持续吗？"></a>消费自由能持续吗？</h1><p>作者在本书结尾提到了一个担忧：当前的消费自由是否能持续，从几个方面，作者说明了这种担忧：所谓消费自由其实是一种特权，是资本社会营造出来的假象，真正能拥有这种权力的人很少：</p><ul><li>鼓吹消费自由，背后其实刻意忽略了所需的生产，以至于造成人人均可以消费自由的假象；</li><li>消费自由无形中增强了特定人群的话语权；</li><li>消费自由依赖的资源处于不稳定的状态下，如各种化石能源；</li></ul><p>基于此，作者认为当前大行其道的消费主义风潮已经处于消退的开始阶段。</p><p>对于这一点，我觉得作者的阐述，论据并不充分，在结尾草草抛出这个观点，并不能使人信服，但是其所说的消费自由是一种特权，这一观点我是认可的。绝对的消费自由对于普通人看来几乎不可能，但是富豪可以参与星际旅行，因此这一权力确实集中在少数人手里。</p><h1 id="对我们的启发"><a href="#对我们的启发" class="headerlink" title="对我们的启发"></a>对我们的启发</h1><p>读完这本书，对于我们的行为有何指导意义？</p><ul><li>我们要掌控商品，而不是被商品奴役；  即，不会被各种消费主义洗脑。</li><li>识别商家的操纵手段是不容易的，但是要注意起避而不谈的部分；</li><li>对于商品的符号价值保持良好形态；  要明白在当前的商品社会，完全依靠使用价值来选择商品，即便自己能做到，身边人可能也无法做到，所以不要求全责备，适度即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
            <tag> 社会 </tag>
            
            <tag> 消费 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++线程：对于线程死锁的认识和理解</title>
      <link href="/2022/12/04/bian-cheng-zhi-dao/c-xian-cheng-dui-yu-xian-cheng-si-suo-de-ren-shi-he-li-jie/"/>
      <url>/2022/12/04/bian-cheng-zhi-dao/c-xian-cheng-dui-yu-xian-cheng-si-suo-de-ren-shi-he-li-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="死锁的理解"><a href="#死锁的理解" class="headerlink" title="死锁的理解"></a>死锁的理解</h1><h2 id="通俗的解释"><a href="#通俗的解释" class="headerlink" title="通俗的解释"></a>通俗的解释</h2><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%AF%B9%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E7%90%86%E8%A7%A3/1.jpg" alt="争抢资源，在死锁中则争抢的是锁"></p><p>用自己的话通俗的解释是，多个线程竞争一个锁，从而对共享的数据进行同步操作，在竞争中，由于锁的存在，需要每个线程排队，占有该锁，才能进行后续操作。因此，每个线程为了完成任务，第一步就是需要占据锁。</p><p>而死锁发生在这种情况下：</p><ol><li>线程A首先占据了锁，并执行操作，在这个过程中，线程A没有unlock；</li><li>此时，线程B也希望占据锁，从而执行任务，但是因为线程A没有unlock，自己只能等待；</li><li>而线程A如果要unlock，需要满足一定的条件，这个条件需要通过线程B执行完成才能实现。</li></ol><p>据此，出现，线程A等待线程B执行完才能unlock，而线程B需要线程A先unlock，才能继续执行，<strong>确定死锁，其核心是线程A和线程B相互等待对方先执行，来满足自己</strong>。这种当不同线程之间的执行存在依赖关系时，以至于每个线程必须满足一定条件才能执行，但是又不释放对锁的控制权，以至于其他线程无法得到锁的控制权，以便实现之前线程unlock需要的条件，从而发生线程A等待线程B完成以满足条件。</p><h2 id="例子1：不用同步量也会发生死锁"><a href="#例子1：不用同步量也会发生死锁" class="headerlink" title="例子1：不用同步量也会发生死锁"></a>例子1：不用同步量也会发生死锁</h2><p>死锁的发生不一定要用mutex等互斥量时才会发生，如下，当两个线程之间互相等待就有可能发生。下述代码中每个线程都在等待对象先满足条件，如果不满足条件，对应的线程就继续等下去。至于输出，则依赖系统对这两个线程的调度。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> g_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">thread_task1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread task1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>g_i <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    g_i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">thread_task2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread task2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>g_i <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    g_i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span>thread_task1<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t2</span><span class="token punctuation">(</span>thread_task2<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="例子2：使用一个同步量时"><a href="#例子2：使用一个同步量时" class="headerlink" title="例子2：使用一个同步量时"></a>例子2：使用一个同步量时</h2><p>当死锁出现时，明显的症状是发生了阻塞行为。如果多个thread之间没有依赖关系，则只会乱序。只有需要同步时才会出现死锁，而同步的实现可以是任何方式，如上述的循环等待，或者加上了mutex信号量。因此死锁是同步出现问题的表现，不是线程本身的问题。</p><p>另一个使用一个mutex同步时引起死锁的简单例子（虽说简单，也设计了一会，其实对于理解死锁还是有帮助的）如下。</p><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>mutex m<span class="token punctuation">;</span>mutex m1<span class="token punctuation">;</span>mutex m2<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">thread_task1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    m<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lock_guard get m from thread 1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"from thread 1: "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        m<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">thread_task2</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    m<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lock_guard get m from thread 2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"from thread 2: "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        m<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span>thread_task1<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t2</span><span class="token punctuation">(</span>thread_task2<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** outputlock_guard get m from thread 1之后一直等待......*/</span></code></pre><p>多个线程竞争一个锁，<strong>注意是一个锁，也就对应一个mutex</strong>，这样不同的线程需要排队占有这个锁，才能执行对应的操作。如上代码中，有两个线程t1和t2，分别执行相应的操作，通过mutex m实现同步，在线程t1执行操作时，需要满足v[1] == 2，但是这个写入操作需要线程t2完成，但是此时线程t1占据m，所以线程t2没有机会修改条件，因此发生死锁。分析如下，这里我想到受精卵形成的一个机制——<a href="https://en.wikipedia.org/wiki/Cortical_reaction">Cortical reaction</a>，用来形容这种情况很是贴切。</p><blockquote><p>此时感受到各种知识的相似之美。</p></blockquote><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%AF%B9%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E7%90%86%E8%A7%A3/2.png" alt="多个thread竞争一个mutex"></p><p>每个mutex对象可以对resource进行lock和unlock，且同一时刻只能允许一个thread占据该mutex，其他的需要排队，多像受精卵排斥多个精子入内的操作。当一个线程执行时，需要满足一个条件，而这个条件需要还未占据mutex的其他线程实现，因此占据mutex的线程就要等待，但是不释放控制权，其他线程无法入内，因此就不能达成条件。</p><p>在实验中，我们也想验证如下的场景：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">thread_task1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    m1<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lock_guard get m from thread 1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"from thread 1: "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        m1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">thread_task2</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    m2<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lock_guard get m from thread 2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"from thread 2: "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        m2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>每个线程对应不同的mutex对象，实际上这两个线程并不是同步的关系，而是各自独立运行，完全没有依赖。这种情况下不会导致死锁，因为涉及多个mutex，分析如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%AF%B9%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E7%90%86%E8%A7%A3/3.png" alt="多个sync scope不会死锁"></p><p>两个线程分别在不同的sync scope中，也根本就没有进行同步，也就谈不上出现死锁了。</p><h2 id="例子3：使用多个同步量时"><a href="#例子3：使用多个同步量时" class="headerlink" title="例子3：使用多个同步量时"></a>例子3：使用多个同步量时</h2><p>另外，我这里举的例子是涉及一个mutex，对于涉及多个mutex的场景，也可能出现死锁的问题，如<a href="https://stackoverflow.com/questions/49351314/c-deadlock-example">文章</a>所示。</p><pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>mutex m1<span class="token punctuation">;</span>std<span class="token operator">::</span>mutex m2<span class="token punctuation">;</span><span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>m1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m2<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lg1</span><span class="token punctuation">(</span>m1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lg2</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>m1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m2<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lg1</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lg2</span><span class="token punctuation">(</span>m1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>f1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>f2<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>f1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>f2<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述代码分析如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%AF%B9%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E7%90%86%E8%A7%A3/4.png" alt="两个线程之间互相等待"></p><p>调试死锁的问题向来就是比较困难的，我在写本文的时候，又去熟悉了一下gdb调试死锁的操作，可以参考<a href="https://www.cnblogs.com/gqtcgq/p/7530384.html">这篇文章</a>，还可以对已经运行的程序查看是否死锁，如<a href="http://www.langdebuqing.com/others%20notebook/gdb%20%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81.html">文章</a>。</p><h1 id="为什么会出现"><a href="#为什么会出现" class="headerlink" title="为什么会出现"></a>为什么会出现</h1><p>综合以上的分析，我们总结一下deadlock为啥会出现，这里直接借助学术派的总结，如<a href="https://sites.ualberta.ca/~smartynk/Resources/CMPUT%20379/beck%20notes/deadlock.pdf">文章</a>所述。</p><p>Four conditions that must hold for a deadlock to be possible:</p><ul><li><strong>Mutual exclusion</strong>: processes require exclusive control of its resources (not sharing).</li><li><strong>Hold and wait</strong>: process may wait for a resource while holding others.</li><li><strong>No preemption</strong>: process will not give up a resource until it is finished with it. Also, processes are irreversible: unable to reset to an earlier state where resources not held.</li><li><strong>Circular wait</strong>: each process in the chain holds a resource requested by another.</li></ul><p>其中还有一个图生动的描述了这些条件的含义：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%AF%B9%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E7%90%86%E8%A7%A3/5.png" alt="死锁条件的说明"></p><p>如果上述条件中有一个被打破，死锁就不会发生。对应我们上述的例子，分别分析这4种条件：</p><ol><li><p><strong>Mutual exclusion</strong></p><p> 对于互斥量mutex，一次只能被thread占据，如果<strong>当前有thread占据该mutex，其他的thread只能等待</strong>。</p></li><li><p><strong>Hold and wait</strong></p><p> 线程t1需要访问数组中的数据，当满足一定的条件后才会执行，<strong>即便当前无法继续前进，也会阻塞在这里，不会释放资源</strong>。</p></li><li><p><strong>No preemption</strong></p><p> 该线程t1会<strong>一直占据该mutex，不会放弃，因此别人无法通过抢占得到</strong>，即先占为王，直到满足条件才会unlock。</p></li><li><p><strong>Circular wait</strong></p><p> 基于上述的条件，每个线程对象不可能中途退出，因此<strong>多个线程之间存在循环等待</strong>，因此只能僵持在这里，即线程t1需要等待t2修改条件，但是却释放资源。</p></li></ol><h2 id="对于例2的解决"><a href="#对于例2的解决" class="headerlink" title="对于例2的解决"></a>对于例2的解决</h2><p>对于上述条件中，我们只要能打破一个，就能解决死锁问题。对于本文的死锁例子，针对上述的4个条件中，我们可以打破<strong>Hold and wait</strong>实现死锁的解决，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">thread_task1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    m<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lock_guard get m from thread 1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"from thread 1: "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    m<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这样即便不能满足条件，线程t1也会unlock。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://sites.ualberta.ca/~smartynk/Resources/CMPUT%20379/beck%20notes/deadlock.pdf">https://sites.ualberta.ca/~smartynk/Resources/CMPUT%20379/beck%20notes/deadlock.pdf</a></p></li><li><p><a href="https://blog.csdn.net/hit_shaoqi/article/details/107193727">https://blog.csdn.net/hit_shaoqi/article/details/107193727</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mutex </tag>
            
            <tag> 死锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们需要对《算法霸权》的威胁重视起来</title>
      <link href="/2022/12/04/du-shu-gan-wu/wo-men-xu-yao-dui-suan-fa-ba-quan-de-wei-xie-chong-shi-qi-lai/"/>
      <url>/2022/12/04/du-shu-gan-wu/wo-men-xu-yao-dui-suan-fa-ba-quan-de-wei-xie-chong-shi-qi-lai/</url>
      
        <content type="html"><![CDATA[<h1 id="我的经历"><a href="#我的经历" class="headerlink" title="我的经历"></a>我的经历</h1><p>在看这本书之前，我对算法模型带来的恶了解不多，但是回想起来，还是有那么几件事情让人不寒而栗。</p><p>一个就是“大数据杀熟”的事情，千人千面，之前我们理解的、或者电商承诺的千人千面，是根据自己的兴趣、喜好推荐不同的物品，现在根据不同人的经济能力、教育水平，甚至可以在价格上千人千面。此时，穷人和富人的界限也不是那么清晰了，办了会员卡的人可能看到的是更高的价格。</p><p>另外一个是，我之前了解的一个事例，据说，某外卖平台中的一个外卖员总是能在算法规定的完成派单时间内，早早完成，后来经过调查，发现骑手在派单时，发现了一条捷径，这条捷径不在算法平台中体现，因此出现远超算法预期的行为，当这个漏洞被补上的时候，骑手的派单时间被压缩了。那么，如果之后这个捷径被堵上，不让过，那么骑手得到的就是超时，罚款。整个过程中，算法在干什么？它在一步步地压缩骑手的活动空间，扩大利润空间，但是当空间变化时，模型能及时调整回原来的状态吗？我持否定态度，另外我看见一个算法工程师在不断用绳子勒死自己，因为也有一些模型在评估他们的行为，而他们研究出来的技术就扑向自己迈向死亡的道路。</p><p>我自己也有一些算法方面的经验，是医学方面的，到没有上面那么“骇人听闻”，但是也是让人不舒服的。众所周知，算法的准确，需要大量的数据，对于医学来说，就需要大量的病人的数据。有时候，当数据不足时，我们希望更多的数据时，殊不知这意味着更多的病人感染奇怪的疾病，想想有点可怕。回想big shot电影中，布拉德皮特饰演的Ben，对Charlie等两人说，“如果你们的策略或者模型成功了，那意味着无数人的失业，美国将陷入经济衰退。”</p><h1 id="WMD的兴起"><a href="#WMD的兴起" class="headerlink" title="WMD的兴起"></a>WMD的兴起</h1><h2 id="数学杀伤性武器WMD"><a href="#数学杀伤性武器WMD" class="headerlink" title="数学杀伤性武器WMD"></a>数学杀伤性武器WMD</h2><p>作者在书中创造了一个新的概念——数学杀伤性武器”（Weapons of Math Destruction，简写成WMD），用于描述数据在人们的日常生活中扮演的不可或缺但又充满威胁性的角色。</p><blockquote><p>数学应用助推数据经济，但这些应用的建立是基于不可靠的人类所做的选择。有些选择无疑是出于好意，但也有许多模型把人类的偏见、误解和偏爱编入了软件系统，而这些系统正日益在更大程度上操控着我们的生活。</p></blockquote><p>其杀伤性的源头，还是来自于人类本身，因为这些模型和工具所需要的输入全部由人类产生。但是：</p><blockquote><p>由于数学的功能特别强大，一旦其与科技相结合，其所造成的混乱和不幸也会成倍增长，它使得一个有着巨大缺陷的系统加速运转，进一步扩大规模。</p></blockquote><p><strong>因此，这样的场景出现了，人类的各种缺陷，通过数学这种工具被无限放大了，而且由于计算能力的提高，这种放大的缺陷反过来给人类社会造成更大的破坏，但是其黑盒属性使得它们难以为人们察觉。</strong></p><h2 id="WMD的特点"><a href="#WMD的特点" class="headerlink" title="WMD的特点"></a>WMD的特点</h2><p>作者在文中通过3个问题引出了WMD的特点：</p><blockquote><p>第一个问题：如果参与者知道自己是被模型评估的对象，或知道模型目的是什么，那么该模型还是不透明的吗？</p></blockquote><blockquote><p>第二个问题特别困难：模型违反国民主体的利益吗？简单来说，模型是不是不公平的？它会破坏或毁灭一些人的生活吗？</p></blockquote><blockquote><p>第三个问题：该模型是否有应用场景呈指数增长的潜力？用统计学家的话来说就是，该模型能否规模化？</p></blockquote><p>这三个问题总结了WMD的3个特点：</p><ul><li>不透明；</li><li>规模化；</li><li>毁灭性；</li></ul><h3 id="不透明"><a href="#不透明" class="headerlink" title="不透明"></a>不透明</h3><p>如果需要对数学模型有深入地理解，需要有相当深厚的专业知识，这对于普通人显然要求过高，甚至对一些初级的数据科学从业人员，也是比较困难的。</p><blockquote><p>人们无从了解模型的具体运作方式，这意味着人们很难对模型给出的分数提出质疑或者抗议。</p></blockquote><p>这种情况，造成的结果是：</p><blockquote><p>这就是数学杀伤性武器的本质——将问题分析的部分外包给程序员和统计师，而他们的原则通常就是，<strong>机器说了算</strong>。</p></blockquote><p>对于不公正的人类决定，人们可以抗议甚至诉讼，但是：</p><blockquote><p>你不能状告一个数学杀伤性武器。这也是我们说数学杀伤性武器具有极为可怕的破坏力的原因之一。模型不会倾听，也不会屈服，对诱惑、威胁和哄骗以及逻辑通通充耳不闻，即使被评估者有充足的理由怀疑得出结论的数据被污染。</p></blockquote><p>当这种情况非常平常时，人们的态度也发生了转变：</p><blockquote><p>人们对模型得出的结论毫无争议，从不上诉，即使结论是错误的或是有害的。</p></blockquote><p>另外一个不透明的原因在于：</p><blockquote><p>许多公司竭尽所能地隐藏它们的模型运算结果，甚至隐藏模型的存在。</p></blockquote><p>因为，这是企业利润的来源，在当今大数据时代，也是他们压榨甚至剥削的核心手段，因此给模型披上面纱是再好不过的事情。对于模型可能造成问题，</p><blockquote><p>但是一般来说，数学模型操作者不会思考这些可能的错误。他们看重的反馈是金钱，这也是他们的根本动机。</p></blockquote><h3 id="规模化"><a href="#规模化" class="headerlink" title="规模化"></a>规模化</h3><blockquote><p>数学杀伤性武器擅长处理巨量数据，而且处理成本很低，这也是它们的优势所在。</p></blockquote><p>规模化增强了数学杀伤性武器的破坏力，想想那些预测你喜欢哪一类商品的模型，在ms甚至ns级别上就能猜到你的喜好，比你的父母、妻子甚至自己都要了解你，而且多个预测操作，可以同时完成，这种规模化的效应，想想就让人害怕，如果将这种喜好换成对人的缺点的预测呢？对人的患病的预测呢？</p><p>另外一点，当今社会中各种模型之间都有互联互通的关系，但你在一个局部上出现问题，可能就会在全局上出现问题。此时，我想起之前美国流浪汉为啥这么多的一个解释，美国的信用体系太发达了，人一旦犯错，就会堕入万丈深渊，欠账了，信用就变差，就没办法租房了，也没办法使用信用卡了，子女进入好的学区也是不可能的，找工作也会看信用分，总之，就是一个螺旋式下降的趋势。中国目前还没有这么严格体系，因此如果一个人犯了错，可以换个地方从新再来。不知道，这种在数学模型上的落后，从这种角度来看，是一件好事呢。</p><h3 id="毁灭性"><a href="#毁灭性" class="headerlink" title="毁灭性"></a>毁灭性</h3><p>因为规模化，因此其造成的伤害也是毁灭性的。这种毁灭性，作者提出了一个观点，</p><blockquote><p>数学杀伤性武器的另一个常见特征，即其结果往往更倾向于惩罚穷人。</p></blockquote><p>想想在拼多多上购物的人，应该是中产或者平民的比例更高一点吧。那些排着队投简历的人中，富裕或者有背景的家庭也是不多的，所以某种程度上也是对的。</p><blockquote><p>特权阶级更多地与具体的人打交道，而大众则被机器操控。</p></blockquote><p>因此，当模型带来的伤害总是为穷人承受时，这种威胁对于整个社会也愈发严重，撕裂、对立和仇恨蔓延开来。有人说，这是社会进步必然会带来的代价，但是看看说这些话的人，往往不在这些模型的打击面上，因此当他们面对这种情况时，我想起大明1573中赵贞吉说的那句话“为今之计，只能苦一苦百姓了。。”</p><p>面对这种局面，人们必须随着具体情况的改变而对模型改变。</p><blockquote><p>但是错误总会出现，因为模型的本质就是简化。没有模型能囊括现实世界的所有复杂因素或者人类交流上的所有细微差别。</p></blockquote><p>而且，毁灭性的源头在于模型设计的目的，这决定了模型到底是干什么的，目标是谁，有何好处，它的假设是什么。</p><blockquote><p>一个模型的信息盲点能够反映建模者的判断和优先级序列。</p></blockquote><blockquote><p>我们自己的价值观和欲望会影响我们的选择，包括我们选择去搜集的数据和我们要问的问题。而模型正是用数学工具包装出来的各种主观观点。</p></blockquote><blockquote><p>我们不仅要问是谁设计的模型，还要问设计模型的人或者组织机构要达成什么目的。</p></blockquote><p>同时，也要看谁在控制数据模型：</p><blockquote><p>和很多数学杀伤性武器一样，数学以造福广大消费者为表象，其实质则是最大化卖家的短期利润。</p></blockquote><h1 id="WMD做的恶及其原因"><a href="#WMD做的恶及其原因" class="headerlink" title="WMD做的恶及其原因"></a>WMD做的恶及其原因</h1><blockquote><p>但重点不是有没有人受益，而是有很多人受害。这些数学杀伤性武器关闭了亿万人的机会之门，通常只是因为一些微不足道的理由，而且不予他们上诉的机会。因此，它们仍然是不公平的模型。</p></blockquote><h2 id="作恶的形式"><a href="#作恶的形式" class="headerlink" title="作恶的形式"></a>作恶的形式</h2><p>书中作者举出了各种例子来说明，WMD造成的各种危害。</p><ul><li>2008年金融危机时，作者作为参与者见证了华尔街使用数据模型窃取美国民众辛苦赚来的钱；</li><li>排名模型对于学校声誉的打击，以及促成各种华而不实的攀比、营销等，而这些成本均被转移到普通的民众身上。而名校们对这些排名模型的免疫力更高，但是普通人上这些名校的概率远远低于特权阶层；</li><li>掠夺式广告，将最穷的一批人往悬崖边上再推一把，各种信用机构和盈利性大学通过用户画像，从而推定制的信息，利用规模化的特点，重点“照顾”那些穷人，不管是发薪日贷款还是无意义的大学；</li><li>犯罪预测模型，使得一次犯错，终生犯错变得相当普遍，这是WMD的规模性和毁灭性的集中体现，美国监狱中大量的犯人就是最好的证据，将普通人变成犯人的效率不断提升；</li><li>找工作时，通过对于简历的“高效率”筛选，使得普通和经济条件不好的候选人早早被剔除，而特权阶级可以通过人类的介入或者资源公司的帮助来包装自己的简历；</li></ul><p>在圣经中的马太福音中有这样一句话“凡有的，还要加倍给他，叫他多余；没有的，连他所有的也要夺过来”，WMD无疑在充分利用自己的“优势”来帮助实现这一目标。</p><h2 id="WMD被误用的几点原因"><a href="#WMD被误用的几点原因" class="headerlink" title="WMD被误用的几点原因"></a>WMD被误用的几点原因</h2><p>WMD在整个社会中存在着误用，其原因从作者的书中各种零散的描述中，大致可分为两类：</p><h3 id="人的原因"><a href="#人的原因" class="headerlink" title="人的原因"></a>人的原因</h3><p>即所谓的“误用”其实是人为的，因为模型是对于真实情况的简化，但是只要能带来利润，这种简化所损失的信息，而带来的各种问题就可以视而不见，马克思的资本论中提到“为了100%的利润，资本就敢践踏一切人间法律”，何况是模型的简单误用呢！</p><h3 id="还有模型本身的“原罪”"><a href="#还有模型本身的“原罪”" class="headerlink" title="还有模型本身的“原罪”"></a>还有模型本身的“原罪”</h3><p>模型的设计是基于一系列的假设，例如：</p><blockquote><p>因为数学模型的本质是基于过去的数据推测未来，其基本假设是：模式会重复。</p></blockquote><p>这种假设的具体体现在：</p><ul><li>一个简历普通的人，是不可能有能力的；</li><li>经常购买便宜货的人，其购买行为会一直持续；</li><li>欠债的人，还会欠债；</li></ul><blockquote><p>这里，我同意这一点，这是符合贝叶斯原理的，先验概率高，后验概率一般也会高，但是不绝对，而模型将不绝对视为绝对，进行了简化。</p></blockquote><p>另外在模型设计和使用过程中，还有其他的一些因素：</p><ul><li>辛普森悖论的影响；  在某个条件下，两组数据在分别讨论时都满足了某种性质，可是一旦合并考虑，就可能导致相反的结论。</li><li>替代变量的误用  在算法模型中，需要很多的变量，用来量化一些难以量化的东西，比如“贫穷”很难量化，一个月工资是多少，如果对于一个人，一个月赚500元，肯定是穷的，但是发现它是学生，那么衡量贫穷应该把职业加进来。  但是量化一个东西，涉及到的变量很多，不可能将所有涉及到的全部列出来，甚至他们之间的以来关系，如果你了解机器学习算法，肯定知道独立同分布假设和各种消除依赖性的方法，如PCA等等。但是，模型是一个简化，只要有效果，对于替代的是否合理，是无人不关心。即便不合理，当涉及到规模化时，个体的错误也会被忽视。只有当规模化时，发现大量的错误时，也就是准确性降低时，才会有人注意。</li><li>通过一般性的原则来预测个体<blockquote><p>“一般人’的水平可以用于衡量整个人口但往往无法用于评估个人。</p></blockquote>  一个例子：抽烟的人有50%的概率会患上肺癌，你抽烟，所以你有50%的可能性得肺癌。这种说法对吗？当然是错误的，这是一种的典型统计学谬误。但是，在数学模型中，大量使用这种方式来运行，你的行为和算法训练中输入的数据一致，就会得到与算法期待的输出一致，并不会根据你的特质有所改变，这种称之为“人工智能”，有时候是一种讽刺！</li></ul><h1 id="如何面对WMD"><a href="#如何面对WMD" class="headerlink" title="如何面对WMD"></a>如何面对WMD</h1><p>从结尾中，可以大致了解作者的思考和态度：</p><ul><li>数学创造的模型在承诺了效率、精准后，但是并没有实现好，而且造成很大的问题；</li><li>数学模型产生的威胁，使得社会撕裂，民主被践踏，贫富愈发悬殊；</li></ul><p>为了应对数学模型带来的威胁，首先：</p><blockquote><p>正如大多数数学杀伤性武器一样，核心问题主要在于模型的目标。把目标由压榨大众变更为帮助大众，数学杀伤性武器的危险性就解除了，甚至可以反过来变成一种正面力量。</p></blockquote><p>并且需要全社会的行动，才能达到目标：</p><ul><li>数据科学工程师需要像希波克拉底一样宣誓，不作恶，谨慎应对每个模型；</li><li>靠企业来解决模型的威胁是不现实的，因为这是他们利润的来源，而公平只是副产品；</li><li>学术界需要参与进来，培养相关的人才，以便应对威胁；</li><li>政府应该发挥关键作用，建立规范，加强监管，像一二次工业革命一样；</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这本书其实对于每个研究算法模型的人都应该读一下，我们过于强调和宣传“机器学习”和“人工智能”的优点，诚然，在技术变革开始时期，为了突破腐朽、落后的技术枷锁，有时候是不可避免的，但是当这类技术已经大行其道甚至被编入小学生教材时，我们就应该以一种审慎、批判的态度去看待它，而不是继续忽视。如果继续片面地宣传其优点，不是存在利益关系，就是我们自己也犯了模型简化的错误了。</p>]]></content>
      
      
      <categories>
          
          <category> 读书感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 科技 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++线程：使用互斥量实现多线程数据共享</title>
      <link href="/2022/12/01/bian-cheng-zhi-dao/c-xian-cheng-shi-yong-hu-chi-liang-shi-xian-duo-xian-cheng-shu-ju-gong-xiang/"/>
      <url>/2022/12/01/bian-cheng-zhi-dao/c-xian-cheng-shi-yong-hu-chi-liang-shi-xian-duo-xian-cheng-shu-ju-gong-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="数据共享的需求和问题"><a href="#数据共享的需求和问题" class="headerlink" title="数据共享的需求和问题"></a>数据共享的需求和问题</h1><p>在多线程的程序中，不同的线程之间存在数据共享的需求，但是在数据共享的时候，存在一些问题：</p><ul><li>多个线程共享数据时，最后数据的状态由哪个线程决定；</li><li>多个线程同时写的时候，哪个线程先写；</li></ul><p>数据在多个线程之间共享时，对其的读操作基本不会产生问题，但是一旦有任何一个写操作，都会产生问题，因此需要规范不同线程对于共享数据的访问。</p><p>不同线程对于共享数据的修改，导致了数据最终状态的不确定，其最终的状态取决于这些线程之间的执行顺序，这种情况被称为条件竞争，<a href="https://www.techtarget.com/searchstorage/definition/race-condition">race condition</a>。</p><blockquote><p>A race condition is an undesirable situation that occurs when a device or system attempts to perform two or more operations at the same time, but because of the nature of the device or system, the operations must be done in the proper sequence to be done correctly.</p></blockquote><p>这种情况出现的原因在于对于invariants的破坏，不同的线程同时访问一个共享的数据，当线程B访问数据时，以为该数据是自己访问之前看到的样子，但是实际上已经被线程A修改了，导致出现预期之外的结果。</p><blockquote><p>多个线程对于invariants的访问一定会产生race conditino吗？不一定，需要明确这些线程的目的是什么，比如生产者和消费者模型中，不同的生产者都向任务队列中提交任务，它们不考虑队列里有什么，这也是一个写操作，但是任务和任务之间假设没有依赖关系时，则不是race condition。</p></blockquote><h2 id="条件竞争的解决"><a href="#条件竞争的解决" class="headerlink" title="条件竞争的解决"></a>条件竞争的解决</h2><p>race condition肯定是我们极力要避免的，我们有几种办法来解决它：</p><ol><li><p>保护共享数据</p><p> 确保任意时刻只有一个线程能够访问该共享数据的中间状态，其他线程只能看到数据的原始状态或者被修改线程的最终状态，这样保证了不同线程读到的数据都是确定的，不会在其他线程修改后，还会读到原始数据。</p><p> 这种方式在C++中一般是通过互斥量实现的。</p></li><li><p>无锁编程</p><p> 无锁编程的基础是原子操作，这依赖于硬件的支持。更多的资料可以参考：</p><ul><li><a href="https://www.jiqizhixin.com/articles/2019-01-22-12">https://www.jiqizhixin.com/articles/2019-01-22-12</a></li><li><a href="https://www.jiqizhixin.com/articles/2019-01-22-13">https://www.jiqizhixin.com/articles/2019-01-22-13</a></li><li><a href="https://zhuanlan.zhihu.com/p/38664758">https://zhuanlan.zhihu.com/p/38664758</a></li></ul></li><li><p>使用事务</p><p> 类似于数据库的事务，来处理数据的更新，这里使用称为<a href="https://gist.github.com/graninas/c7e0a603f3a22c7e85daa4599bf92525">software transactional memory</a>的技术。</p></li></ol><h1 id="使用互斥量解决条件竞争"><a href="#使用互斥量解决条件竞争" class="headerlink" title="使用互斥量解决条件竞争"></a>使用互斥量解决条件竞争</h1><p>所谓互斥量，通俗的理解，是多个线程访问共享的数据时，任何一个线程在修改数据时，其他的线程都必须等待。</p><h2 id="基本使用方式"><a href="#基本使用方式" class="headerlink" title="基本使用方式"></a>基本使用方式</h2><p>在一个线程访问共享数据前，先将数据锁住，在访问结束后，再将数据解锁。当访问线程使用互斥量锁住共享数据时，其他线程都必须等到该线程对数据解锁后，才能进行访问该数据。</p><p>在C++中通过std::mutex实现互斥量，基本使用如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#inlcude &lt;mutex></span>mutex thread_mutex<span class="token punctuation">;</span><span class="token keyword">int</span> global_i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    thread_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    global_i <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"gobal_i is : "</span> <span class="token operator">&lt;&lt;</span> global_i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    thread_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a  <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>    thread <span class="token function">t2</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里的输出虽然也是不确定的，但是输出中，global_i可以为110/310，或者210/310，这是因为两个线程t1和t2被调度的先后顺序可能不同。但是因为这里两个线程对象的join都在最后，两个线程之间没有顺序，所以才会出现输出有两种可能。</p><p>上述的基本使用方式，每次都需要用<code>lock</code>和<code>unlock</code>成对使用，而且因为异常的原因，如果抛出的异常没有被捕捉，则会导致失败。修改函数do_on_background如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    thread_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    global_i <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"gobal_i is : "</span> <span class="token operator">&lt;&lt;</span> global_i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"invalid argument"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当发生异常时，只会执行一个线程，输出的结果只可能是110或者210，不能有两个，因为当异常抛出时，导致没有执行到unlock就直接终止了，另外的线程也就不会进入共享数据中。</p><p>当异常被捕捉后，就可以正常解锁，可以让两个线程都访问到共享数据。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    thread_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    global_i <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"gobal_i is : "</span> <span class="token operator">&lt;&lt;</span> global_i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"invalid argument"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">const</span> exception <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        thread_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    thread_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>但是这种lock和unlcok的方式很繁琐，还要考虑异常的情况，使用RAII的方式可以优雅地解决这个问题。</p><h2 id="RAII的方式：使用lock-guard"><a href="#RAII的方式：使用lock-guard" class="headerlink" title="RAII的方式：使用lock_guard"></a>RAII的方式：使用lock_guard</h2><p>C++支持使用RAII的方式使用互斥量——通过std::lock_guard实现。构造时提供已锁的互斥量，并在析构时进行解锁，从而保证了互斥量能被正确解锁。使用如下，只需要修改do_on_background函数即可：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">guard</span><span class="token punctuation">(</span>thread_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    global_i <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"gobal_i is : "</span> <span class="token operator">&lt;&lt;</span> global_i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// throw invalid_argument("invalid argument");</span><span class="token punctuation">}</span></code></pre><p>这里当函数中抛出了异常，没有被捕捉，仍然会直接终止，最终只有一个线程被执行。</p><blockquote><p>上述例子中都是针对全局变量的，实际开发中，互斥量多是与要保护的数据放到一个类中，可以对类进行封装，提供数据保护。</p></blockquote><h2 id="漏洞：来自指针和引用的隐秘操作"><a href="#漏洞：来自指针和引用的隐秘操作" class="headerlink" title="漏洞：来自指针和引用的隐秘操作"></a>漏洞：来自指针和引用的隐秘操作</h2><p>互斥量并不是万无一失的，还是需要仔细梳理代码逻辑来保证正确，将对类的数据访问全部限制在互斥量的范围中才能较好的保护数据。当对数据的访问和修改脱离了互斥量的作用范围，就很容易产生问题，这种情况的典型例子是指针和引用，因为能够直接操作数据，所以更加危险。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">raw_data</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">data_wrapper</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    raw_data data<span class="token punctuation">;</span>    mutex m<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Function<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">process_data</span><span class="token punctuation">(</span>Function func<span class="token punctuation">)</span><span class="token punctuation">{</span>        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">guard</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">func</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    raw_data <span class="token operator">*</span>unprotected<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">malicious_function</span><span class="token punctuation">(</span>raw_data <span class="token operator">&amp;</span>protected_data<span class="token punctuation">)</span> <span class="token punctuation">{</span>     unprotected <span class="token operator">=</span> <span class="token operator">&amp;</span>protected_data<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    data_wrapper x<span class="token punctuation">;</span>    x<span class="token punctuation">.</span><span class="token function">process_data</span><span class="token punctuation">(</span>malicious_function<span class="token punctuation">)</span><span class="token punctuation">;</span>    unprotected<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** outputa = 100*/</span></code></pre><p>即便在类data_wrapper内对于数据的访问在互斥量范围内，但是由于访问数据之后，导致返回了引用类型，导致类的外部可以通过raw_data对象的指针修改累的数据，这已经超过了互斥量作用的范围。</p><p>基于这种问题，需要注意：</p><ul><li>不要将类中数据的指针或者引用传递到类外，脱离互斥量的管控；</li><li>不要将外部不在互斥量影响范围内的函数传递到类中；</li></ul><h2 id="锁的粒度导致的问题"><a href="#锁的粒度导致的问题" class="headerlink" title="锁的粒度导致的问题"></a>锁的粒度导致的问题</h2><p>在上述的说明中，当需要对多线程访问共享数据进行保护时，需要使用互斥量对于共享数据进行保护，使得只有一个线程能够操作。换言之，只要多线程操作数据，就让互斥量参与其中，就能确保万事大吉吗？显然不是这样，这涉及到锁的粒度的问题。</p><h3 id="仍然存在条件竞争"><a href="#仍然存在条件竞争" class="headerlink" title="仍然存在条件竞争"></a>仍然存在条件竞争</h3><p>当锁的粒度过细时，对于多种操作的组合，可能仍然存在race condition，怎么理解这句话呢？还是代码说话吧。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> task<span class="token punctuation">{</span>    string name<span class="token punctuation">;</span>    <span class="token keyword">int</span> priority<span class="token punctuation">;</span>    <span class="token function">task</span><span class="token punctuation">(</span>string n<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>        name <span class="token operator">=</span> n<span class="token punctuation">;</span>        priority <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">task_queue</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    mutex m<span class="token punctuation">;</span>    deque<span class="token operator">&lt;</span>task<span class="token operator">></span> tasks<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">add_task</span><span class="token punctuation">(</span>task t<span class="token punctuation">)</span><span class="token punctuation">{</span>        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">guard</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        tasks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    task <span class="token function">get_oldest_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">guard</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        task oldest_task <span class="token operator">=</span> tasks<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tasks<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> oldest_task<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    task <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">guard</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> tasks<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">guard</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        tasks<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">process_task</span><span class="token punctuation">(</span>task_queue <span class="token operator">&amp;</span>tq<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// method 1. not safe</span>    <span class="token comment" spellcheck="true">// task t = tq.front();</span>    <span class="token comment" spellcheck="true">// this_thread::sleep_for(chrono::milliseconds(1));</span>    <span class="token comment" spellcheck="true">// tq.pop_front();</span>    <span class="token comment" spellcheck="true">// method 2. safe</span>    task t <span class="token operator">=</span> tq<span class="token punctuation">.</span><span class="token function">get_oldest_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"process task : name = "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">"; priority = "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>priority <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    task_queue tq<span class="token punctuation">;</span>    tq<span class="token punctuation">.</span><span class="token function">add_task</span><span class="token punctuation">(</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"task1"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      tq<span class="token punctuation">.</span><span class="token function">add_task</span><span class="token punctuation">(</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"task2"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tq<span class="token punctuation">.</span><span class="token function">add_task</span><span class="token punctuation">(</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"task3"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span>process_task<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span>tq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t2</span><span class="token punctuation">(</span>process_task<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span>tq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里，我们构建一个task_queue，其中每个操作都在lock_guard的保护之下，但是在使用process_task时，使用method 1时，发现task1被处理了两次，而且一个task丢失了，没有被处理。这里使用两个线程去处理，因为计算机太快，可能运行很多次也不会有错误的输出，因此这里稍微sleep一下，现象就比较明显，如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/1.png" alt="线程共享时因为锁的粒度太细导致出错"></p><p>上述中，打印输出因为没有同步，也会出现乱序，是可以预期的。当使用method 2时，就不会出现上述行为，其原因在于，两种情况下，lock_guard保护的范围不同，如下分析：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/2.png" alt="两种不同方法的差异"></p><p>因为锁的粒度不同，在方法一种，任何时刻，保证了只有一个线程能够访问对应的操作函数，但是不能保证两个函数都在一个被保护的范围内，这就出现了交叉，也就出现了race condition；当两个操作被一个lock_guard保护时，就不会出现交叉的问题。</p><h3 id="性能太差"><a href="#性能太差" class="headerlink" title="性能太差"></a>性能太差</h3><p>基于上述的分析，粒度过小时会出现同步的问题，那将粒度很大时，保护范围就大了，就不会出问题了。这个说法从共享同步的角度说得通，但是此时使用多线程的技术就没有什么意义了，这是因为，当锁的粒度太大时，并行就会变成串行，严重影响性能。而在实际情况中，这种多线程退化为单线程的方式，其实比单线程性能更低，因为还有线程切换消耗的资源。</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/3.png" alt="粒度太粗使得多线程并发执行变成了串行执行"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://ciphersaw.me/ctf-wiki/pwn/linux/race-condition/introduction/">https://ciphersaw.me/ctf-wiki/pwn/linux/race-condition/introduction/</a></li><li><a href="https://www.cnblogs.com/linuxAndMcu/p/14576577.html">https://www.cnblogs.com/linuxAndMcu/p/14576577.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
            <tag> mutex </tag>
            
            <tag> lock_guard </tag>
            
            <tag> RAII </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++线程：thread中传递参数和所有权</title>
      <link href="/2022/11/30/bian-cheng-zhi-dao/c-xian-cheng-thread-zhong-chuan-di-can-shu-he-suo-you-quan/"/>
      <url>/2022/11/30/bian-cheng-zhi-dao/c-xian-cheng-thread-zhong-chuan-di-can-shu-he-suo-you-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="线程之间的参数传递"><a href="#线程之间的参数传递" class="headerlink" title="线程之间的参数传递"></a>线程之间的参数传递</h1><p>在创建线程时，可以向线程执行的函数传递参数，使用方式很简单，直接向thread对象的构造函数中传递即可。这些参数会被复制到对应的线程空间，我们知道C++中的参数传递分为：</p><ul><li>pass by value</li><li>pass by reference</li></ul><p>另外，对于一些特定类型的参数，不能进行copy，只能move，因此也需要对这一类场景进行说明。</p><h2 id="基本使用：pass-by-value"><a href="#基本使用：pass-by-value" class="headerlink" title="基本使用：pass by value"></a>基本使用：pass by value</h2><p>基本的参数传递方式是pass by value，使用如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">": call do_on_background"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**0x7ffe264ba6bc0x7f5b3e2cddbc0: call do_on_background*/</span></code></pre><p>传递到线程执行的参数中的变量的地址不同，即发生了copy。</p><h2 id="引用类型参数-amp-std-ref"><a href="#引用类型参数-amp-std-ref" class="headerlink" title="引用类型参数 &amp; std::ref"></a>引用类型参数 &amp; std::ref</h2><p>引用类型的变量，应该是指向同一个地址的，那么看如下代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id : "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"address of a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">": call do_on_background"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id : "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"address of a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token function">do_on_background</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**thread id : 140598405343040address of a: 0x7fff65782e0cthread id : 140598405343040address of a: 0x7fff65782e0c0: call do_on_backgroundthread id : 140598387095296address of a: 0x5594f464a2880: call do_on_background*/</span></code></pre><p>从上述代码发现：</p><ul><li>当在同样的线程中时，即main所在的线程和do_on_background(a)执行时所在的线程相同，此时变量a可以按照引用传递；</li><li>当在不同的线程中时，即便写成const int&amp;的形式，传递的函数参数也不是引用， 而是不同的地址，即发生了copy，发生的是pass by value，诡异，为啥呢？</li></ul><p>这是因为thread构造函数和std::bind的操作在标准库中以相同的机制进行定义，其中涉及到c++11中的一个新概念——<a href="https://devtut.github.io/cpp/callable-objects.html">Callable Objects</a>。因为Callable Objects有多种定义形式，因为C++11使用统一了它们的操作，将它们通过std::bind绑定到统一的包装形式std::functino，以方便使用。在这种情况下，默认是copy函数参数的，如果想要pass by referecne，需要使用std::ref。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id : "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"address of a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">": call do_on_background"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id : "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"address of a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token function">do_on_background</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**thread id : 0x1195afdc0address of a: 0x7ffee12c52f8thread id : 0x1195afdc0address of a: 0x7ffee12c52f80: call do_on_backgroundthread id : 0x70000bfac000address of a: 0x7ffee12c52f80: call do_on_background*/</span></code></pre><p>通过使用ref之后，发现在不同的线程中，发现使用的变量是同一个，即函数参数是按照引用传递的。</p><p>关于std::function和std::ref的一些参考资料如下：</p><ol><li><a href="https://juejin.cn/post/7094192602638974990">https://juejin.cn/post/7094192602638974990</a></li><li><a href="https://murphypei.github.io/blog/2019/04/cpp-std-ref">https://murphypei.github.io/blog/2019/04/cpp-std-ref</a></li><li><a href="https://www.nextptr.com/tutorial/ta1441164581/stdref-and-stdreference_wrapper-common-use-cases">https://www.nextptr.com/tutorial/ta1441164581/stdref-and-stdreference_wrapper-common-use-cases</a></li></ol><h2 id="只支持move的函数参数"><a href="#只支持move的函数参数" class="headerlink" title="只支持move的函数参数"></a>只支持move的函数参数</h2><p>在C++11中，一些类的对象只支持move，不支持copy和assignment，例如：<code>unique_ptr</code>。针对这种情况，需要使用std::move函数。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> up<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>up <span class="token operator">&lt;&lt;</span> <span class="token string">": call do_on_background"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">,</span> <span class="token function">move</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**10: call do_on_background*/</span></code></pre><h1 id="转移ownership"><a href="#转移ownership" class="headerlink" title="转移ownership"></a>转移ownership</h1><p>线程的所有权这方面，与unique_ptr很类似，即可以move，但是不能copy。</p><ul><li>即线程对象可以在多个线程对象之间转移所有权，这让我们决定可以让哪个线程对象有线程执行的决策权；</li><li>但是，线程不可以复制，即，任意一个时间点上，只有一个线程对象关联一个实际执行的线程；</li></ul><p>线程所有权转移的使用场景，可有3种，如下所示。</p><h2 id="直接使用移动构造函数"><a href="#直接使用移动构造函数" class="headerlink" title="直接使用移动构造函数"></a>直接使用移动构造函数</h2><p>在新的线程对象的构造中，直接使用move来转移线程对象的所有权。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call do_on_background"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread t2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>       t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**thread id: 0x7000026cd000call do_on_background*/</span></code></pre><p>值得注意的是，当线程的所有权被转移后，其原来的线程对象与实际线程的执行没有一毛钱关系，也就不能调用join或者detach。当一个线程对象的所有权被转移后，如果尝试调用join和detach时，则会报错：</p><pre class=" language-cpp"><code class="language-cpp">thread <span class="token function">t1</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">;</span>thread t2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span> t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>报错如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9Athread%E4%B8%AD%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83/1.png" alt="所有权被转移的线程对象尝试调用join时"></p><p>另外，当一个已有对应执行线程的线程对象在接受一个新的执行对象所有权的转移时，是会导致程序崩溃的。</p><pre class=" language-cpp"><code class="language-cpp">thread <span class="token function">t1</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">;</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">;</span>t1 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当执行时报错如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9Athread%E4%B8%AD%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83/2.png" alt="线程对象尝试控制多个执行线程时报错"></p><p>当一个线程对象尝试控制2个甚至更多的执行线程时，会导致系统直接调用std::terminate直接终止程序运行。</p><h2 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h2><p>thread对象作为函数返回值时，不需要使用move，因为函数调用技术，线程对象本来就要销毁，是一个典型的将亡值，是右值，因此自动调用移动构造函数。</p><pre class=" language-cpp"><code class="language-cpp">thread <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">thread</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>thread <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    thread t1 <span class="token operator">=</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread t2 <span class="token operator">=</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** outputthread id: 0x700007582000call do_on_backgroundthread id: 0x700007605000call do_on_background*/</span></code></pre><h2 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>thread t<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">thread</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里，如果将thread对象作为参数传递给函数时，如果是一个左值，比如t1，需要使用move函数。如果是一个右值，则不用，例如上述的临时线程对象。注意，上述代码的输出是不确定的。</p><h1 id="一些其他的用法"><a href="#一些其他的用法" class="headerlink" title="一些其他的用法"></a>一些其他的用法</h1><h2 id="线程的数量与硬件的关系"><a href="#线程的数量与硬件的关系" class="headerlink" title="线程的数量与硬件的关系"></a>线程的数量与硬件的关系</h2><p>线程的频繁调度也会影响性能，因为涉及到一些状态的保存和恢复，因此了解计算机实际支持的并发线程能力很重要，C++提供了一个函数可以查询：</p><pre class=" language-cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> thread<span class="token operator">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// output: 8</span></code></pre><p>其会返回允许的并发线程的数量。在多核系统中，返回值可以是CPU核的数量。当返回值无法获取时，也会返回0。</p><h2 id="识别具体的线程"><a href="#识别具体的线程" class="headerlink" title="识别具体的线程"></a>识别具体的线程</h2><p>有两种方法可以识别当前程序运行的线程：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call do_on_background"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. method 1</span>    thread<span class="token operator">::</span>id thread_id <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread t id: "</span> <span class="token operator">&lt;&lt;</span> thread_id <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. method 2</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**output:thread t id: 0x700001428000thread id: thread id: 0x11114ddc00x700001428000call do_on_background*/</span></code></pre><p>当使用t.get_id()时，如果有对应的执行线程，可以保证返回对应的thread id，如果没有，则会返回thread::type。</p><pre class=" language-cpp"><code class="language-cpp">thread <span class="token function">t1</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">;</span>thread t2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>thread<span class="token operator">::</span>id thread_id <span class="token operator">=</span> t1<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread t1 id: "</span> <span class="token operator">&lt;&lt;</span> thread_id <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**thread t1 id: 0x0thread id: 0x7000003eb000call do_on_background*/</span></code></pre><p>当t1的所有权被转移给t2时，如果查询t1对应的线程id，则会返回0x0。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Concurrency in action - 2.2 - 2.5</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> thread </tag>
            
            <tag> ref </tag>
            
            <tag> move </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++线程：thread的基本使用方式</title>
      <link href="/2022/11/28/bian-cheng-zhi-dao/c-xian-cheng-thread-de-ji-ben-shi-yong-fang-shi/"/>
      <url>/2022/11/28/bian-cheng-zhi-dao/c-xian-cheng-thread-de-ji-ben-shi-yong-fang-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="基本使用样例"><a href="#基本使用样例" class="headerlink" title="基本使用样例"></a>基本使用样例</h1><p>这里使用一个基本的使用模版来说明thread的使用方式。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">background_task</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call background task in operator ()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call do_on_background"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.</span>    background_task bt<span class="token punctuation">;</span>    thread <span class="token function">t2</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** outputcall do_on_backgroundcall background task in operator ()*/</span></code></pre><blockquote><p>clang编译直接运行就行，linux下使用g++编译需要指定 <code>-lpthread</code>。</p></blockquote><p>上述代码的输出是确定的，不会出现不同的输出。基本的套路如下：</p><ol><li>构建thread对象；</li><li>定义一个函数，作为thread构造函数的参数传入，可以是普通的对象或者是函数类的对象；</li><li>调用join函数，让主线程等子线程执行完再继续执行，保证了执行顺序；</li></ol><p>在这个过程中，do_on_background等函数会被复制到线程的存储空间中，这些函数的执行和调用都在线程的内存空间中进行。</p><h1 id="thread对象构造时的问题"><a href="#thread对象构造时的问题" class="headerlink" title="thread对象构造时的问题"></a>thread对象构造时的问题</h1><p>在构造thread过程中会存在一个问题，对于普通函数do_on_background不存在，但是对于函数对象来说，会出现<a href="https://en.wikipedia.org/wiki/Most_vexing_parse">most vexing parse</a>，具体来说是这样的：</p><p>我们以为下述代码的含义是：构建一个background_task的对象，并用这个临时的函数对象初始化thread对象：</p><pre class=" language-cpp"><code class="language-cpp">thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token function">background_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但是，C++编译器是这么理解的：</p><p>声明了一个函数t2，返回thread对象，t2函数的参数是一个函数指针，该函数指针本质为：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">background_task</span><span class="token punctuation">(</span><span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>即返回值为background_task对象，且无参数的函数指针。使用这个写法来声明thread对象时，会有如下的错误出现：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9Athread%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/1.png" alt="错误如上"></p><p>直接告诉我们，这种写法被认为是函数声明，还告诉我们一种解决方法：</p><ul><li><p>加个()</p><pre class=" language-cpp"><code class="language-cpp">thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">background_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>还可以使用list initialization</p><pre class=" language-cpp"><code class="language-cpp">thread t2<span class="token punctuation">{</span><span class="token function">background_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li><li><p>使用lambda表达式也是可以的；</p><pre class=" language-cpp"><code class="language-cpp">thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call lambda expression"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h1 id="thread对象析构时的问题"><a href="#thread对象析构时的问题" class="headerlink" title="thread对象析构时的问题"></a>thread对象析构时的问题</h1><p><strong>当构造完成thread对象后，必须调用join或者detach来执行，否则会报错</strong>，其原因在于创建的线程有两个状态，如果thread对象析构时，为nonjoinable时，则会直接终止，如<a href="https://blog.51cto.com/liangchaoxi/4125187">文章</a>所述。</p><p>如果没有使用join或者detach时，当main程序结束之后，线程对象被析构之前，如果发现线程对象是joinable时，就会直接调用std::terminate结束线程的运行，如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9Athread%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/2.png" alt="std::terminate结束线程运行"></p><blockquote><p><a href="https://stackoverflow.com/questions/7381757/c-terminate-called-without-an-active-exception">When a thread object goes out of scope and it is in joinable state, the program is terminated.</a></p></blockquote><h2 id="join还是detach？"><a href="#join还是detach？" class="headerlink" title="join还是detach？"></a>join还是detach？</h2><p>两者之间有什么区别吗？</p><ul><li><p>join</p><blockquote><p>Blocks the current thread until the thread identified by *this finishes its execution.</p></blockquote><p>  在上述样例代码中，join表示main线程等待t1和t2等线程的结束，才会继续执行。</p><p>  该函数调用后，一定能保证线程的输出是确定的，不一定，只能保证创建子线程的线程与父线程之间有等待关系，多个兄弟线程之间不保证，如上代码改为下述代码就不保证输出是确定的。</p><pre class=" language-cpp"><code class="language-cpp">thread <span class="token function">t1</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">)</span><span class="token punctuation">;</span>background_task bt<span class="token punctuation">;</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span>t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>  对于<code>join</code>的调用，一个线程只能使用一次，可以通过<code>joinable</code>来判断线程是否允许<code>join</code>，奇怪的是这个函数也可以用来判断是否允许<code>detach</code>。</p><p>  在main中调用join，其实另外一个作用是，清理线程创建使用的资源，避免资源泄露。</p></li><li><p>detach</p><blockquote><p>Separates the thread of execution from the thread object, allowing execution to continue independently. Any allocated resources will be freed once the thread exits.</p></blockquote><p>  该函数表示main对应的线程不管t1h和t2等线程的执行，它们可以独立地执行，因此也不会等待它们，这样最终输出的结果也是不确定的。</p><p>  当线程执行结束后，其获得资源也会被释放。当main对应的线程结束后，detach的线程也不一定执行完成。当调用detach之后，在main函数中声明的线程对象与实际线程的执行没有关系，也无法进行管理了。</p></li></ul><h2 id="对象lifetime的影响"><a href="#对象lifetime的影响" class="headerlink" title="对象lifetime的影响"></a>对象lifetime的影响</h2><p>在单线程程序中，对于变量的访问，受到了其生命周期的影响，例如，当block scope结束后，其中的变量会被销毁，就不能进行访问了。但是，这种情况也很简单，因为只要保证单线程访问时，变量没有被销毁即可，这种条件，对于编程人员，可能很明显地发现来避免。</p><p>但是在多线程程序中，需要保证线程在访问变量时，变量仍然存在，此时，编程人员很难去发现，保证变量与线程的生命周期重叠。对于线程的启动，我们当前有join和detach来介入线程的实际运行方式。</p><ul><li><p>join</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">": call do_on_background"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**output: 0: call do_on_background*/</span></code></pre><p>  这里的输出一定是确定的，因为t.join()保证在main线程停止，等待t线程结束运行，此时变量a一直存在，不会销毁。</p></li><li><p>detach</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">": call do_on_background"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>  在上述代码中线程t中可就会访问不到变量a，因为当main线程结束，a被销毁，其引用也就无意义了。但是这种问题并不容易发现。</p><p>  针对这种问题，一般有两种解决方法：</p><ul><li>使用join等待，确保局部变量在线程执行完才销毁；</li><li>将传递的数据进行复制，而不是引用，这样数据就在main和t线程中存在两份，分别对应个各自线程的生命周期。</li></ul><blockquote><p>在线程之间，尤其是指针和引用等数据要注意使用和共享。</p></blockquote></li></ul><h1 id="资源泄露：join的位置在哪？"><a href="#资源泄露：join的位置在哪？" class="headerlink" title="资源泄露：join的位置在哪？"></a>资源泄露：join的位置在哪？</h1><p>在前面，我们已经发现，join的位置不同，会导致输出的结果变得确定、或者不确定。另外join还会回收资源，如果join未执行，则会导致资源泄露，常见的导致join未执行的行为包括：</p><ul><li>提前return；</li><li>原始线程出现异常被抛出；</li></ul><p>如下：</p><pre class=" language-cpp"><code class="language-cpp">thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">throw</span> <span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述代码不会输出“call do_on_background”，因为有异常抛出，main非正常退出。当抛出异常后，程序直接调用std::terminate，不会执行到t.join，因此线程对象t的资源没有被释放。</p><p>如果在捕捉到相关的异常后，也可以调用join，这时也能保证线程的资源被回收，如下：</p><pre class=" language-cpp"><code class="language-cpp">thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>     <span class="token keyword">throw</span> <span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">const</span> exception <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%BA%BF%E7%A8%8B%EF%BC%9Athread%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/3.png" alt="线程可以正常执行不会终止"></p><p>还可以使用<a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a>来解决这种问题：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">thread_guard</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>thread <span class="token operator">&amp;</span>t<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">thread_guard</span><span class="token punctuation">(</span>std<span class="token operator">::</span>thread <span class="token operator">&amp;</span>t_<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">t</span><span class="token punctuation">(</span>t_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">thread_guard</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">thread_guard</span><span class="token punctuation">(</span>thread_guard <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    thread_guard <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>thread_guard <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">do_on_background</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">": call do_on_background"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    thread <span class="token function">t</span><span class="token punctuation">(</span>do_on_background<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread_guard <span class="token function">g</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main over"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述使用RAII来管理线程资源，当main函数退出时，对象g会被析构，然后就会调用join，使得线程对象t的资源被正确释放。但是，注意上述代码的输出是不确定的，这也是join位置造成的影响。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Concurrency in action - 2.1 - Basic thread management</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> thread </tag>
            
            <tag> join </tag>
            
            <tag> detach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan的programming model</title>
      <link href="/2022/11/27/ji-suan-ji-tu-xing-xue/vulkan/vulkan-de-programming-model/"/>
      <url>/2022/11/27/ji-suan-ji-tu-xing-xue/vulkan/vulkan-de-programming-model/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="vulkan-application都需要什么"><a href="#vulkan-application都需要什么" class="headerlink" title="vulkan application都需要什么"></a>vulkan application都需要什么</h1><p>要完成一个Vulkan API编写的应用，需要哪些东西呢？如下图所示。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84programming-model/1.png" alt="vulkan application需要的组件"></p><ol><li>首先，你需要一个<strong>支持Vulkan的GPU</strong>，否则无法运行应用；</li><li>其次，你需要<strong>Vulkan Driver</strong>，这个不需要单独安装，一般和GPU一起绑定出厂；</li><li>第三，为了写一个application，你需要<strong>一套Vulkan SDK</strong>；</li><li>之后，写完的application需要运行<strong>SPIR-V格式的shader</strong>；</li><li>最后，application得到的结果，需要显示在屏幕上，你需要<strong>Windows System Integration</strong>。</li></ol><h2 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h2><h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><p>驱动是沟通application和GPU的中介，在application执行中，可以通过driver来查询GPU有多少可用的<code>PhysicalDevice</code>，每个<code>Device</code>中有多少个<code>Queue</code>，每个<code>Queue</code>具体什么功能。</p><p>Vulkan只是提供了一个统一的API，其具体的实现由各个硬件厂家完成，而这些厂家一般将驱动和对应的GPU绑定出厂，而驱动的功能和能效也是竞争力所在。</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>由开发人员负责提供，用于执行图形渲染或者并发计算等任务。Vulkan programming model规范地说明了一个Vulkan application的一般化操作，下边会详述。</p><h3 id="Vulkan-SDK"><a href="#Vulkan-SDK" class="headerlink" title="Vulkan SDK"></a>Vulkan SDK</h3><p>用于支持Vulkan application的一系列工具，类似Java中的JDK。</p><h3 id="SPIR-V"><a href="#SPIR-V" class="headerlink" title="SPIR-V"></a>SPIR-V</h3><p>在GPU中通过可编程的shader来完成各种顶点计算、着色等操作，Vulkan中的shader是<a href="https://www.khronos.org/spir/">SPIR-V格式</a>的——a precompiled binary format。这种形式的最大好处是在运行时不用编译了，提高了执行的效率，而且SDK中提供了compiler，可以将多种shader语言编写成SPIR-V的格式，如：<a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)">GLSL</a>、HLSL等。</p><h3 id="WSI"><a href="#WSI" class="headerlink" title="WSI"></a>WSI</h3><p>Vulkan application的结果不一定要展现在屏幕上，比如并行计算的结果，即便是对于图形渲染的结果也不是强制的，但是为了方便开发，显现在屏幕上还是有很多的需求。但是Vulkan官方的规范中没有明确提出与window system交互，而是通过extension来实现的。<code>Windows System Integration</code>就是来自Khronos的一系列extensions，统一了对于Linux、Windows和Android等屏幕的呈现功能。</p><h1 id="Vulkan-programming-model"><a href="#Vulkan-programming-model" class="headerlink" title="Vulkan programming model"></a>Vulkan programming model</h1><p>什么是编程模型，“模型”肯定是对一系列事务的共性的描述，那编程模型，可以理解为对于编程这件事的共性的描述。编程模型之前可以添加很多的定语，来描述“什么样的编程”的共性，例如：有事件驱动的编程模型等。</p><p>那么这里，就容易理解了——要说的是，通过vulkan API进行编程的共性的描述。也就是使用Vulkan API编程，不管是复杂还是简单，你一般都需要干哪些事情，具体应该怎么干。</p><p>Vulkan programming model整体结构如下：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84programming-model/2.png" alt="Vulkan programming model"></p><h2 id="Hardware-Initialization"><a href="#Hardware-Initialization" class="headerlink" title="Hardware Initialization"></a>Hardware Initialization</h2><p>在application开始正常运行之前，首先需要初始化硬件。<strong>所谓初始化硬件，需要找到操作GPU的driver，这个操作是通过定位loader来实现的</strong>。</p><p><a href="https://github.com/KhronosGroup/Vulkan-Loader">Vulkan loader的文档</a>中说到：</p><blockquote><p>The ICD loader is a library that is placed between a Vulkan application and any number of Vulkan drivers, in order to support multiple drivers and the instance-level functionality that works across these drivers. Additionally, the loader manages inserting Vulkan layer libraries, such as validation layers, between an application and the drivers.</p></blockquote><p>简单说：</p><ul><li>loader是一个代码组件，主要任务是在application启动时去查找GPU对应的driver；</li><li>loader加载driver的方式在各个平台中是一致的。<ul><li>前面提到，在Vulkan中保证所有操作在所有平台都是一致的，不一致的地方通过extension的方式支持；</li></ul></li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84programming-model/3.png" alt="loader所处的位置"></p><p>这个loader会还会完成哪些工作呢？在<a href="https://github.com/KhronosGroup/Vulkan-Loader/blob/master/docs/LoaderInterfaceArchitecture.md#overview">loader中存在一个layered architecture</a>。如下图所示：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84programming-model/4.png" alt="Loader layered architecture"></p><p>对于不希望在vulkan API中实现的功能，可以通过在这里加一个layer来实现，以实现与vulkan driver的解耦，当需要这些功能时就打开（开发阶段），不需要就关闭（发布阶段）。具体包括以下功能：</p><ul><li><p>Error &amp; Validation for debugging purpose</p><p>在vulkan中，各种调试工作是通过validation layer实现的，不是vulkan core API的一部分，因此此时不需要找到vulkan driver。如<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers">Validation layers</a>所述。</p></li><li><p>Tracing vulkan API commands</p></li></ul><p>一旦loader找到对应的driver并且成功建立链接，后续application需要逐步完成：</p><ul><li><p>create vulkan instance</p><p>在vulkan中没有类似<a href="https://softwareengineering.stackexchange.com/questions/380832/opengl-and-global-state">OpenGL的global state</a>，而是每个application都有自己的state，存储在<code>VkInstance</code>中，之后通过该对象初始化vulkan API，将application自身的信息传递出去。</p></li><li><p>query physical devices for available queues</p></li><li><p>query extensions and store them as function pointers</p><p>如WSI (Window System Integration) extensions等。</p></li><li><p>enable an injectable layer for error checking, debugging</p></li></ul><h2 id="Windowing-Presentation-Surface"><a href="#Windowing-Presentation-Surface" class="headerlink" title="Windowing Presentation Surface"></a>Windowing Presentation Surface</h2><p>在完成driver的加载后，需要完成绘制任务，为了将绘制的结果显示在屏幕上，需要完成两件事：</p><ol><li>perform the drawing task to build an image</li><li>put the image on the presentation window</li></ol><p>这两个任务都是与具体的平台密切相关的，但是在vulkan的设计哲学中，所有的API都尽量与平台解耦，以统一的方式提供。而且，Vulkan本身不直接提供关于window创建相关的API，而是通过extension的方式支持，因此这2个任务通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap33.html">Window System Integration（WSI）</a>完成：</p><ul><li><p>WSI中使用统一的API来创建window并且显示image，隐藏了技术细节，同时支持跨平台的功能。</p></li><li><p>WSI还支持<a href="https://en.wikipedia.org/wiki/Swap_chain">swap chain机制</a>，这种机制本质上是一个<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain">images的队列</a>，当在屏幕上显示一张图像时，application可以处理下一张图像。</p><blockquote><p>Vulkan does not have the concept of a “default framebuffer”, hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen. This infrastructure is known as the <strong>swap chain</strong> and must be created explicitly in Vulkan. <strong>The swap chain is essentially a queue of images that are waiting to be presented to the screen</strong>.</p></blockquote></li></ul><p>WSI作为Display和application之间的interface，在两者之间不断交换image，保证image轮转地在两者之间被处理。如下图所示：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84programming-model/5.png" alt="WSI将image在Display和application之间轮换"></p><p>总的来说，此时通过WSI需要完成如下任务：</p><ul><li><p>通过调用本地的API实现创建一个window；</p></li><li><p>创建一个WSI Surface 附着到这个window上；</p><blockquote><p><code>VK_KHR_surface</code> exposes a <code>VkSurfaceKHR</code> object that represents an abstract type of <strong><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface">surface</a></strong> to present rendered images to.</p></blockquote></li><li><p>创建一个swapchain以便将image呈现到surface</p></li><li><p>向创建的swapchain请求已经绘制的image</p></li></ul><p>整个层次结构如下所示：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84programming-model/6.png" alt="使用WSI显示图像的层次结构"></p><h2 id="Resource-Setup"><a href="#Resource-Setup" class="headerlink" title="Resource Setup"></a>Resource Setup</h2><p><strong>资源设置是什么意思？其本质很简单，就是存储vulkan应用的数据到内存空间中</strong>，以便在后续的程序中可以使用。<strong>在我们的语境下，所谓资源一般是指内存资源</strong>。</p><p>这里又要对比OpenGL和vulkan的区别了，OpenGL使用隐式的内存管理，而vulkan提供了low-level的API来操作底层的内存管理。在physical device中，vulkan提供了不同类型的内存，从而可以方便且显式地管理这些内存。</p><h3 id="内存资源的类型"><a href="#内存资源的类型" class="headerlink" title="内存资源的类型"></a>内存资源的类型</h3><blockquote><p>这里有疑问，所谓多种类型的memory是什么意思？memory不是一个统一的DDR吗？原因在于划分标准不同，按照性能和位置进行划分。</p></blockquote><p>在Vulkan中内存可以分为两种类型：</p><ul><li><p>host local</p><p>内存访问比较慢。</p><ul><li><p>host local, device visible</p><p>指的是host自己的内存资源，但是能被device访问。</p></li></ul></li><li><p>device local</p><p>这种内存在physical device中，具有高带宽的特点，比较快。</p><p>这种类型的内存可以进一步划分为：</p><ul><li>device local, host not visible</li><li>device local, host visible</li></ul></li></ul><h3 id="资源的管理过程"><a href="#资源的管理过程" class="headerlink" title="资源的管理过程"></a>资源的管理过程</h3><ol><li><p>创建resource objects</p><p> 这里要明确resource objects这个概念，我的理解是占据内存的是哪种类型的objects，比如用来存储images的内存，和用来存储buffer objects的内存。application负责为这些resource objects分配内存资源。</p></li><li><p>allocation &amp; suballocation</p><p> 当这些resource objects被创建后，它们只知道内存的virtual address，还不知道physical address，也就无法实际访问内存空间。而之后，application负责分配内存，并将这些virtual address绑定到physical address中，如<a href="https://lifehit.cn/2022/10/29/ji-suan-ji-ji-chu/virtual-memory-1-jian-jie/">文章</a>所述。</p><p>   这里要注意一个问题，allocation是个expensive task，尽量不用多用，代替以suballocation，具体行为是，一次申请一大块内存空间，之后不再申请，而是将不同的resource objects放入到该内存空间中的各个小块。如下图所示：</p><p> <img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84programming-model/7.png" alt="suballocation的行为"></p></li><li><p>sparse memory的支持</p><p> vulkan支持sparse memory。对于一个很大的object，例如image object，其超过了当前分配给其的内存空间，因此可以对其进行切分，分成很多的小块，存储到很多的小内存空间中，当application要使用该object时，根据放置这些小块时记录的映射关系，再加载回来，这个过程对于application是不可知的。</p><blockquote><p>基于sparse memory的方法，我的理解是会影响效率，写入时切分小块，读出时再组合，有额外的工作。其需要至少保存两类信息，与切分后各个小块的映射关系，各个小块之间的依赖关系。</p></blockquote></li><li><p>使用staging buffer作为数据中转站</p><p> 如果要将vertex等data放到内存中，最简单的方法是直接放到CPU中，即host local，然后让GPU执行任务时去读取。但是，前面说到，这种类型memory很慢，当都需要读取大量数据时，受限于带宽，无法实现最优的性能，因此将数据放到device local才是最理想的方式。基于此，需要首先在CPU上构建staging buffer，将数据传输到这里，然后再将这些数据转移到device local中，<a href="https://vulkan-tutorial.com/Vertex_buffers/Vertex_input_description">vulkan-tutorial中有讲这个过程</a>。</p></li><li><p>异步传输数据</p><p> 完成了数据通道的构建，之后使用异步命令在graphic、DMA/tranfer queues中实现数据的传输。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>资源管理的流程可以总结如下：</p><ol><li><p>create resource objects</p></li><li><p>query the appropriate memory instance and create memory objects</p><p> 简单说就是，将申请一块大内存，并将其切分为小块，分配给各个resource objects。</p></li><li><p>get memory requirements for the allocation.</p><p> 分配的内存资源是否足够，要使用sparse memory机制吗？</p></li><li><p>allocate space and store data in it</p></li><li><p>bind the memory with the created resource objects</p></li></ol><h2 id="Pipeline-Setup"><a href="#Pipeline-Setup" class="headerlink" title="Pipeline Setup"></a>Pipeline Setup</h2><blockquote><p>a pipeline is a set of events that occur in a fixed sequence defined by the applcaition logic.</p></blockquote><p>这部分的工作包括：</p><ol><li>supply the shaders</li><li>bind the shaders to the resource allocated in <strong>resource setup</strong></li><li>manage the states of the pipeline</li></ol><h3 id="descriptor-sets"><a href="#descriptor-sets" class="headerlink" title="descriptor sets"></a>descriptor sets</h3><p>descriptor set是shaders和resources之间的桥梁，shaders通过descriptor sets实现对于resources的访问和使用。</p><p>descriptor sets有一系列特性：</p><ul><li><p>frequent change</p><p>  descriptor sets中存储了很多属性信息，类似关于texture等的，其数据变化的很频繁，而频繁地刷新descriptor sets是一项expensive task，极大地影响vulkan的性能。基于此，vulkan将descriptor sets在逻辑上划分为几个levels：</p><ul><li>scene : low frequecy udpate  </li><li>model : medium frequecy udpate</li><li>draw : high frequency update</li></ul><p>  这确保，对于draw level的高频更新不会影响scene等低频中descriptor sets对应的资源。</p></li><li><p>multithread scalability</p><p>  允许多个线程同时更新descriptor sets中的数据。</p></li><li><p>allocation mechnism</p><p>  descriptor sets是从descriptor pool中分配的，descriptor pool中维护了很多的descriptors，这些descriptor sets的同步由descriptor pool负责。</p></li></ul><h3 id="shaders-with-SPIR-V"><a href="#shaders-with-SPIR-V" class="headerlink" title="shaders with SPIR-V"></a>shaders with SPIR-V</h3><p>在vulkan中指定shader的方式只有通过SPIR-V这一种，但是具有如下特点：</p><ul><li><p>various source languages</p><p>  支持使用多种language编写human-reabable shaders，如：GLSL、HLSL，并使用LunarG提供的compiler编译成SPIR-V格式。</p></li><li><p>offline compilation</p><p>  vulkan中的shaders都是预先编译好的，不会在程序运行期间编译，提高了效率。</p></li></ul><h3 id="Pipeline-state-management"><a href="#Pipeline-state-management" class="headerlink" title="Pipeline state management"></a>Pipeline state management</h3><h4 id="pipeline-state是什么？"><a href="#pipeline-state是什么？" class="headerlink" title="pipeline state是什么？"></a>pipeline state是什么？</h4><blockquote><p>A physical device contains a range of hardware settings that determine how the submitted input data of a given geometry needs to be interpreted and drawn. These settings are collectively called pipeline states.</p></blockquote><p>状态可以分为2种类型：</p><ul><li>dynamic</li><li>static</li></ul><h4 id="state能干什么"><a href="#state能干什么" class="headerlink" title="state能干什么"></a>state能干什么</h4><p>这些state决定了创建哪种pipeline object（graphics/compute），而创建pipeline object是一个expensive task，最好只创建一次并且重用。</p><blockquote><p>为啥expensive？The VkPipeline is a huge object in Vulkan that encompasses the configuration of the entire GPU for the draw. Building them can be very expensive, as it will fully convert the shader module into the GPU instructions, and will validate the setup for it. 引自<a href="https://vkguide.dev/docs/chapter-2/pipeline_walkthrough/">这里</a>。具体来说，包括对shader重新编译，并将这些shader绑定到对应的resource上等工作。</p></blockquote><p>根据不同的状态变量及其取值，可以组合成百上千种pipeline objects</p><p>pipeline object和pipeline cache object(PCO)、pipeline layout一起控制pipeline state：</p><ul><li><p>pipeline cache object</p><p>  因为pipeline的创建是expensive，因此一旦被创建，就会被cached。这样，当需要创建一个新的pipeline object时，就会寻找最接近的PCO，然后基于此base pipeline创建新的pipeline object。</p><p>  需要说明的是，PCO可以提供性能，但是，这需要application负责持久化该cache对象，并在创建新的pipeline object时，匹配合适的PCO。</p></li><li><p>pipeline layout</p><p>  该对象描述了给定一个pipeline object，shaders的输入信息是什么样的。具体来说，就是通过descriptor sets，将resources绑定到shaders的binding slot来建立映射关系，以便后续shaders能够读取相应的数据，完成drawing tasks。</p></li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>这个阶段，我们完成了：</p><ol><li><p>shaders are compiled into SPIR-V forms and specified in the pipeline shader state.</p></li><li><p>descirptor sets connect resources to shaders.</p></li><li><p>application creates pipeline objects from PCO for better peformance.</p></li></ol><h2 id="Command-Recordings"><a href="#Command-Recordings" class="headerlink" title="Command Recordings"></a>Command Recordings</h2><p>这一步就是收集各个commands，构建command buffer的过程，以便后续提交到queue中。</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>为了记录application提交的commands，需要将它们包裹在一定的范围内，如下图是一个drawing command buffer被记录的描述：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84programming-model/8.png" alt="commands recording for drawing"></p><p>简要介绍一下，如果完成command recording：</p><blockquote><p>这个过程是一般化的，具体的场景可能会有变化。</p></blockquote><ul><li><p><code>scope</code></p><p>指定command buffer recordings的开始和结束所框定的范围。</p></li><li><p><code>Render Pass</code></p><p>指定了任务的执行具体过程。</p><blockquote><p>对于render pass这个概念，一直比较迷糊，Vulkan spec中也没有细讲，可以参考下述的资料：</p></blockquote><ul><li><p><a href="https://developer.samsung.com/galaxy-gamedev/resources/articles/renderpasses.html">https://developer.samsung.com/galaxy-gamedev/resources/articles/renderpasses.html</a></p></li><li><p><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes#page_Render-pass">https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes#page_Render-pass</a></p></li><li><p><a href="https://vkguide.dev/docs/chapter-1/vulkan_renderpass/">https://vkguide.dev/docs/chapter-1/vulkan_renderpass/</a></p></li></ul><p>一个比较清晰的描述如下：</p><blockquote><p>A VkRenderPass is a Vulkan object that encapsulates the state needed to setup the “target” for rendering, and the state of the images you will be rendering to.</p></blockquote><blockquote><p>The renderpass is a concept that only exists in Vulkan. It’s there because it allows the driver to know more about the state of the images you render.</p></blockquote></li><li><p><code>Pipeline</code></p><p>通过pipeline object指定各种状态信息。</p></li><li><p><code>descriptor</code></p><p>将内存资源与shaders建立联系，以便后续的数据的读写。</p></li><li><p><code>Bind resource</code></p><p>指定各种需要的数据，比如vertex buffer、images等，这些在执行任务时都要用到。</p></li><li><p><code>Viewport</code></p><p>确定了要进行rendering的surface，可以查看上面WSI部分那个图。</p></li><li><p><code>Scissor</code></p><p>定义了一个矩形区域，超过这个区域的内容不会被渲染。</p></li><li><p><code>Draw</code></p><p>具体的draw command，需要指定geometry buffer相关的属性信息，完成任务。</p></li></ul><h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><p>创建command buffer是一个expensive task，因此，Vulkan支持使用多线程的方式来创建command buffer，而且为了不因并发产生资源竞争，采用了command buffer pool的方式，如下：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84programming-model/9.png" alt="多线程使用command buffer pool"></p><p>每个单独的线程对应一个command buffer pool，既可以重用command buffer，又不担心资源竞争。</p><h2 id="Queue-Submission"><a href="#Queue-Submission" class="headerlink" title="Queue Submission"></a>Queue Submission</h2><p>当上述的command buffer构建成功后，就被提交到queue中进行处理。vulkan中有不同类型的queue，根据job的不同属性，可以选择不同类型的queue。</p><ul><li>对于compute任务，需要提交到compute queue；</li><li>对于graphics任务，需要提交到graphics queue；</li></ul><p>这些提交的job以异步的方式执行，如果希望进行同步，需要application显式管理。</p><p>具体来说，这一阶段完成了：</p><ul><li>从sawpchain中获取下一个需要被draw的frame；</li><li>application设置各种同步机制，以便协调不同commands；</li><li>将收集的command记录到command buffer中，并提交到特定的queue中；</li><li>请求将绘制完成的images展现到output device中；</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules</a></li><li><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface">https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface</a></li><li>Learning Vulkan - Chapter 1 - Understanding the Vulkan application &amp; Getting started with the Vulkan programming model</li><li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap4.html">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap4.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
            <tag> pipeline </tag>
            
            <tag> driver </tag>
            
            <tag> loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存管理：使用allocator管理dynamic array</title>
      <link href="/2022/11/27/bian-cheng-zhi-dao/c-nei-cun-guan-li-shi-yong-allocator-guan-li-dynamic-array/"/>
      <url>/2022/11/27/bian-cheng-zhi-dao/c-nei-cun-guan-li-shi-yong-allocator-guan-li-dynamic-array/</url>
      
        <content type="html"><![CDATA[<h1 id="动态内存申请中的问题"><a href="#动态内存申请中的问题" class="headerlink" title="动态内存申请中的问题"></a>动态内存申请中的问题</h1><p>在之前的动态内存分配中，不管是单个对象还是dynamic array，都存在一个耦合的行为：</p><ul><li>new将memory allocation与object construction结合到一起；</li><li>delete将deallocation与destruction结合到一起；</li></ul><p>对于单个对象问题不大，但是对于一块大内存，则会存在一个问题，申请一块内存空间后，如果要初始化，则需要对这块内存执行写操作，对内存空间的大量写操作，根据<a href="https://lifehit.cn/2022/10/16/ji-suan-ji-ji-chu/ji-suan-ji-de-cun-chu-qi-ceng-ci-jie-gou/">计算机存储层次结构</a>，会浪费大量的时间，使得性能下降。此外，当分配内存时进行初始化时，在后续的操作中可能会覆盖初始化的数据，导致初始化时的写操作完全无意义。</p><p>基于这种情况，我们希望将内存的分配与初始化解耦，当需要的时候再将数据写入到内存中。这样可以避免无意义的写操作，尤其是面对大量的内存空间时。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><pre class=" language-cpp"><code class="language-cpp">string <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span></code></pre><p>上述代码中，申请了100个string对应的内存空间，但是程序中只使用了5个且还都是写操作，则在初始化中的写操作均为无意义的。</p><h1 id="allocator将内存分配与初始化分开"><a href="#allocator将内存分配与初始化分开" class="headerlink" title="allocator将内存分配与初始化分开"></a>allocator将内存分配与初始化分开</h1><p>定义在<memory>中的allocater类将内存分配与初始化分开。</p><blockquote><p>It provides type-aware allocation of raw, uncon-structed, memory.</p></blockquote><p>简单讲，哥们可以只先申请内存空间，并不执行写操作。其支持如下的操作：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BD%BF%E7%94%A8allocator%E7%AE%A1%E7%90%86dynamic-array/1.png" alt="allocator支持的操作"></p><h2 id="内存分配的操作"><a href="#内存分配的操作" class="headerlink" title="内存分配的操作"></a>内存分配的操作</h2><p>由于allocater类也是模版类，因此需要指定类型</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明一个allocar实例，用于为string数据分配内存</span>allocator<span class="token operator">&lt;</span>string<span class="token operator">></span> alloc<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 分配10个string对象，返回指向第一个元素的指针</span><span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>为了验证分配内存期间是否有初始化操作，可以使用如下代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> m_a<span class="token punctuation">;</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call default constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> m_a <span class="token operator">&lt;&lt;</span> <span class="token string">": call constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> m_a <span class="token operator">&lt;&lt;</span> <span class="token string">": call destructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    allocator<span class="token operator">&lt;</span>Foo<span class="token operator">></span> alloc<span class="token punctuation">;</span>    <span class="token keyword">auto</span> p <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>没有任何输出，说明此时没有调用构造函数。</p><h2 id="构造对象"><a href="#构造对象" class="headerlink" title="构造对象"></a>构造对象</h2><p>对于完成内存分配的空间，可以进行初始化，这里使用<code>construct</code>函数，其第一个参数为执行<code>allocate</code>完得到的内存空间的指针：</p><ul><li>默认情况下使用无参构造函数；</li><li>如果有参数，则会选择匹配的构造函数完成初始化；</li></ul><p>这里要注意的是，一次<code>construct</code>函数的调用只完成了一个指针对应内存的初始化，例如如果申请了10个string类型的内存空间，需要调用10次allocator。</p><pre class=" language-cpp"><code class="language-cpp">alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p <span class="token operator">-</span><span class="token operator">></span> m_a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> m_a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**call default constructor1: call constructor2: call constructor20*/</span></code></pre><p>根据代码输出可以知道，对于同一个分配的内存区域，可以重复调用<code>cosntruct</code>多次，且以最后一次为准。如代码中，针对指针p对应的内存，初始化了3次，最后一次成员变量赋值为2，也就是输出的结果。</p><p>如果要对每个指针对应的内存都要初始化，则使用如下代码：</p><pre class=" language-cpp"><code class="language-cpp">alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>p<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p <span class="token operator">-</span><span class="token operator">></span> m_a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> m_a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**1: call constructor2: call constructor21*/</span></code></pre><blockquote><p>We must construct objects in order to use memory returned by allocate. Using unconstructed memory in other ways is undeﬁned.</p></blockquote><h2 id="销毁对象"><a href="#销毁对象" class="headerlink" title="销毁对象"></a>销毁对象</h2><p>销毁对象对应着调用析构函数，这里使用<code>destroy</code>函数完成，其参数为<code>allocate</code>返回的指向申请内存的指针。销毁对象代码如下：</p><pre class=" language-cpp"><code class="language-cpp">allocator<span class="token operator">&lt;</span>Foo<span class="token operator">></span> alloc<span class="token punctuation">;</span><span class="token keyword">auto</span> p <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// q &amp; p as pointers to the first element</span><span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>p<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>p<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**1: call constructor2: call constructor2: call destructor1: call destructor*/</span></code></pre><p>但销毁对象后，对应的内存空间又变成了未初始化的状态，可以进行重用，进行初始化，也可以释放这块申请的内容。重用时是将这个申请的内存变成了一个memory pool，即所谓的allocation和suballocation，可以提高效率。</p><h2 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h2><p>当不想使用时，可以释放申请的内存，使用<code>deallocate</code>函数。但是使用时需要注意几点：</p><ul><li>第一个参数是<code>allocate</code>函数返回的指针，必须指向第一个元素；</li><li>第二个是分配的元素的个数，与<code>allocate</code>保持一致；</li></ul><pre class=" language-cpp"><code class="language-cpp">alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当指针使用不对时，会出现未被allocate的内存被释放的错误，如下：</p><pre class=" language-cpp"><code class="language-cpp">allocator<span class="token operator">&lt;</span>Foo<span class="token operator">></span> alloc<span class="token punctuation">;</span><span class="token keyword">auto</span> p <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>p<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>p<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token operator">++</span>q<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BD%BF%E7%94%A8allocator%E7%AE%A1%E7%90%86dynamic-array/2.png" alt="dealloate指针指定错误"></p><h1 id="一些支持函数"><a href="#一些支持函数" class="headerlink" title="一些支持函数"></a>一些支持函数</h1><p>在初始化时，对于多个内存空间，需要对调用多次construct，一些方便函数支持快速对allocator分配的内存进行初始化，如下。</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BD%BF%E7%94%A8allocator%E7%AE%A1%E7%90%86dynamic-array/3.png" alt="一些支持函数"></p><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vi <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">}</span><span class="token punctuation">;</span>allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> alloc<span class="token punctuation">;</span><span class="token keyword">auto</span> p <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>vi<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// construct elements starting at p as copies of elements in vi </span><span class="token comment" spellcheck="true">// return pointer to next uninitialized element</span><span class="token keyword">auto</span> q <span class="token operator">=</span> <span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// initialize the remaining elements to 42 from q</span><span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vi<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**12344242*/</span></code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Primer - 12.2.2 The allocator Class</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic array </tag>
            
            <tag> allocator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存管理：使用new和智能指针操作dynamic array</title>
      <link href="/2022/11/25/bian-cheng-zhi-dao/c-nei-cun-guan-li-shi-yong-new-he-zhi-neng-zhi-zhen-cao-zuo-dynamic-array/"/>
      <url>/2022/11/25/bian-cheng-zhi-dao/c-nei-cun-guan-li-shi-yong-new-he-zhi-neng-zhi-zhen-cao-zuo-dynamic-array/</url>
      
        <content type="html"><![CDATA[<p>在之前的动态内存管理中，涉及的多为单一对象，但是在应用中也有这样的需求，在一次内存申请中需要一个连续的内存空间，为了满足这种需求，有两种解决方法：</p><ul><li><p>使用各种类型的container</p><p>  根据不同的需求，可以使用vector，其将变量名称保存在stack中，而数据存储在heap，与dynamic array申请的内存在同一个区域。</p><blockquote><p>Most applications should use a library container rather than dynamically allocated arrays. Using a container is easier, less likely to contain memorymanagement bugs, and is likely to give better performance.</p></blockquote><p>  而且在C++ Primer中也建议大家多使用这种container。</p></li><li><p>使用dynamic array来动态的分配一块内存空间；</p></li></ul><p>即便container是一个更好的选择，但是dynamic array也是一种解决方案。关于dynamic array的使用和管理，有两种途径：</p><ul><li><p>直接使用指针类型</p><p>  与分配单个对象的使用类似，包括：</p><ul><li>通过 <code>new/delete</code> 实现；</li><li>通过smart poiners实现；</li></ul><p>  这是本篇文章的主要内容。</p></li><li><p>使用封装类<code>allocator</code></p><p>  这种方法相比于上述方法，性能更好，也更灵活。</p></li></ul><h1 id="使用new-delete管理dynamic-array"><a href="#使用new-delete管理dynamic-array" class="headerlink" title="使用new/delete管理dynamic array"></a>使用new/delete管理dynamic array</h1><h2 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><p>使用<code>new</code>声明，申请10个int数据对应的内存空间，并将指向第一个int的指针返回给pa1，但是这里没有初始化。</p><p>不同于普通数据的声明限制，其<a href="https://lifehit.cn/2022/10/07/bian-cheng-zhi-dao/c-shu-zu-de-shi-yong-yi-ji-xiang-guan-nei-rong/">要求数组的dimension在编译时已知</a>，dynamic array没有这个要求，因为就是在运行时才会动态申请内存，因此使用<code>get_size()</code>也是可以指定申请的内存的空间的，也不需要是constants。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call foo constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1. declaration</span><span class="token keyword">int</span> <span class="token operator">*</span>pa1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2. ok, use get_size() to indicate the dimension of pa2.</span><span class="token keyword">int</span> <span class="token operator">*</span>pa2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 3. call foo constructor three times.</span>Foo <span class="token operator">*</span>pa3 <span class="token operator">=</span> <span class="token keyword">new</span> Foo<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** outputcall foo constructorcall foo constructorcall foo constructor*/</span></code></pre><p>但是定义类型别名时，编译器也会使用<code>new[]</code>来申请内存，如下所示，分别使用了<code>typedef</code>和<code>using</code>定义<code>Foo</code>数组类型，之后通过这些类型别名来申请内存。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        count <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">" : call foo constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> Foo arrT1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> arrT2 <span class="token operator">=</span> Foo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    Foo <span class="token operator">*</span>ap1 <span class="token operator">=</span> <span class="token keyword">new</span> arrT1<span class="token punctuation">;</span>    Foo <span class="token operator">*</span>ap2 <span class="token operator">=</span> <span class="token keyword">new</span> arrT2<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>ap1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>ap2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**1 : call foo constructor2 : call foo constructor3 : call foo constructor4 : call foo constructorP3FooP3Foo*/</span></code></pre><p>另外，对于dynamic array的初始化而言，如果是上述的方式时，则为<a href="https://en.cppreference.com/w/cpp/language/default_initialization">default initialization</a>，<a href="https://lifehit.cn/2022/11/16/bian-cheng-zhi-dao/c-nei-cun-guan-li-ji-ben-zhi-shi-yu-new-delete-de-shi-yong/">如同单个对象的方式一样</a>。</p><ul><li>对于基础类型，则是未定义的值；</li><li>对于类类型，则调用默认构造函数；</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// the value of p is undefined and can be any value.</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><p>可以通过value initialize的方式完成初始化，这样可以避免不确定的行为。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// all elements are initialized into 0.</span><span class="token keyword">int</span> <span class="token operator">*</span>pa1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// all elements are initialized into empty string.</span>string <span class="token operator">*</span>pa2 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但是要注意一点，我们不能在<code>()</code>中放入初始化数据，这种会导致错误如下。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>pa1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**error: parenthesized initializer in array new*/</span></code></pre><p>新标准下可以使用list initialization。</p><ul><li><p>当list中的元素比dimension少时，剩余的使用value initialization；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>pa1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>pa1<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**output: 0*/</span></code></pre></li><li><p>当超出dimension时，则申请内存失败，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**error: excess elements in array initializer*/</span></code></pre></li></ul><h2 id="new的注意事项"><a href="#new的注意事项" class="headerlink" title="new的注意事项"></a>new的注意事项</h2><h3 id="不是数组类型"><a href="#不是数组类型" class="headerlink" title="不是数组类型"></a>不是数组类型</h3><p>对于通过new得到的dynamic array而言，准确的说不是数组类型，得到的返回值是指向第一个元素的指针。一个显著的特性就是，不能对这种dynamic array使用<code>begin</code>和<code>end</code>，因为这两个函数需要使用数组的dimension来定位对应的指针位置。但是可以使用下标来访问对应的数组元素。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ok</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// p[1] is ok</span>    <span class="token comment" spellcheck="true">// cout &lt;&lt; p[1] &lt;&lt; endl;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// compile error, error: no matching function for call to 'begin'</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><p>基于同样的原因，也不能使用range-for语句，因为无dimension信息。但是如下的遍历方法是可行的：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>s <span class="token operator">=</span> pa<span class="token punctuation">;</span> s <span class="token operator">!=</span> pa <span class="token operator">+</span> d<span class="token punctuation">;</span> s<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**output:234512*/</span></code></pre><h3 id="允许申请0空间的内存"><a href="#允许申请0空间的内存" class="headerlink" title="允许申请0空间的内存"></a>允许申请0空间的内存</h3><p>诡异的是，<strong>new允许申请dimension为0的内存空间</strong>，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**0x7ffee7a293982594365810x7fb0d55058d00*/</span></code></pre><p>从上述的输出中发现，即便是申请0空间的dynamic array，也是会成功的，也会返回对应的指针， 这种指针是<code>off-the-end pointer</code>，即指向每个数组最后一个元素之后的元素的地址。但是<strong>上述通过指针找到对应的元素的做法都是非常尾危险的，因为得到的数据是不确定的</strong>。</p><blockquote><p>C++ Primer中说不允许定义dimension为0的普通数组，但是尝试后发现是可以的，在clang 12编译器和c++11标准下。</p></blockquote><h2 id="delete的注意事项"><a href="#delete的注意事项" class="headerlink" title="delete的注意事项"></a>delete的注意事项</h2><p>在释放<code>new</code>申请的dynamic array时，与释放单个对象类似，但是仍有一定的区别。</p><h3 id="释放顺序"><a href="#释放顺序" class="headerlink" title="释放顺序"></a>释放顺序</h3><p><code>delete</code>释放内存的顺序与初始化的顺序完全相反，即首先释放内存中的最后一个对象，接着向前直到第一个。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> m_a<span class="token punctuation">;</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> m_a <span class="token operator">&lt;&lt;</span> <span class="token string">": call constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> m_a <span class="token operator">&lt;&lt;</span> <span class="token string">": call destructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Foo <span class="token operator">*</span>foo <span class="token operator">=</span> <span class="token keyword">new</span> Foo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> foo<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** output1: call constructor2: call constructor2: call destructor1: call destructor*/</span></code></pre><p>在上述代码中，发现Foo的构造函数和析构函数均被调用多次，与dynamic array的dimension相同。</p><h3 id="必须使用"><a href="#必须使用" class="headerlink" title="必须使用[]"></a>必须使用[]</h3><p>在释放dynamic array对应的内存时，必须使用[]，否则行为未可知。</p><blockquote><p>If we omit the brackets when we delete a pointer to an array (or provide them when we delete a pointer to an object), the behavior is undeﬁned.</p></blockquote><p>即便使用类型别名时，也需要指定<code>[]</code>，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span> arrT<span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> arrT<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span><span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error</span><span class="token comment" spellcheck="true">//delete p</span></code></pre><h1 id="使用smart-pointers管理dynamic-array"><a href="#使用smart-pointers管理dynamic-array" class="headerlink" title="使用smart pointers管理dynamic array"></a>使用smart pointers管理dynamic array</h1><h2 id="unique-ptr申请dynamic-array"><a href="#unique-ptr申请dynamic-array" class="headerlink" title="unique_ptr申请dynamic array"></a>unique_ptr申请dynamic array</h2><ul><li><p>在<code>unique_ptr</code>申请连续的内存空间时，采用<code>new</code>完成申请。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unique_ptr<span class="token operator">&lt;</span>Foo<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> Foo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** output1: call constructor2: call constructor2: call destructor1: call destructor*/</span></code></pre><p>  这里的写法是，要保证 <code>new Foo[2]&#123;Foo(1), Foo(2)&#125;</code> 是一个<code>Foo*</code>类型。</p></li><li><p><strong>在unique_ptr中还重载了[]，可以直接访问其中的元素</strong>，如下：</p><pre class=" language-cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> up<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>m_a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**output: 2*/</span></code></pre><p>  支持的函数如下图所示：</p><p>  <img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BD%BF%E7%94%A8new%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9Cdynamic-array/1.png" alt="unique_ptr支持dynamic array的操作"></p></li></ul><ul><li><p>还有另外一种写法，是通过<a href="https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique">make_unique</a>实现的，这是在<code>C++14</code>才引入的函数，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> m_a<span class="token punctuation">;</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call default constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> m_a <span class="token operator">&lt;&lt;</span> <span class="token string">": call constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> m_a <span class="token operator">&lt;&lt;</span> <span class="token string">": call destructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unique_ptr<span class="token operator">&lt;</span>Foo<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> up <span class="token operator">=</span> make_unique<span class="token operator">&lt;</span>Foo<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**call default constructorcall default constructor0: call destructor0: call destructor*/</span></code></pre><p>  在上述代码中，使用<code>make_unique</code>时，需要指定数组的dimension，且必须在类中指定默认构造函数，无法指定特定的构造函数。</p></li></ul><h2 id="shared-ptr申请dynamic-array"><a href="#shared-ptr申请dynamic-array" class="headerlink" title="shared_ptr申请dynamic array"></a>shared_ptr申请dynamic array</h2><p>在<code>shared_ptr</code>中申请dynamic array比<code>unique_ptr</code>还要麻烦。</p><ul><li><p>在<code>shared_ptr</code>中不支持自动释放dynamic array的内存资源，因此需要显式给出deleter，通过<code>delete[]</code>。如下：</p><pre class=" language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> Foo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Foo <span class="token operator">*</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> foo<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** output1: call constructor2: call constructor2: call destructor1: call destructor*/</span></code></pre><p>  注意，这里还有跟<code>unique_ptr</code>不同的地方在于模版类型中不用<code>Foo[]</code>，直接用<code>Foo</code>就行。上述这种写法在<code>C++11</code>中就支持了。</p><p>  这里还产生一个疑问，如果我不指定自定义的deleter，会发生啥？</p><pre class=" language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> Foo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> sp <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> </code></pre><p>  编译不会出错，运行出现如下错误：</p><p>  <img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BD%BF%E7%94%A8new%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9Cdynamic-array/2.png" alt="shared_ptr中不提供自定义的deleter时出错"></p><p>  从运行结果来看，Foo(2)的析构函数没有被执行，因此大胆猜测，如果我们不提供自定义的deleter，默认情况下使用的是<code>deleter sp</code>，也就是将第一个元素释放了。</p></li><li><p><code>c++11</code>中的<code>shared_ptr</code>不支持使用<code>[]</code>访问元素，如下：</p><pre class=" language-cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> sp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>m_a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error: type 'shared_ptr&lt;Foo>' does not provide a subscript operator</span></code></pre></li></ul><p>同样的，<code>shared_ptr</code>中也支持使用<code>make_shared</code>申请dynamic array，如下，但是其中涉及的内容较多，超出了本篇的内容，可以查看参考资料2阅读。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于dynamic array的使用频率不算多，而且在C++ Primer中也建议多用<code>vector</code>等container，但是对于需要独占控制权等场景，<code>unique_ptr</code>等还是有其用途的，对比之下<code>vector</code>等需要进行拷贝。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Primer - 12.2.1 new and Arrays</li><li><a href="https://www.cppstories.com/2021/smartptr-array/">https://www.cppstories.com/2021/smartptr-array/</a></li><li><a href="https://www.nextptr.com/question/qa1348405750/dynamic-array-with-stdunique_ptr">https://www.nextptr.com/question/qa1348405750/dynamic-array-with-stdunique_ptr</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shared_ptr </tag>
            
            <tag> unique_ptr </tag>
            
            <tag> new </tag>
            
            <tag> delete </tag>
            
            <tag> dynamic array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存管理：智能指针、异常与自定义deleter的关系</title>
      <link href="/2022/11/24/bian-cheng-zhi-dao/c-nei-cun-guan-li-zhi-neng-zhi-zhen-yi-chang-yu-zi-ding-yi-deleter-de-guan-xi/"/>
      <url>/2022/11/24/bian-cheng-zhi-dao/c-nei-cun-guan-li-zhi-neng-zhi-zhen-yi-chang-yu-zi-ding-yi-deleter-de-guan-xi/</url>
      
        <content type="html"><![CDATA[<p>对于内存的管理，在C++中是一个重要的主题，而C++中异常的出现又带来了新的困惑，异常发生时，会对内存的管理有何影响？</p><p>本节从3个方面阐述：</p><ul><li>对于传统显式管理方法new/delete的影响；</li><li>对于智能指针的影响；</li><li>泛化思考：如果对于资源（不仅是内存），忘记处理了怎么办？</li></ul><h1 id="异常对于new-delete的影响"><a href="#异常对于new-delete的影响" class="headerlink" title="异常对于new/delete的影响"></a>异常对于new/delete的影响</h1><p>先说结论，对于采用这种方式管理的内存，极有出现内存泄露的问题。简单来讲，</p><ul><li>在一个block scope中，例如函数，如果delete调用之前，异常没有捕获，则会出现内存泄露；</li><li>如果在delete之前捕获了，就不会出现内存泄露；</li></ul><p>如下例所示：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call Foo constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call Foo destructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Foo <span class="token operator">*</span>foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"invalid_argument"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> logic_error <span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">delete</span> foo<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**outputcall Foo constructorinvalid_argumentcall Foo destructor*/</span></code></pre><p>说明此时，当异常捕获后，析构函数被调用成功，因此资源被释放了。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Foo <span class="token operator">*</span>foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"invalid_argument"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> foo<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**call Foo constructorlibc++abi.dylib: terminating with uncaught exception of type std::invalid_argument: invalid_argument*/</span></code></pre><p>当异常直接被抛出，没有捕获时，就会发现析构函数没有调用成功，因此出现了内存泄露。</p><h1 id="异常对于smart-pointers的影响"><a href="#异常对于smart-pointers的影响" class="headerlink" title="异常对于smart pointers的影响"></a>异常对于smart pointers的影响</h1><p>对于smart pointers来说，不需要手动释放内存资源，而是交给其隐式管理，能够保证资源及时被释放，即便因各种问题，导致函数提前结束（如出现异常）。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call Foo constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call Foo destructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"invalid_argument"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span>    <span class="token punctuation">{</span>        <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> logic_error <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** outputcall Foo constructorcall Foo destructorinvalid_argument*/</span></code></pre><p>说明即便test函数中的异常没有捕获，shared_ptr指向的内存空间也被释放了，因为成功调用了析构函数。</p><p>更不用说，在函数test中成功捕获到异常时，也会成功调用析构函数。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span>    <span class="token punctuation">{</span>        <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"invalid_argument"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> logic_error <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** outputcall Foo constructorinvalid_argumentcall Foo destructor*/</span></code></pre><p>这里有个注意事项，当main函数中的异常没有被捕获时，会出现程序直接终止，此时内存泄露问题也就无意义了，因为整个进程都被销毁了。但是在此时不管是new/delete管理的，还是smart pointers管理的，都不会调用析构函数，因为在异常抛出的那个时间点，程序就结束了。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"invalid_argument"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** outputcall Foo constructorlibc++abi.dylib: terminating with uncaught exception of type std::invalid_argument: invalid_argument*/</span></code></pre><h1 id="General：如何避免忘记释放资源"><a href="#General：如何避免忘记释放资源" class="headerlink" title="General：如何避免忘记释放资源"></a>General：如何避免忘记释放资源</h1><p>从上述的例子中可以发现：</p><ul><li><p>new/delete的操作方法，如果忘记delete，或者因为导致无法delete时，就会有泄漏；</p></li><li><p>相比指向，smart pointers利用了超出block scope后，局部变量自动销毁的特点，可以实现自动地释放资源。这种idea也可以应用到其他形式资源的管理上。</p></li></ul><p>shared_ptr隐式进行内存资源的管理，在其内部也是通过delete完成内存的释放的，当reference count变成0之后，shared_ptr被销毁，其指向的内存也被销毁，此时默认情况下，通过delete完成。</p><p>如果说对于内存资源，可以通过delete完成，但是对于其他资源，也需要进行释放，比如：文件操作符、网络socket、数据库连接等等，但是这是就不能使用shared_ptr中默认的delete了，因为不同的资源提供的接口不同，比如文件操作符是close等等。</p><p>为了实现这种技术，一般有两条路：</p><ul><li><p>定义一个良好的析构函数，当smart pointers被销毁后，自动调用该析构函数；</p></li><li><p>如果一个外部类中，没有定义良好的析构函数，可以在使用smart pointers时，传入一个deleter函数。</p></li></ul><p>这里，析构函数我们足够熟悉，因此主要阐述deleter的使用方法。</p><h2 id="shared-ptr中定义deleter"><a href="#shared-ptr中定义deleter" class="headerlink" title="shared_ptr中定义deleter"></a>shared_ptr中定义deleter</h2><p>在shared_ptr中自定义deleter，有几种实现方式：</p><ol><li>定义一个deleter函数；</li><li>定义一个函数类，通过重载操作符实现；</li><li>通过lambda表达式实现；</li></ol><p>首先定义一个类如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> m_a<span class="token punctuation">;</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call destructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="定义一个deleter函数"><a href="#定义一个deleter函数" class="headerlink" title="定义一个deleter函数"></a>定义一个deleter函数</h3><p>在下边的代码中，我们定义了两个deleter，第一个与shared_ptr默认执行的deleter的操作行为是一致的。另外，C++也提供了一个函数来完成默认的操作<a href="https://en.cppreference.com/w/cpp/memory/default_delete">default_delete</a>。</p><p>第二个则是自定义的deleter，作为一个额外的函数，其参数为传入shared_ptr的通过new得到的指针对应的类型。从下面的代码中，可以发现代码的执行顺序为：</p><ul><li>首先，构造函数先被执行；</li><li>之后是自定义的deleter被执行；</li><li>最后是foo的析构函数被执行，说明<strong>即便有自定义的deleter，析构函数仍然会被执行</strong>；</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">default_deleter</span><span class="token punctuation">(</span>Foo <span class="token operator">*</span>foo<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">delete</span> foo<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">custom_deleter</span><span class="token punctuation">(</span>Foo <span class="token operator">*</span>foo<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call custom deleter"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span> foo<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// close file</span>    <span class="token comment" spellcheck="true">// close connection</span>    <span class="token comment" spellcheck="true">// close socket</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// the three deleters do the same things by default.</span>    shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>default_delete<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> default_deleter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// define customized deleter</span>    <span class="token comment" spellcheck="true">// shared_ptr&lt;Foo> foo(new Foo(a), custom_deleter);</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** for custom_deleter, the output:call constructorcall custom deletercall destructor*/</span></code></pre><h3 id="定义函数对象类"><a href="#定义函数对象类" class="headerlink" title="定义函数对象类"></a>定义函数对象类</h3><ul><li><p>一个类将()重载为成员函数，这个类就称为<strong>函数对象类</strong>，该类的对象就是函数对象。</p></li><li><p>函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用。</p></li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">FuncObject</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Foo <span class="token operator">*</span>foo<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call func object"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span> foo<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// main</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FuncObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** outputcall constructorcall func objectcall destructor*/</span></code></pre><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda表达式类似函数类，作为一个匿名函数，可以直接传入到shared_ptr的构造函数中，作为自定义的deleter。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Foo <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call lambda expression"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span> f<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** outputcall constructorcall lambda expressioncall destructor*/</span></code></pre><h2 id="unique-ptr中定义deleter"><a href="#unique-ptr中定义deleter" class="headerlink" title="unique_ptr中定义deleter"></a>unique_ptr中定义deleter</h2><p>在unique_ptr中自定义deleter有点繁琐，不同于shared_ptr，需要指定deleter的类型。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// p points to an object of type objT and uses an object of type delT to free that object</span><span class="token comment" spellcheck="true">// it will call an object named fcn of type delT</span>unique_ptr<span class="token operator">&lt;</span>objT<span class="token punctuation">,</span> delT<span class="token operator">></span> <span class="token function">p</span> <span class="token punctuation">(</span><span class="token keyword">new</span> objT<span class="token punctuation">,</span> fcn<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中，fcn是delT类型的实例，即可以是普通类的对象，也可以是函数指针指向的一个函数。</p><p>那么如何自定义deleter呢？有几种方法，这里主要介绍3种：</p><ol><li>自定义函数，并声明函数类型；</li><li>定义函数类；</li><li>通过function函数；</li></ol><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>在这里，用到了<a href="https://lifehit.cn/2022/10/12/bian-cheng-zhi-dao/c-han-shu-zhi-zhen/">函数指针</a>的概念。对于unique_ptr初始化时，提供了自定义的deleter函数custom_deleter，其对应的类型为<code>void (*)(Foo)</code>。这里使用了decltype进行类型推导，注意：不要忘记后面那个<code>*</code>，因为decltype(custom_deleter)返回的是函数类型，这里必须要用函数指针类型，才能与后面的custom_deleter对应，因此要加<code>*</code>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">custom_deleter</span><span class="token punctuation">(</span>Foo <span class="token operator">*</span>foo<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call custom deleter"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span> foo<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>custom_deleter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>custom_deleter<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span>Foo<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>custom_deleter<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> custom_deleter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** outputFv3FooEPFv3FooEFvP3FooEPFvP3FooEcall constructorcall custom deletercall destructor*/</span></code></pre><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>这里使用函数对象定义deleter，其类型为<code>FuncObject</code>，对应的对象为<code>FuncObject()</code>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">FuncObject</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Foo <span class="token operator">*</span>foo<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call func object"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span> foo<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span>Foo<span class="token punctuation">,</span> FuncObject<span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FuncObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**call constructorcall func objectcall destructor*/</span></code></pre><h3 id="lambda表达式-1"><a href="#lambda表达式-1" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>使用lambda表达式的方式，与在shared_ptr中的方式类似，更为简洁。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">auto</span> custom_deleter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Foo <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call lambda expression"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span> f<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>unique_ptr<span class="token operator">&lt;</span>Foo<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>custom_deleter<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> custom_deleter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** outputcall constructorcall lambda expressioncall destructor*/</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述介绍了各种自定义deleter的方式，主要是为了回答这样一个问题——如果忘记释放资源了怎么办，不管是内存、网络连接、数据库连接还是文件描述符，最好的办法就是创建时就想好退路，即便最后忘记了，也提前制定了计划。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Primer 12.1.4 - Smart pointers and Exceptions</li><li>C++ Primer 12.1.5 - unique_ptr</li><li><a href="https://thispointer.com/shared_ptr-and-custom-deletor/">https://thispointer.com/shared_ptr-and-custom-deletor/</a></li><li><a href="https://zhuanlan.zhihu.com/p/367412477">https://zhuanlan.zhihu.com/p/367412477</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shared_ptr </tag>
            
            <tag> unique_ptr </tag>
            
            <tag> new </tag>
            
            <tag> delete </tag>
            
            <tag> exception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存管理：shared_ptr</title>
      <link href="/2022/11/20/bian-cheng-zhi-dao/c-nei-cun-guan-li-shared-ptr/"/>
      <url>/2022/11/20/bian-cheng-zhi-dao/c-nei-cun-guan-li-shared-ptr/</url>
      
        <content type="html"><![CDATA[<p>智能指针<code>shared_ptr</code>，与<code>unique_ptr</code>和<code>weak_ptr</code>不同：</p><ul><li>不像<code>unique_ptr</code>那么独断专制；</li><li>也不像<code>weak_ptr</code>那么不负责任；</li></ul><p>而是可以同时多个<code>shared_ptr</code>指向同一块内存地址，这种特性使得可以使用<code>shared_ptr</code>进行数据的共享。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul><li><p>当未显式初始化时，默认情况下使用nullptr进行初始化。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// define a nullptr pointing to s string, default initialization</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// nullptr</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre></li><li><p>可以对<code>shared_ptr</code>进行赋值操作，类似于普通的指针类型。</p><pre class=" language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// assignment</span><span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token string">"hi"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// use * access the object pointer points to</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**hello, worldhi*/</span></code></pre></li><li><p>可以使用<code>make_shared</code>进行初始化，是推荐使用方式，安全且不易出错；</p><blockquote><p>This function allocates and initializes an object in dynamic memory and returns a shared_ptr that points to that object.</p></blockquote><pre class=" language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p3 <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> p4 <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// use auto for simplification</span><span class="token keyword">auto</span> p6 <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>在<code>make_shared</code>中，使用该指针所指向类型的构造函数来初始化。</li><li>无参的情况下，则为value initialization</li></ul></li><li><p>与new结合使用</p><p>  类似于<code>unique_ptr</code>，<code>shared_ptr</code>也可以使用<code>new</code>来支持初始化。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// error, 类型转换不支持</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, direct initialization</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ul><p>一些初始化的方式总结如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Ashared_ptr/1.png" alt="一些shared_ptr初始化的方式"></p><h1 id="copy-amp-assign"><a href="#copy-amp-assign" class="headerlink" title="copy &amp; assign"></a>copy &amp; assign</h1><blockquote><p>When we copy or assign a <code>shared_ptr</code>, each <code>shared_ptr</code> keeps track of how many other shared_ptrs point to the same object.</p></blockquote><p>每个shared_ptr都有一个绑定的counter，即<strong>reference count</strong>，用来表示有多少个<code>shared_ptr</code>共享指向的对象。当shared_ptr的reference count变为0后，则会导致其指向的object被free，此时会调用该obejct的析构函数完成。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// int to which r points has one user </span><span class="token keyword">auto</span> r <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// assign to r, making it point to a different address</span><span class="token comment" spellcheck="true">// increase the use count for the object to which q points </span><span class="token comment" spellcheck="true">// reduce the use count of the object to which r had pointed </span><span class="token comment" spellcheck="true">// the object r had pointed to has no users; that object is automatically freed</span>r <span class="token operator">=</span> q<span class="token punctuation">;</span> </code></pre><p><strong>reference count</strong>的变化受到以下事件的影响：</p><ul><li><p>增加reference count；</p><ul><li>shared_ptr被copy；</li><li>用该shared_ptr初始化另一个shared_ptr；</li></ul><pre class=" language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> p3 <span class="token operator">=</span> p1<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**output:123*/</span></code></pre></li><li><p>减少reference count；</p><ul><li>shared_ptr被赋予新值；</li></ul><pre class=" language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**output: 不会崩溃10*/</span></code></pre><ul><li>该shared_ptr超出其定义的scope后，其被自动destroyed；</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token punctuation">{</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> p1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// p1 and p1 are destroyed, p is generated.</span>    <span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**output:121*/</span></code></pre></li></ul><h1 id="函数中使用"><a href="#函数中使用" class="headerlink" title="函数中使用"></a>函数中使用</h1><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>当作为函数返回值时，可以直接返回<code>shared_ptr</code>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// factory returns a shared_ptr pointing to a dynamically allocated object </span>shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">factory</span><span class="token punctuation">(</span>T arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// shared_ptr will take care of deleting this memory</span>    <span class="token keyword">return</span> make_shared<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>当作为函数返回值返回时，函数内部的指针会被destroyed，当外部的函数返回值没有“接盘侠”时，这块内存因为reference count变为0，就会被系统释放。</p><p>但是当返回值被赋值给新变量时，则这块内存的引用计数为1，就不会被释放，destroy的只有函数内部指向这块内存的<code>shared_ptr</code>。</p><h2 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h2><p>unique_ptr作为函数参数进行传递时，有一些限制，因为它不能copy和assign，所以只能按照引用传递参数，或者释放控制权，或者重新使用make_unique赋值，如<a href="https://lifehit.cn/2022/11/12/bian-cheng-zhi-dao/c-nei-cun-guan-li-zhi-neng-zhi-zhen-yu-unique-ptr/#toc-heading-9">C++内存管理：智能指针与unique_ptr</a>所述。</p><p>而<code>shared_ptr</code>可以记进行copy和assign，因此限制会少一些。</p><p>一些关于将智能指针作为参数传递的推荐使用方式如下：</p><ol><li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-smart">C++ Core Guidelines</a></li><li><a href="https://www.modernescpp.com/index.php/c-core-guidelines-passing-smart-pointer">C++ Core Guidelines: Passing Smart Pointers</a></li><li><a href="https://www.internalpointers.com/post/move-smart-pointers-and-out-functions-modern-c">Move smart pointers in and out functions in modern C++</a></li><li><a href="https://vladris.com/blog/2016/03/11/arguments-and-smart-pointers.html">Arguments and Smart Pointers</a></li></ol><h3 id="pass-by-value"><a href="#pass-by-value" class="headerlink" title="pass by value"></a>pass by value</h3><p>这种方式中，与普通的对象类似，当传入<code>shared_ptr</code>时，进行了copy，生成了一个新的智能指针，并且两个指针指向同一块内存，但是两个指针被存在不同的地址，且此时的reference count变成了2。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> sp<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>sp <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> sp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ok, this kind of form is accepted.</span>    <span class="token function">func</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>sp <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span>output<span class="token operator">:</span><span class="token number">0x7fffc9825e90</span>hello<span class="token punctuation">,</span> world<span class="token number">0x7fffc9825ea0</span><span class="token number">2</span><span class="token operator">/</span></code></pre><h3 id="pass-by-reference"><a href="#pass-by-reference" class="headerlink" title="pass by reference"></a>pass by reference</h3><p>此时，只需要将func函数的参数改为引用即可，得到的输出完全不一样了，引用计数并不会增加，且智能指针是同一个。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token operator">&amp;</span>sp<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>sp <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> sp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>sp <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**output:0x7ffe147b9db0hello, world0x7ffe147b9db01*/</span></code></pre><h1 id="shared-ptr的缺点"><a href="#shared-ptr的缺点" class="headerlink" title="shared_ptr的缺点"></a>shared_ptr的缺点</h1><blockquote><p>The program will execute correctly but may waste memory if you neglect to destroy shared_ptrs that the program does not need.</p></blockquote><p>当程序不能及时将最后一个shared_ptr销毁，则其指向的内存会一直存在，导致浪费。这种问题在容器中可能更容易忽略。</p><p>换句话说，因为shared_ptr及其对应内存的销毁，与reference count有紧密的关系，而且一般不建议显式操作，但是如果想要shared_ptr一直存在呢，可以将它们放到vector等容器中，但是对于容器中不需要的shared_ptr，也要及时erase掉，相关问题可以参考<a href="https://stackoverflow.com/questions/30470997/placing-smart-pointers-in-an-stl-container">这里</a>。</p><h1 id="一些使用技巧和注意事项"><a href="#一些使用技巧和注意事项" class="headerlink" title="一些使用技巧和注意事项"></a>一些使用技巧和注意事项</h1><h2 id="自己死亡不牵连别人"><a href="#自己死亡不牵连别人" class="headerlink" title="自己死亡不牵连别人"></a>自己死亡不牵连别人</h2><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>string<span class="token operator">></span> s1<span class="token punctuation">;</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> s2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    s1 <span class="token operator">=</span> s2<span class="token punctuation">;</span>    s1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"haha"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> si<span class="token operator">:</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> si <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> si<span class="token operator">:</span> s1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> si <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**output:helloworldhelloworldhaha*/</span></code></pre><p>当在block scope中对s1赋值时，当该scope结束后，s2就被回收了，但是不影响s1，因为s2中的元素已经被copy到s1中，两者没有任何关系，因此对其中任意一个修改，不会影响另一个。</p><p>当scope结束后，s2被回收，其中对应的元素也会被释放，对于vector来说，其指针存储在stack中，而对应的元素是动态分配在heap中的。此时s1中被赋值的元素仍然存在。</p><p>除了上述这种方式，s2的死亡不影响s1，但是s1和s2之间的元素是不能共享的，有时需要进行共享，这里可以使用<code>shared_ptr</code>实现。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">sharedObject</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">sharedObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token function">sharedObject</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> name<span class="token punctuation">,</span> shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> address<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_address</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> m_name<span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> m_address<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    sharedObject so1<span class="token punctuation">;</span>    <span class="token punctuation">{</span>        shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"john"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sharedObject <span class="token function">so2</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>        so1 <span class="token operator">=</span> so2<span class="token punctuation">;</span>        <span class="token operator">*</span>so2<span class="token punctuation">.</span>m_name <span class="token operator">=</span> <span class="token string">"Ram"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>so1<span class="token punctuation">.</span>m_name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>so1<span class="token punctuation">.</span>m_address <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**output:Ramsh*/</span></code></pre><p>其中，so1和so2共享其中的两个成员变量，这并没有通过类的静态成员实现，而且类的静态成员变量在所有对象之间共享，但是这种使用<code>shared_ptr</code>的方式可以指定进行共享的对象，在更细粒度上控制共享的范围。</p><h2 id="谨慎使用普通指针访问智能指针指向的内存"><a href="#谨慎使用普通指针访问智能指针指向的内存" class="headerlink" title="谨慎使用普通指针访问智能指针指向的内存"></a>谨慎使用普通指针访问智能指针指向的内存</h2><blockquote><p>It is dangerous to use a built-in pointer to access an object owned by a smart pointer, because we may not know when that object is destroyed.</p></blockquote><p>用智能指针得到的内存对象，就一直用智能指针来访问，因为这些不会因为scope的结束导致对象被destroyed，但是普通的指针会。看一个例子：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> sp<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> sp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**output:hello, world1*/</span></code></pre><p>当完成了func函数的调用，再使用*p1访问内存中的数据时已经不起作用了，此时p1成为<strong>dangling pointer</strong>，因为其指向的内存，在func中，当参数sp超过func的作用域后，连同智能指针sp都被销毁了，因为无法访问了。</p><h2 id="谨慎使用get"><a href="#谨慎使用get" class="headerlink" title="谨慎使用get"></a>谨慎使用get</h2><blockquote><p>Use get only to pass access to the pointer to code that you know will not delete the pointer. In particular, never use get to initialize or assign to another smart pointer.</p></blockquote><p>这个函数又将智能指针与普通指针混用了，因为get返回的是智能指针管理的普通指针，如果返回了该普通指针，就会脱离智能指针为其建立的一系列安全机制，比如自动删除内存等，会导致内存误删、重复删除等问题。</p><p>看如下代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    string <span class="token operator">*</span>p <span class="token operator">=</span> sp1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">sp2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行时出现了重复使用内存的问题，如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Ashared_ptr/2.png" alt="重复释放内存"></p><h2 id="写数据时要验证"><a href="#写数据时要验证" class="headerlink" title="写数据时要验证"></a>写数据时要验证</h2><p>因为<code>shared_ptr</code>指向的内存对象是在多个指针之间共享，因此当其中一个指针更改其中的值，会影响到其他指针的使用，为了避免这种情况，需要在写入新数据之前进行验证，判断自己是不是唯一的使用者。</p><pre class=" language-cpp"><code class="language-cpp">share_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// equal to sp.use_count() == 1.</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sp<span class="token punctuation">.</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">*</span>sp <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">" haha"</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span>output<span class="token operator">:</span>hello<span class="token punctuation">,</span> world haha<span class="token operator">*</span></code></pre><p>这里，当sp是唯一的使用者时，sp可以直接操作数据；但是如果有其他的使用者时，sp需要释放其原来的指向的对象，并重新申请一块内存，并将原来内存中的数据复制过来，然后将新生成的<code>shared_ptr</code>指向这块新内存，这就避免了对数据的负面影响。</p><h1 id="其他相关操作"><a href="#其他相关操作" class="headerlink" title="其他相关操作"></a>其他相关操作</h1><p>对于智能指针的操作，有些是共有的API，shared_ptr和unique_ptr都可以使用，如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Ashared_ptr/3.png" alt="共有的API"></p><p>还有一些是shared_ptr独有的API，如下所示：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Ashared_ptr/4.png" alt="独有的API"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Primer - 12.1.1 The shared_ptr class</li><li>C++ Primer - 12.1.3 Using shared_ptrs with new</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> smart pointers </tag>
            
            <tag> weak_ptr </tag>
            
            <tag> shared_ptr </tag>
            
            <tag> unique_ptr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存管理：基本知识与new-delete的使用</title>
      <link href="/2022/11/16/bian-cheng-zhi-dao/c-nei-cun-guan-li-ji-ben-zhi-shi-yu-new-delete-de-shi-yong/"/>
      <url>/2022/11/16/bian-cheng-zhi-dao/c-nei-cun-guan-li-ji-ben-zhi-shi-yu-new-delete-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Dynamic-Memory之前的问题"><a href="#Dynamic-Memory之前的问题" class="headerlink" title="Dynamic Memory之前的问题"></a>Dynamic Memory之前的问题</h1><p>在<a href="https://lifehit.cn/2022/11/09/bian-cheng-zhi-dao/c-de-bian-liang-ji-qi-chu-shi-hua/">这篇文章</a>中已经总结了C++中的变量和各种初始化方式，了解这些内容对于变量的内存使用是必要的。到目前为止，就scope和lifetime来说，有三种类型的变量：</p><ul><li><code>Global objects</code> are allocated at program start-up and destroyed when the program ends.</li><li><code>Local, automatic objects</code> are created and destroyed when the block in which they are deﬁned is entered and exited. </li><li><code>Local static objects</code> are allocated before their ﬁrst use and are destroyed when the program ends.</li></ul><p>虽然，它们在scope和lifetime上均不同，但是有一个共同点，即都是由程序隐式控制整个lifetime，即内存的分配和释放不用程序员操心。</p><p>但是，有时候，内存的管理非常复杂，根据<a href="https://stackoverflow.com/questions/18217525/why-or-when-do-you-need-to-dynamically-allocate-memory-in-c">该文</a>：</p><ul><li>you cannot determine the maximum amount of memory to use at compile time;</li><li>you want to allocate a very large object;</li><li>you want to build data structures (containers) without a fixed upper size;</li></ul><p>另外一个目的，根据C++ Primer的说法：</p><blockquote><p>One common reason to use dynamic memory is to allow multiple objects to share the same state.</p></blockquote><p>这时候，<code>Dynamic Memory</code>能够解决问题。</p><blockquote><p>Dynamically allocated objects have a lifetime that is independent of where they are created; they exist until they are explicitly freed.</p></blockquote><p>但是，在<code>Dynamic Memory</code>中的一个核心的问题是——<strong>在正确的时间，申请和释放正确的内存</strong>。</p><h1 id="变量在内存中的分配"><a href="#变量在内存中的分配" class="headerlink" title="变量在内存中的分配"></a>变量在内存中的分配</h1><p>在C++中，变量在内存中的分配区域，多种资料使用的术语不尽相同，虽然查了很多资料，但是无法统一。虽然存在差异，但是基本的原则大体相同，如下图所示：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8Enew-delete%E7%9A%84%E4%BD%BF%E7%94%A8/1.png" alt="一个程序的memory layout"></p><p>基本可以包括：</p><ul><li>stack<ul><li>used for nonstatic objects deﬁned inside functions.</li><li>也就是之前提到的automatic objects；</li></ul></li><li>heap<ul><li> objects which are dynamically allocated at run time</li></ul></li><li>static data section<ul><li>bss segment: uninitialized data<ul><li>stand for <a href="https://en.wikipedia.org/wiki/.bss">block starting symbol</a></li><li>including <ul><li>uninitialized global objects</li><li>uninitialized local static objects</li></ul></li><li>these uninitialized objects will be initialized by zero/nullptr.</li></ul></li><li>data segment: initialized data<ul><li>including<ul><li>initialized global objects</li><li>initialized local static objects</li><li>constants: declared by <code>const</code>;</li><li>external variables: declared by <code>extern</code> keyword</li></ul></li></ul></li></ul></li><li>code/text segments<ul><li>store program executable code.</li><li>read-only with fixed size</li></ul></li></ul><h1 id="new-amp-delete的使用"><a href="#new-amp-delete的使用" class="headerlink" title="new &amp; delete的使用"></a>new &amp; delete的使用</h1><p>C++中，最开始使用new &amp; delete 两个操作符来实现内存的申请和释放：</p><ul><li><code>new</code>, which allocates, and optionally initializes, an object in dynamic memory and returns a pointer to that object.</li><li><code>delete</code>, which takes a pointer to a dynamic object, destroys that object, and frees the associated memory.</li></ul><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>使用new在heap中分配的内存是没有名字的，因为不能通过变量名来访问，但是new返回了指向该内存地址的一个指针，可以通过指针来访问这个内存中的object。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// pi points to int object without initialization</span><span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span></code></pre><h3 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h3><ul><li><p>default initialization</p><p>  虽然分配了内存，但是如果没有显式初始化的话，这些object使用<strong>default initialization</strong>。</p><ul><li>objects of built-in or compound type have undeﬁned value; </li><li>objects of class type are initialized by their default constructor</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// initialized to empty string</span>string <span class="token operator">*</span> ps <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pi points to an uninitialized int</span><span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span></code></pre></li><li><p>direct initialization</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// object to which pi points has value 1024 </span><span class="token keyword">int</span> <span class="token operator">*</span> pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// *ps is "9999999999"</span>string <span class="token operator">*</span>ps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> ’<span class="token number">9</span>’<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre></li><li><p>list initialization</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// vector with ten elements with values from 0 to 9 </span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">*</span> pv <span class="token operator">=</span> <span class="token keyword">new</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li><li><p>value initialization(following the type name with a pair of empty parentheses)</p><ul><li>For class types, the object is initialized by the default constructor.</li><li>For built-in types, they are initialized by well-defined values. （一般为0）</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// value initialized to the empty string</span>string <span class="token operator">*</span> ps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// value initialized to 0; *pi2 is 0</span><span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p>考虑到不同的初始化方式的影响，我们最好显式地对动态分配的内存进行初始化。</p><h3 id="auto的使用限制"><a href="#auto的使用限制" class="headerlink" title="auto的使用限制"></a>auto的使用限制</h3><p>使用auto可以进行类型推导，但是必须从initilizer中推导，当使用direct initialization时，只能提供一个initializer。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ok</span><span class="token keyword">auto</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error: initialization of new-expression for type ‘auto’ requires exactly one element</span><span class="token keyword">auto</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error: initialization of new-expression for type ‘auto’ requires exactly one element</span><span class="token keyword">auto</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="处理const"><a href="#处理const" class="headerlink" title="处理const"></a>处理const</h3><p>使用<code>new</code>为<code>const</code>对象分配内存是可行的：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// allocate and initialize a const int </span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> pci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// allocate a default-initialized const empty string </span><span class="token keyword">const</span> string <span class="token operator">*</span> pcs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> string<span class="token punctuation">;</span></code></pre><p>当为<code>const</code>对象分配内存时，必须要初始化。</p><ul><li><p>对于基本类型，必须显式初始化，否则报错。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ok, *pci = 0</span><span class="token comment" spellcheck="true">// pointer to const int</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>pci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error: uninitialized const in ‘new’ of ‘const int’</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>pci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">;</span></code></pre></li><li><p>对于class type，则情况有点复杂。</p><ul><li><p>类有成员变量，无默认构造函数；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span>A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span>A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error: uninitialized const in ‘new’ of ‘const class A’</span><span class="token keyword">const</span> A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> A<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span><span class="token keyword">const</span> A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>类有成员变量，有默认构造函数；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span>A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span>A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error: uninitialized const in ‘new’ of ‘const class A’</span><span class="token keyword">const</span> A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> A<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span><span class="token keyword">const</span> A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>类无成员变量，无默认构造函数；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span>A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span>A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span><span class="token keyword">const</span> A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> A<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span><span class="token keyword">const</span> A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>类无成员变量，有默认构造函数；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span>A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span>A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span><span class="token keyword">const</span> A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> A<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span><span class="token keyword">const</span> A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p>  总结来看：</p><ul><li>对于使用new来动态分配const对象的内存时，如果有成员变量时，必须显式初始化，不能隐式初始化；</li><li>对于没有成员变量时，可以使用隐式初始化；</li></ul></li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>当内存分配失败时，使用<code>new</code>会抛出异常，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// if allocation fails, new throws std::bad_alloc</span><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span> </code></pre><p><a href="https://www.geeksforgeeks.org/if-memory-allocation-using-new-is-failed-in-c-then-how-it-should-be-handled/">一般在分配大内存时，有可能会失败。</a> 如果我们不希望<code>new</code>抛出异常，可以使用<code>nothrow</code>关键字。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// if allocation fails, new returns a null pointer</span><span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span></code></pre><p>这种使用方式称为<strong>placement new</strong>。</p><p><code>bad_alloc</code>与<code>nothrow</code>均定义在<code>&lt;new&gt;</code>header中。</p><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>与new对应的，delete完成2件事情：</p><ul><li>It destroys the object to which its given pointer points, </li><li>and it frees the corresponding memory.</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>传入的pointer value可以是new分配的，也可以是nullptr；</p><p>  也就是说，<strong>delete一个空指针也是可以的</strong>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// p must point to a dynamically allocated object or be null</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span></code></pre></li><li><p>删除不是new分配的内存时，其行为是undefined的。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>pi1 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>pi2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error: i is not a pointer</span><span class="token comment" spellcheck="true">// error: type ‘int’ argument given to ‘delete’, expected pointer</span><span class="token keyword">delete</span> i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// undeﬁned: pi1 refers to a object on stack, no errors occurred from the compiler.</span><span class="token keyword">delete</span> pi1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: it is always ok to delete a null pointer</span><span class="token keyword">delete</span> pi2<span class="token punctuation">;</span></code></pre></li><li><p>对同一块内存释放两次，其行为也是undefined的。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token operator">*</span>pd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token operator">*</span>pd2 <span class="token operator">=</span> pd<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok </span><span class="token keyword">delete</span> pd<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// undefined: the memory pointed to by pd2 was already freed</span><span class="token keyword">delete</span> pd2<span class="token punctuation">;</span></code></pre><p>  在clang++编译器下，对于释放两次内存的这种操作，运行时出现错误如下：</p><p>  <img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8Enew-delete%E7%9A%84%E4%BD%BF%E7%94%A8/2.png" alt="释放两次内存运行时出现的错误"></p></li><li><p>释放const对象对应的资源，其方式与一般的object并无二致。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> pci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok: deletes a const object</span><span class="token keyword">delete</span> pci<span class="token punctuation">;</span></code></pre></li><li><p>通过new创建的动态内存，在没有显式释放前会一直存在；</p><p>  这意味着block scope对其不起作用，即便函数返回了，其中创建的动态内存也不会释放，对应的object也不会有任何变化。这与smart pointers是不同的。</p><p>  这样的好处是，这块内存以及对应的变量会一直存在，不用担心由系统收回。但是也存在弊端，当我们忘记显式释放这块内存时，会导致内存泄露，尤其是当在函数中返回时，我们无法获取到对应的指针了，就无法释放对应的内存。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>  此时，其中p指向的内存，在函数返回后仍然存在，但是无法获取到指针p，也就无法释放了。</p></li><li><p>在delete指向对应内存的指针后，将该指针置nullptr是一种推荐的方式。</p><p>  因为即便删除了对应的内存，但是在一些系统中，对应的指针仍然持有这块已经被删除的内存的地址，这时候该指针成为<strong>dangling pointer</strong>。为了避免再次使用该指针，显式地将其赋值为nullptr，起到提醒的作用。</p><p>  但是对于指向相同内存空间的不同指针，将其中一个置为nullptr，不会影响另外的指针。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// p and q point to the same memory</span><span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// invalidates both p and q</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// indicates that p is no longer bound to an object</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// q is still a dangling pointer .....</span></code></pre></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Primer - 12.1.2 Managing Memory Directly</li><li><a href="https://en.cppreference.com/w/cpp/language/new">https://en.cppreference.com/w/cpp/language/new</a></li><li><a href="https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/">https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/</a></li><li><a href="https://sbme-tutorials.github.io/2018/data-structures/notes/2_week2a.html">https://sbme-tutorials.github.io/2018/data-structures/notes/2_week2a.html</a></li><li><a href="https://www.javatpoint.com/memory-layout-in-c">https://www.javatpoint.com/memory-layout-in-c</a></li><li><a href="https://developerinsider.co/memory-layout-representation-of-c-program/">https://developerinsider.co/memory-layout-representation-of-c-program/</a></li><li><a href="https://lovemesomecoding.com/data-structure-algorithm/data-structure-algorithm-memory">https://lovemesomecoding.com/data-structure-algorithm/data-structure-algorithm-memory</a></li><li><a href="https://www.scaler.com/topics/c/memory-layout-in-c/">https://www.scaler.com/topics/c/memory-layout-in-c/</a></li><li><a href="https://hackthedeveloper.com/memory-layout-c-program/">https://hackthedeveloper.com/memory-layout-c-program/</a></li><li><a href="https://en.wikipedia.org/wiki/Data_segment">https://en.wikipedia.org/wiki/Data_segment</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic memory </tag>
            
            <tag> new </tag>
            
            <tag> delete </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存管理：weak_ptr</title>
      <link href="/2022/11/13/bian-cheng-zhi-dao/c-nei-cun-guan-li-weak-ptr/"/>
      <url>/2022/11/13/bian-cheng-zhi-dao/c-nei-cun-guan-li-weak-ptr/</url>
      
        <content type="html"><![CDATA[<h1 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h1><h2 id="举例：双向链表"><a href="#举例：双向链表" class="headerlink" title="举例：双向链表"></a>举例：双向链表</h2><p>已经有了<code>shared_ptr</code>和<code>unique_ptr</code>后，为什么还要提出<code>weak_ptr</code>呢？以双向链表为例说明，各种引用关系如下图所示：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Aweak_ptr/1.png" alt="链表中的引用关系"></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call Node constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call Node destructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">></span> pre<span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">></span> next<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">></span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">></span> <span class="token function">sp2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// == 1 </span>    cout<span class="token operator">&lt;&lt;</span>sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> sp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ==</span>        <span class="token comment" spellcheck="true">// == 2 </span>    <span class="token comment" spellcheck="true">// sp1 -> next = sp2;</span>    <span class="token comment" spellcheck="true">// sp2 -> pre= sp1;</span>        <span class="token comment" spellcheck="true">// cout&lt;&lt;sp1.use_count()&lt;&lt;endl;</span>    <span class="token comment" spellcheck="true">// cout &lt;&lt; sp2.use_count() &lt;&lt; endl;</span>    <span class="token comment" spellcheck="true">// ==</span><span class="token punctuation">}</span></code></pre><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在上述的代码中，只开启1对应的代码时，得到如下的输出：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Aweak_ptr/2.png" alt="只开启1对应的代码"></p><p>当1和2都开启后，得到如下的输出：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Aweak_ptr/3.png" alt="当1和2都开启对应的代码"></p><p>发现当开启了2之后，析构函数没有被调用，说明出现了对象没有被销毁，出现了内存泄露。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>出现上述现象的原因在于，对于双向链表而言，当要释放node2内存空间时，需要指向node2的shared_ptr的reference count为0，为了实现这个目的，需要将node1.next释放，也就需要释放node1。</p><p>进一步，如果要释放node1，需要node2.pre被释放，也就需要释放node2。最后变成了：</p><ul><li>要释放node2，先要释放node1；</li><li>要释放node1，先要释放node2；</li></ul><p>即<strong>循环引用</strong>的问题。</p><h2 id="weak-ptr的解决方式"><a href="#weak-ptr的解决方式" class="headerlink" title="weak_ptr的解决方式"></a>weak_ptr的解决方式</h2><p>只需要将Node中的next和pre变为<code>weak_ptr</code>即可，其余仍然不变。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call Node constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call Node destructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    weak_ptr<span class="token operator">&lt;</span>Node<span class="token operator">></span> pre<span class="token punctuation">;</span>    weak_ptr<span class="token operator">&lt;</span>Node<span class="token operator">></span> next<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>得到如下的输出：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Aweak_ptr/4.png" alt="使用weak_ptr后的输出"></p><p>发现能够成功调用到析构函数，说明内存被正确的释放了。</p><p>其中的原因在于，此时在双向链表中，node1和node2对应的shared_ptr的reference count均为1，没有形成环，也就没有循环引用的问题，可以自由释放。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p><code>weak_ptr</code>具有如下的特点：</p><ul><li><p>不控制所指向对象的lifetime，也不负责释放该对象；</p><blockquote><p>do not control the lifetime of the object to which it points.</p></blockquote><ul><li>所指向的对象由<code>shared_ptr</code>负责管理。</li></ul></li><li><p>由于不负责管理该对象，因此其不会改变<code>shared_ptr</code>的<strong>reference count</strong>；</p><p>  因为不会改变object的引用计数，也不负责其的释放，因此当shared_ptr的引用计数为0后，即便存在<code>weak_ptr</code>指向该object，也会毫不犹豫的执行object的释放。</p></li></ul><p>因此，总结来看，<code>weak_ptr</code>不负责、不管理所指向的object，只是一个“旁观者”。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>weak_ptr</code>的初始化要依赖<code>shared_ptr</code>：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> p <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// wp weakly shares with p; use count in p is unchanged</span><span class="token comment" spellcheck="true">// wp and p point to the same object</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="确保object存在"><a href="#确保object存在" class="headerlink" title="确保object存在"></a>确保object存在</h2><p>因为当<code>shared_ptr</code>所指向的对象被删除后，<code>weak_ptr</code>也无效了，不能通过指针访问该对象了。因此，为了能够使得<code>weak_ptr</code>有效地访问该对象，必须进行判定。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> np <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// inside the if, np shares its object with p </span><span class="token punctuation">}</span></code></pre><ul><li><code>lock</code> returns a shared_ptr to the shared object.</li></ul><p>只要<code>shared_ptr</code>仍然存在，其所指向的对象也就仍然存在。</p><h1 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h1><p><code>weak_ptr</code>的相关操作如下图所示：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Aweak_ptr/5.png" alt="`weak_ptr`的相关操作"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Primer - 12.1.6 weak_ptr</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> smart pointers </tag>
            
            <tag> weak_ptr </tag>
            
            <tag> shared_ptr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存管理：智能指针与unique_ptr</title>
      <link href="/2022/11/12/bian-cheng-zhi-dao/c-nei-cun-guan-li-zhi-neng-zhi-zhen-yu-unique-ptr/"/>
      <url>/2022/11/12/bian-cheng-zhi-dao/c-nei-cun-guan-li-zhi-neng-zhi-zhen-yu-unique-ptr/</url>
      
        <content type="html"><![CDATA[<h1 id="smart-pointers"><a href="#smart-pointers" class="headerlink" title="smart pointers"></a>smart pointers</h1><p>在传统上，C++使用<code>new</code>和<code>delete</code>两个操作符进行内存管理，但是会有各种问题，比如：忘记释放内存、重复释放内存。考虑到这些问题，C++中提出了<code>smart pointers</code>的概念（取名太low，差评！）。</p><p><code>smart pointers</code>有点像Java的虚拟机，自动管理对象的内存空间。从实现机制上，通过<strong>引用计数</strong>来实现，在Java中的一些虚拟机中，有些也是<a href="https://juejin.cn/post/7011812667992064036">用引用计数来判断对象是否存活，以实现垃圾回收</a>，但是现在JVM很少使用这种机制了，从这个角度来说，C++是不是落后了，哈哈哈。</p><blockquote><p>A smart pointer acts like a regular pointer with the important exception that it automatically deletes the object to which it points.</p></blockquote><p>smart pointers中一般有3种：</p><ul><li><code>shared_ptr</code>, which allows multiple pointers to refer to the same object.</li><li><code>unique_ptr</code>, which “owns” the object to which it points. </li><li><code>weak_ptr</code>, which is a weak reference to an object managed by a shared_ptr. </li></ul><p>All three are deﬁned in the <code>&lt;memory&gt;</code> header.</p><h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">unique_ptr</a>与<code>shared_ptr</code>是不同的：</p><ul><li><code>unique_ptr</code> <strong>完全占有</strong>它所指向的object；<ul><li>意味着，这种是完全控制的、独占的、排他的；</li><li>任何时刻，只有一个<code>unique_ptr</code>能指向特定的对象，即不会出现一个内存中的object，被多个unique_ptr所指向的情况；</li></ul></li><li>被该<code>unique_ptr</code>指向的object的lifetime受到该智能指针的影响，当该智能指针destroyed，其指向的object也会destroyed。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>对于<code>unique_ptr</code>的出初始化，与<code>shared_ptr</code>有相同和不同的部分：</p><ul><li><p>相同点</p><p>  它们都可以使用<code>new</code>来完成初始化，也都必须是<a href="https://en.cppreference.com/w/cpp/language/direct_initialization">direct initialization</a>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// unique_ptr that can point at an int, but initialzied to nullptr </span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1<span class="token punctuation">;</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// p3 points to int with value 42</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>p2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// output</span><span class="token comment" spellcheck="true">/**10142*/</span></code></pre><p>  从输出的数据可以看出几个关键点：</p><ul><li><code>unique_ptr&lt;int&gt; p1</code>中，返回的是一个指向int类型的<code>nullptr</code>；</li><li>通过使用new来direct iniliazation，是C++11中初始化一个非空指针的合适的方式；</li><li>最奇怪的是，使用<code>unique_ptr&lt;int&gt; p2()</code>来初始化，得到竟然不是nullptr，而是一个有效的unique_ptr，并且其指向的数字为1，且是固定的，不是一个undefined value，可能与unique_ptr的构造函数的实现有关，但是考虑到这种奇怪的问题，<strong>强烈禁止使用这种方式来初始化unique_ptr</strong>。</li></ul></li><li><p>不同点</p><p>  在C++11中，<code>shared_ptr</code>可以使用<code>make_shared</code>来初始化，但是在<code>unique_ptr</code>中不可以。直到C++14中，才可以使用<a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/memory-functions?view=msvc-170#make_unique">make_unique</a>来初始化，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> pi <span class="token operator">=</span> make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> ps1 <span class="token operator">=</span> make_unique<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> ps2 <span class="token operator">=</span> make_unique<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'q'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pi <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ps1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ps2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**output:cout&lt;&lt; *pi &lt;&lt; endl;cout&lt;&lt; *ps1 &lt;&lt; endl;cout&lt;&lt; *ps2 &lt;&lt; endl;*/</span></code></pre><ul><li>其中，<code>make_unique&lt;string&gt;(...)</code>函数的参数为string的构造函数要求的参数类型；</li><li>并且，在支持C++14的场景下，强烈推荐使用这种方式来初始化<code>unique_ptr</code>。</li></ul></li></ul><h2 id="copy-amp-assignment-amp-transfer"><a href="#copy-amp-assignment-amp-transfer" class="headerlink" title="copy &amp; assignment &amp; transfer"></a>copy &amp; assignment &amp; transfer</h2><p>既然unique_ptr是独占一段内存中的object的，因此就不能将其copy或者assignment给别人，因为一份object不允许变成两份。</p><pre class=" language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error: copy constructor</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error: normal assignment</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p3<span class="token punctuation">;</span>p3 <span class="token operator">=</span> p1<span class="token punctuation">;</span></code></pre><p>编译输出的结果如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Eunique_ptr/1.png" alt="尝试对unique_ptr进行拷贝和赋值"></p><p>但是一个<code>unique_ptr</code>对于一个object的控制权虽然不能copy，但是可以transfer。</p><blockquote><p>一个不太合适的对比，皇帝的权力不能共享，但是换个人来当皇帝是可以的。</p></blockquote><p>可以用两种方法实现控制权的转移。</p><h3 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h3><p>该函数的调用一般是为了将控制权转移出去，打破了unique_ptr及其指向的object之间的联系，完成了2件事情：</p><ul><li>返回存储在<code>unique_ptr</code>中的指针；</li><li>使得<code>unique_ptr</code>变成<code>nullptr</code>；</li></ul><p>一般用来初始化另一个智能指针。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// init p1</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// return a unique_ptr and make p1 a nullptr</span><span class="token comment" spellcheck="true">// p2 is initialized with unique_ptr which is from p1.</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// output: 10</span></code></pre><p>上例中，将<code>p1.release()</code>之后，将p1指向的对象交给p2负责，自己成为<code>nullptr</code>。同时，也衍生出了一种行为，当<code>p1.release()</code>之后，没有人接盘怎么办？如下：</p><pre class=" language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>此时会导致p1自己变成了nullptr，同时其指向的object没有人显式接盘，也就没有人负责free，如果只是上述这种写法，会导致这个object对应的内存无法被释放，<a href="https://stackoverflow.com/questions/41046028/does-unique-ptr-release-cause-memory-leaks">此文</a>有所描述，因此，此时应该如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> p <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// free p explicitly</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span></code></pre><p>此时，<code>p1.release()</code>之后，指针p接盘了，因此p1没责任了，可以自由地死去了，由p负责之前喜指向的object了，赵氏孤儿的既视感。</p><h3 id="move"><a href="#move" class="headerlink" title="move()"></a>move()</h3><p>这函数类似于release，也完成了unique_ptr控制权的转移。</p><blockquote><p>该函数在右值引用中也有出现。</p></blockquote><pre class=" language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// move makes p1 a nullptr</span>p2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// output: 10</span></code></pre><h3 id="例子：release-导致的困惑问题"><a href="#例子：release-导致的困惑问题" class="headerlink" title="例子：release()导致的困惑问题"></a>例子：release()导致的困惑问题</h3><p>最近看到一个让人迷惑的代码，下述代码的输出是什么？</p><p><strong>如果你认为是崩溃，那可以打错、特错了，我一开始也是这么认为的！</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foo"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">up1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">up2</span><span class="token punctuation">(</span>up1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>up1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"up1 ok"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"up1"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>up1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"up2"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>up2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> <span class="token function">a1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a1 <span class="token operator">-</span><span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> <span class="token function">a2</span><span class="token punctuation">(</span>a1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a2 <span class="token operator">-</span><span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a1 == nullptr: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>a1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>  endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    a1 <span class="token operator">-</span><span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// func2();</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当调用<code>func1</code>时会出现segmentation fault，但是同样的，当调用func2时，我们可能理所当然的认为也会segmentation fault，但是真实的输出如下：</p><pre class=" language-txt"><code class="language-txt">FooFooa1 == nullptr: 1Foo</code></pre><p>nullptr可以调用成员函数，而且还不会崩溃，这说明啥？说明这个调用过程压根就没用上nullptr本身，根据<a href="https://blog.csdn.net/shanghx_123/article/details/89744613">文章</a>所述，空指针可以调用成员函数，因为成员函数在所有类对象之间共享，并不属于特定对象。a1 -&gt; foo()相当于C::foo(this)，而函数foo中并未有成员变量，因此不会发生程序崩溃，当稍微改一下上例时，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foo"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>当func2访问C的变量i时，就会出现segmentation fault。</p><h2 id="用在函数中"><a href="#用在函数中" class="headerlink" title="用在函数中"></a>用在函数中</h2><h3 id="作为参数传递"><a href="#作为参数传递" class="headerlink" title="作为参数传递"></a>作为参数传递</h3><p>unique_ptr作为参数传递给函数时，也要遵守”完全独占“导致的禁止拷贝和赋值的原则。那么按照之前了解的函数传递方式：</p><ul><li><p>pass by reference</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>u<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>u <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span><span class="token function">func1</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>pass by value</p><ul><li><p>对于直接使用pass by value</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>u <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error, copy is forbidden.</span><span class="token function">func2</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>  会导致如下的错误：<br>  <img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Eunique_ptr/2.png" alt="直接使用pass by value"></p></li><li><p>为了pass by value，可以使用std::move()转移控制权。</p><pre class=" language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, use move to transfer ownership</span><span class="token function">func2</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>如果你了解右值引用和移动语义，可能会角色，这里使用move时，需要func2中的参数应该是&amp;&amp;形式，但是我们这里没有这么写，也是可以的，瞬间感觉到C++语言的严谨，哈哈。。。</p></blockquote></li><li><p>还可以隐式使用移动构造函数，完成函数的调用。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ok, call move constructor implicitly.</span><span class="token function">func</span><span class="token punctuation">(</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>  因为在<code>unique_ptr</code>内部的实现中，通过使用move constructor禁止了拷贝构造函数，因此所以的拷贝和赋值都是调用move constructor和assignment。</p></li><li><p>使用release()是不可以的。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> up <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error</span><span class="token function">func</span><span class="token punctuation">(</span>up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>  编译得到如下错误，因为release()返回的对象是普通的pointer，不能转换为smart pointers。<br>  <img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Eunique_ptr/3.png" alt="通过release()隐式初始化unique_ptr被禁止"></p></li></ul></li></ul><p>进一步阅读材料，可以参考：</p><ul><li><a href="https://stackoverflow.com/questions/8114276/how-do-i-pass-a-unique-ptr-argument-to-a-constructor-or-a-function">How do I pass a unique_ptr argument to a constructor or a function?</a></li><li><a href="https://www.nextptr.com/question/qa1343387017/passing-stdunique_ptr-as-function-argument">Passing std::unique_ptr as function argument</a></li></ul><h3 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h3><p>虽然unique_ptr具有“独占”的特点，但是总会有“法外狂徒“。<strong>当unique_ptr作为函数的返回值时，是允许的</strong>。虽然在函数返回时，出现了copy或者assignment行为，但是“合法”，即便此时函数内部的unique_ptr在函数结束后，会被destroyed。</p><p>因为其作为返回值时，当函数内的unqiue_ptr死亡后，返回值所赋予的智能指针仍然是唯一指向之前object的unique_ptr，本质上不违反“独占”的特点，但是此时compiler仍会执行一种特殊的copy。</p><p>使用实例如下：</p><pre class=" language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// create a unique_ptr pointing to an int with value p</span>    <span class="token keyword">return</span> unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// create a unique_ptr pointing to an int with value p</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// return copy of a unique_ptr</span>    <span class="token keyword">return</span> up<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="reset的行为"><a href="#reset的行为" class="headerlink" title="reset的行为"></a>reset的行为</h2><p><code>reset(...)</code>的行为有点复杂，可以概括为：<strong>打扫干净屋子再请客</strong>。</p><ul><li><p>打扫干净屋子</p><p>  当没有参数时，其行为如下：</p><ul><li>删除unique_ptr指向的object；</li><li>将自身置为nullptr；</li></ul><pre class=" language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// output: 1</span></code></pre></li><li><p>请客</p><p>  当有参数时，行为如下：</p><ul><li>删除unique_ptr指向的object；</li><li>使得自身的unique_ptr指向新的object；</li></ul><pre class=" language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** output:0100*/</span></code></pre></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Primer - 12.1.5 unique_ptr</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> smart pointers </tag>
            
            <tag> shared_ptr </tag>
            
            <tag> unique_ptr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的变量及其初始化</title>
      <link href="/2022/11/09/bian-cheng-zhi-dao/c-de-bian-liang-ji-qi-chu-shi-hua/"/>
      <url>/2022/11/09/bian-cheng-zhi-dao/c-de-bian-liang-ji-qi-chu-shi-hua/</url>
      
        <content type="html"><![CDATA[<p>变量的及其初始化可能是编程中最基础、最重要，但是也是最为大家忽略的一个主题，最近在看C++，本来想越过这个主题，但是看到后边，越来越多的内容与变量的初始化有关，而且各种内容十分繁杂，想着这一篇总结一下。</p><h1 id="关于variable的那些事"><a href="#关于variable的那些事" class="headerlink" title="关于variable的那些事"></a>关于variable的那些事</h1><h2 id="类型的作用"><a href="#类型的作用" class="headerlink" title="类型的作用"></a>类型的作用</h2><p>C++中，变量<code>variable</code>提供了一个署名的内存空间，每个变量都有一个type与其绑定，type提供了非常重要的信息，决定了：</p><ul><li>variable的memory size和layout；</li><li>该memory space中能存储的最大的值；</li><li>对于该variable可以进行什么样的操作；</li></ul><blockquote><p>C++ is a <strong>statically typed language</strong>, which means that <strong>types are checked at compile time</strong>. The process by which types are checked is referred to as <strong>type checking</strong>.</p></blockquote><p>C++中的built-in types包括以下几种：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%9A%84%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96/1.png" alt="C++中的built-in type"></p><blockquote><p>在C++中，<code>variable</code>和<code>object</code>基本可以认为表示相同语义，具体指：<strong>a region of memory that can contain data and has a type</strong>.</p></blockquote><h2 id="scope和lifetime的影响"><a href="#scope和lifetime的影响" class="headerlink" title="scope和lifetime的影响"></a>scope和lifetime的影响</h2><p>C++中每个变量都有作用域<code>scope</code>和生命周期<code>lifetime</code>。这两个概念对于变量的初始化、内存的分配、资源的管理等有非常大的影响，但是经常被忽视。</p><ul><li><p>the <code>scope</code> of a name is the part of the program’s text in which that name is visible.</p><ul><li><code>scope</code>可以分为<code>global scope</code>和<code>block scope</code>；</li><li>任何函数内的<code>scope</code>都是<code>block scope</code>，一般通过<code>&#123;&#125;</code>标识，定义的变量为<code>local variables</code>.</li><li>不同的<code>block scope</code>之间可以发生嵌套，且<code>inner scope</code>会隐藏<code>outer scope</code>中定义的同名变量，但是强烈建议不要采用这种做法；</li></ul></li><li><p>the <code>lifetime</code> of an object is the time during the program’s execution that the object exists.</p><ul><li><code>lifetime</code>受到<code>scope</code>的影响；</li><li>定义在<code>global scope</code>的object在整个program执行期间都会存在；</li><li>定义在<code>block scope</code>的object在当前的作用域结束后，也会被destroyed，比如定义在函数内的变量（也有例外，如<code>static</code>）；</li><li>已经被destroyed的变量不能再用了，这种问题在很多的指针操作、动态内存申请中都会出现；</li></ul></li></ul><h3 id="automatic-objects"><a href="#automatic-objects" class="headerlink" title="automatic objects"></a>automatic objects</h3><p>正常情况下，定义在<code>block scope</code>中的<code>ordinary local variables</code>，在scope结束时，也会被destroyed，其value变为undefined，这种类型的objects称为<code>automatic objects</code>.</p><ul><li><p>在函数调用，参数的传递过程中，函数parameters只在该<code>block scope</code>内有效，当函数调用结束，即被destroyed。</p></li><li><p>那么这些<code>automatic objects</code>是如何初始化的？</p><ul><li>parameters被arguments初始化；</li><li>函数内部的其他local variables可以被显式初始化；</li><li>最后，如果没有显式初始化，则会默认初始化，其value成为<code>undefined</code>。</li></ul></li></ul><h3 id="Local-static-objects"><a href="#Local-static-objects" class="headerlink" title="Local static objects"></a>Local static objects</h3><p><strong>问题：有时需要在函数调用结束后，仍然让一些variable存在，而不是被destroyed，怎么办？</strong></p><ul><li>使用<strong>全局变量</strong>呗，但是这种操作将该变量的控制权暴露给所有的函数，这显然不是我们想要的。</li><li>static变量可以有效解决这个问题：<ul><li>其<code>lifetime</code>在函数对应的<code>block scope</code>结束后，仍然存续；</li><li>其次，其只能在该函数内进行访问，不会被别的函数修改；</li></ul></li></ul><p>这种定义在<code>block scope</code>的variable称为<code>local static objects</code>，关于static的进一步阅读可以参考<a href="http://www.guozet.me/post/C++-Static-keyword/">此文</a>。</p><ul><li>它们在program结束时才会被destroyed；</li><li>这种特殊的local variables的初始化也有其特点：<ul><li>它们的初始化只有一次，即在对该函数的第一次调用时完成；</li><li>如果没有对它们进行显式的初始化，它们通过<a href="https://en.cppreference.com/w/cpp/language/value_initialization">value initilization</a>完成，即全部用0初始化。</li></ul></li></ul><blockquote><p>根据<a href="https://stackoverflow.com/questions/8106016/c-default-initialization-and-value-initialization-which-is-which-which-is-ca">该文</a>：</p><ol><li><strong>Value initialization</strong> for fundamental types means <strong>zero-initialization</strong>, which in turn means that the variables are initialized to zero (which all fundamental types have).</li><li>For objects of class type, both default- and value-initialization invoke the default constructor. What happens then depends on the constructor’s initializer list, and the game continues recursively for member variables.</li></ol></blockquote><p>代码示例如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> call_count<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> call_count <span class="token operator">&lt;&lt;</span> <span class="token string">": hello"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    call_count <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> times <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> times<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// output:</span><span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span><span class="token number">0</span><span class="token operator">:</span> hello<span class="token number">1</span><span class="token operator">:</span> hello<span class="token number">2</span><span class="token operator">:</span> hello<span class="token number">3</span><span class="token operator">:</span> hello<span class="token number">4</span><span class="token operator">:</span> hello<span class="token operator">*</span></code></pre><p><code>call_count</code>默认初始化为0，当显式给出1时，则输出从1：hello开始。</p><h2 id="variable-declaration-amp-definition"><a href="#variable-declaration-amp-definition" class="headerlink" title="variable declaration &amp; definition"></a>variable declaration &amp; definition</h2><h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><ul><li>To allow programs to be written in logical parts, C++ supports what is commonly known as <strong>separate compilation</strong>.<ul><li><strong>Separate compilation</strong> lets us split our programs into several ﬁles, each of which can be compiled independently.</li><li>To support separate compilation, C++ distinguishes between <code>declarations</code> and <code>deﬁnitions</code>.</li><li>To use a variable in more than one ﬁle requires declarations that are separate from the variable’s deﬁnition.</li></ul></li></ul><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><ul><li><p>A <strong>declaration</strong> makes a name known to the program. </p><ul><li>A ﬁle that wants to use a name deﬁned elsewhere includes a declaration for that name.</li><li>A variable declaration speciﬁes the type and name of a variable.</li></ul></li><li><p>A <strong>deﬁnition</strong> creates the associated entity.</p><ul><li><strong>A variable deﬁnition is a declaration</strong>.</li><li>In addition to specifying the name and type, a deﬁnition also <strong>allocates storage and may provide the variable with an initial value</strong>. 在这个过程中发生的是初始化。</li></ul></li><li><p>Variables must be deﬁned exactly once but can be declared many times.</p></li><li><p>To use the same variable in multiple ﬁles, we must deﬁne that variable in one—and only one—ﬁle. </p></li><li><p>Other ﬁles that use that variable must declare—but not deﬁne—that variable.</p></li></ul><p>两者在代码中的区别是啥？</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// declares but does not deﬁne i</span><span class="token keyword">extern</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// declares and deﬁnes j</span><span class="token keyword">int</span> j<span class="token punctuation">;</span></code></pre><ul><li>Any declaration that includes an explicit initializer is a <strong>definition</strong>.</li><li>We can provide an initializer on a variable defined as <code>extern</code>, but doing so overrides the <code>extern</code>.</li><li>An extern that has an initializer is a <strong>definition</strong>:<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.1416</span><span class="token punctuation">;</span></code></pre><ul><li><strong>It is an error to provide an initializer on an extern inside a function</strong>.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// compile output:</span><span class="token comment" spellcheck="true">// error: ‘a’ has both ‘extern’ and initializer</span></code></pre></li></ul></li></ul><h1 id="初始化那些事"><a href="#初始化那些事" class="headerlink" title="初始化那些事"></a>初始化那些事</h1><p>根据<a href="https://en.cppreference.com/w/cpp/language/initialization">C++官方文档</a>，变量的初始化行为如下：</p><blockquote><p>Initialization of a variable provides its initial value at the time of construction.</p></blockquote><p>C++ Primer中这么描述initialization：</p><blockquote><p>An object that is initialized gets the speciﬁed value at the moment it is created.</p></blockquote><p>简单来说，initialization强调2点：</p><ul><li>发生在变量构造期间：分配一个内存空间，即上述所说的<code>variable definition</code>中；</li><li>赋值：给该变量一个特定的值；</li></ul><p>变量的初始化，不止发生在普通的variable definition中，函数的参数传递和函数的返回值的获取，也是变量初始化的实际场景。</p><h2 id="Initialization与Assignment的区别"><a href="#Initialization与Assignment的区别" class="headerlink" title="Initialization与Assignment的区别"></a>Initialization与Assignment的区别</h2><p>简单的结论：<strong>Initialization不是Assignment</strong>，但是如果认为两者一样，在一些场合中也不会导致什么问题。</p><ul><li><p><strong>Initialization</strong> happens when a variable is given a value when it is created.</p><ul><li>从这个角度理解，<strong>Initialization</strong>只有一次。</li></ul></li><li><p><strong>Assignment</strong> obliterates an object’s current value and replaces that value with a new one.</p><ul><li><strong>Assignment</strong>在整个程序运行期间，可以发生多次。</li></ul></li></ul><h2 id="默认初始化的行为"><a href="#默认初始化的行为" class="headerlink" title="默认初始化的行为"></a>默认初始化的行为</h2><p>当在variable definition时，没有显式给出初始化的值时，变量会被default initialized，默认值的提供取决于两个因素：</p><ul><li><p>变量的类型；</p><ul><li>对于语言支持的基本数据类型，按照默认语言规定的默认初始化行为；</li><li>对于一些类类型或者自定义的类型，需要在构造函数中自行实现，如string默认初始化为空字符串；<blockquote><p>Objects of class type that we do not explicitly initialize have a value that is deﬁned by the class.</p></blockquote></li></ul></li><li><p>变量的位置；</p><ul><li>The value of an object of built-in type that is not explicitly initialized depends on where it is deﬁned. Variables deﬁned outside any function body are initialized to <strong>zero</strong>.</li><li>variables of built-in type deﬁned inside a function are uninitialized. The value of an uninitialized variable of built-in type is <strong>undefined</strong>.<ul><li>It is an error to copy or otherwise try to access the value of a variable whose value is undeﬁned.</li></ul></li></ul><blockquote><p>Uninitialized objects of built-in type deﬁned inside a function body have undefined value. </p></blockquote></li></ul><p>示例代码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> l_int<span class="token punctuation">;</span>    <span class="token keyword">float</span> l_float<span class="token punctuation">;</span>    <span class="token keyword">double</span> l_double<span class="token punctuation">;</span>    <span class="token keyword">char</span> l_char<span class="token punctuation">;</span>    string l_str<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> l_int <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> l_float <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> l_double <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> l_char <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> l_str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> g_int<span class="token punctuation">;</span><span class="token keyword">float</span> g_float<span class="token punctuation">;</span><span class="token keyword">double</span> g_double<span class="token punctuation">;</span><span class="token keyword">char</span> g_char<span class="token punctuation">;</span>string g_str<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> g_int <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> g_float <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> g_double <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> g_char <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> g_str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// output</span><span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span><span class="token number">0</span><span class="token number">0</span><span class="token number">0</span><span class="token number">18192</span><span class="token number">1.4013e-45</span><span class="token number">3.17535e-310</span><span class="token operator">*</span></code></pre><h2 id="不同的初始化方式及适用场景"><a href="#不同的初始化方式及适用场景" class="headerlink" title="不同的初始化方式及适用场景"></a>不同的初始化方式及适用场景</h2><p>在C++中定义了不同的初始化方式，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 最常见</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// c++中引入的list initialization</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 类似类类型中对象的初始化</span><span class="token keyword">int</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="list-initialization"><a href="#list-initialization" class="headerlink" title="list initialization - {}"></a>list initialization - {}</h3><p><a href="https://en.cppreference.com/w/cpp/language/list_initialization">list initialization</a>是方法是在C++11种引入的方法。</p><ul><li>这种方法<strong>可以在任何需要初始化的地方使用</strong>；</li><li>甚至在一些进行赋值的场景中也能用；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok</span>a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>虽然，有很多的初始化方法，但是为啥又引入新的一种，或者，换一个问题——这个方法有啥好处？</li></ul><p>这种初始化方法用在built-in types时：</p><blockquote><p>The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information.</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.1415926</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">{</span>pi<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">{</span>pi<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">c</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> d <span class="token operator">=</span> pi<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><p>编译输出如下：<br><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E7%9A%84%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96/2.png" alt="list initialization在隐式类型转换中的作用"></p><blockquote><p>在MacOS中，这里使用编译命令<code>g++</code>时要注意加上 <code>-std=c++11</code>。</p></blockquote><p>发现通过这种初始化方法，之前那种隐式的类型转换行不通的了，必须要显式地给出。</p><h1 id="阅读资料"><a href="#阅读资料" class="headerlink" title="阅读资料"></a>阅读资料</h1><ol><li>C++ Primer - 2.2.1 Variable Definition</li><li>C++ Primer - 6.1.1 Local Objects</li><li><a href="https://en.cppreference.com/w/cpp/language/declarations">https://en.cppreference.com/w/cpp/language/declarations</a></li><li><a href="https://accu.org/journals/overload/25/139/brand_2379/">https://accu.org/journals/overload/25/139/brand_2379/</a></li><li><a href="https://en.cppreference.com/w/cpp/language/list_initialization">https://en.cppreference.com/w/cpp/language/list_initialization</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> variable </tag>
            
            <tag> static </tag>
            
            <tag> scope </tag>
            
            <tag> lifetime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的参数传递方式</title>
      <link href="/2022/11/06/bian-cheng-zhi-dao/python-zhong-de-can-shu-chuan-di-fang-shi/"/>
      <url>/2022/11/06/bian-cheng-zhi-dao/python-zhong-de-can-shu-chuan-di-fang-shi/</url>
      
        <content type="html"><![CDATA[<p>工作写Python脚本时，对于python中函数参数传递有疑惑，在加上最近在学习C++，恰好复习了C++中参数传递的传递方法，于是想把这两类对比一下。</p><h1 id="Review：C-中的参数传递方式"><a href="#Review：C-中的参数传递方式" class="headerlink" title="Review：C++中的参数传递方式"></a>Review：C++中的参数传递方式</h1><p>C++中的参数传递，总结在<a href="https://lifehit.cn/2022/11/02/bian-cheng-zhi-dao/c-zhong-de-han-shu-can-shu-chuan-di/">这篇文章</a>中，主要分为：</p><ul><li>按值传递；</li><li>按引用传递；</li></ul><p>不同的传递方式，有不同的好处，比如按引用传递，可以避免copy，节省资源；按照值传递，则不会影响原有数据，这些方式没有好坏，只有是否适合特定的场景。</p><h1 id="Python中的参数传递方式"><a href="#Python中的参数传递方式" class="headerlink" title="Python中的参数传递方式"></a>Python中的参数传递方式</h1><p>众所周知，python以其速度慢而被人诟病，因此对于函数中参数的传递，如果能够避免参数copy，可以节省资源，那么Python中函数参数究竟是则怎么传递的？</p><p>要知道，Python中没有引用的概念。因此，它的函数参数传递，有人叫做pass by value，但是其行为又像pass by reference。确定具体的方式，需要查询变量的内存地址，<a href="https://stackoverflow.com/questions/16408472/print-memory-address-of-python-variable">python中使用id(…)函数</a>。</p><blockquote><p>Return the “identity” of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.</p></blockquote><p>这里举例说明。</p><h2 id="Python中的赋值操作"><a href="#Python中的赋值操作" class="headerlink" title="Python中的赋值操作"></a>Python中的赋值操作</h2><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">100</span>b <span class="token operator">=</span> a<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The address of a is {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The address of b is {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b <span class="token operator">=</span> <span class="token number">200</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The address of b is {} after assignments"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output</span><span class="token comment" spellcheck="true"># The address of a is 0x956a80</span><span class="token comment" spellcheck="true"># The address of b is 0x956a80</span><span class="token comment" spellcheck="true"># The address of b is 0x957700 after assignments</span></code></pre><p>python中赋值操作，有点令人迷惑，不同于C++，每个变量的初始化都伴随着内存的分配，但是python中不是这样，执行上述的代码，内存分配的场景如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/Python%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/1.png" alt="Python中的赋值操作"></p><p>对于<code>b = a</code>中变量<code>b</code>的初始化，有点像Java中的字符串常量池的意思，如果已经有了相应的值，直接赋值即可，不重新分配内存。但是，当<code>b</code>的值发生变化后，其立刻就会重新分配内存空间，有点延迟分配的意思。</p><p>在C++中，函数的参数传递与变量的赋值遵循相同的规则，在python中是否也是一样呢？</p><h2 id="Python中的可变对象和不可变对象"><a href="#Python中的可变对象和不可变对象" class="headerlink" title="Python中的可变对象和不可变对象"></a>Python中的可变对象和不可变对象</h2><p>如<a href="https://www.runoob.com/note/46684">文章</a>所示，python中存在可变和不可变的对象，所谓<strong>可变</strong>是指，对象的内容是可变的；而<strong>不可变</strong>则相反，表示其内容不可变。</p><ul><li><p>不可变对象：int，string，float，tuple。可理解为C++中，该参数为值传递。<br>  当不可变的对象发生变化后，并不违反不可变的原则，而是创建了一个新的对象，并将变量指向西对象，如下所示：</p><pre class=" language-python"><code class="language-python">i <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The address of i is {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>i <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The address of i is {} after change"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># The address of i is 0x955e20</span><span class="token comment" spellcheck="true"># The address of i is 0x955e40 after change</span></code></pre><p>  <img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/Python%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/2.png" alt="不可变对象的修改操作"></p><p>  换句话说，当你不断修改一个不可变的对象时，就是不断在申请内存，OMG。</p></li><li><p>可变对象：list，dictionary。可理解为C++中，该参数为指针传递。<br>  在可变对象中，修改其中的内存，不会造成重新申请内存。</p><pre class=" language-python"><code class="language-python">l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The address of l is {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The address of l is {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The address of l is {} after change l[1]"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The address of l is {} after change l[1]"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># The address of l is 0x7f0f25489540</span><span class="token comment" spellcheck="true"># The address of l is 0x955ea0</span><span class="token comment" spellcheck="true"># The address of l is 0x7f0f25489540 after change l[1]</span><span class="token comment" spellcheck="true"># The address of l is 0x955ee0 after change l[1]</span></code></pre><p>  当修改可变对象中的值时，对象本身不会新申请内存，但是其中变化的值，需要重新申请内存。</p></li></ul><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>了解了变量赋值，可变和不可变对象，下面看一下函数的参数传递。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> int<span class="token punctuation">,</span> f<span class="token punctuation">:</span> float<span class="token punctuation">,</span> s<span class="token punctuation">:</span>str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> tuple<span class="token punctuation">,</span> l<span class="token punctuation">:</span> list<span class="token punctuation">,</span> d<span class="token punctuation">:</span> dict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"i-{}, f-{}, s-{}, t-{}, l-{}, d-{} after call func before change"</span>        <span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>    d<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"i-{}, f-{}, s-{}, t-{}, l-{}, d-{} after call func after change object's objects"</span>        <span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        i <span class="token operator">=</span> <span class="token number">2</span>    f <span class="token operator">=</span> <span class="token number">0.2</span>    s <span class="token operator">=</span> <span class="token string">"hi"</span>    t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>    l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span>    d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">}</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"i-{}, f-{}, s-{}, t-{}, l-{}, d-{} after call func after change object itself"</span>        <span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    i <span class="token operator">=</span> <span class="token number">1</span>    f <span class="token operator">=</span> <span class="token number">0.1</span>    s <span class="token operator">=</span> <span class="token string">"hello"</span>    t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>    l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>    d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"i-{}, f-{}, s-{}, t-{}, l-{}, d-{} for initialization"</span>        <span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    func<span class="token punctuation">(</span>i<span class="token punctuation">,</span> f<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> l<span class="token punctuation">,</span> d<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"i-{}, f-{}, s-{}, t-{}, l-{}, d-{} after call func"</span>        <span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>hex<span class="token punctuation">(</span>id<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> f<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> l<span class="token punctuation">,</span> d<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># output</span>    <span class="token comment" spellcheck="true"># i-0x955e20, f-0x7f48221af2f0, s-0x7f48221441f0, t-0x7f482218b940, l-0x7f482220c540, d-0x7f482227a900 for initialization</span>    <span class="token comment" spellcheck="true"># i-0x955e20, f-0x7f48221af2f0, s-0x7f48221441f0, t-0x7f482218b940, l-0x7f482220c540, d-0x7f482227a900 after call func before change</span>    <span class="token comment" spellcheck="true"># i-0x955e20, f-0x7f48221af2f0, s-0x7f48221441f0, t-0x7f482218b940, l-0x7f482220c540, d-0x7f482227a900 after call func after change object's objects</span>    <span class="token comment" spellcheck="true"># i-0x955e40, f-0x7f48222aca90, s-0x7f4822144170, t-0x7f482216c740, l-0x7f4822136dc0, d-0x7f482224b680 after call func after change object itself</span>    <span class="token comment" spellcheck="true"># i-0x955e20, f-0x7f48221af2f0, s-0x7f48221441f0, t-0x7f482218b940, l-0x7f482220c540, d-0x7f482227a900 after call func</span>    <span class="token comment" spellcheck="true"># 1 0.1 hello (1, 5, 7) [3, 5, 7] {'a': 100, 'b': 2}</span></code></pre><p>从上述的代码中可以看出：</p><ul><li>不管是可变还是不可变对象，作为函数参数传递的时刻，不会发生copy，也就不会申请新的内存，内存地址不变。</li><li>当在函数内修改可变对象中的对象，如list和dict中的值，不会影响该可变对象的内存地址，但是会影响外部传入对象的值，<strong>与C++中的按引用传递一致</strong>。</li><li>不管是可变还是不可变对象，在函数内部进行修改后，都会重新申请内存，生成新的内存地址，与传入的参数解绑，对其的修改也不会影响外部的变量，此时<strong>与C++中的按值传递一致</strong>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果传入函数的参数不被修改（无论对象可变还是不可变），就指向同一个地址；</li><li>如果函数参数本身变化了（无论对象可变还是不可变），生成新地址，不影响外部变量，<strong>与C++中的按值传递一致</strong>；</li><li>如果函数参数中的对象变化了（只针对可变参数）：内存地址不变，影响外部变量，<strong>与C++中的按引用传递一致</strong>。</li></ul><p>一些资料把这种参数传递方式称为 <code>call by object reference</code> ， <code>Call by Sharing</code>。</p><p>回顾到我们在写python脚本时，对于命令行输入的参数，一般会打包成一个<code>dict</code>，其作为参数传递到各个函数时，不会发生copy，但是要注意，在各个函数内对于该<code>dict</code>中的任意修改，都会影响全局的环境。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/69746955">https://zhuanlan.zhihu.com/p/69746955</a></li><li><a href="https://www.codespeedy.com/find-the-memory-address-of-a-variable-in-python/">https://www.codespeedy.com/find-the-memory-address-of-a-variable-in-python/</a></li><li><a href="https://www.onlinegdb.com/online_python_compiler">https://www.onlinegdb.com/online_python_compiler</a></li><li><a href="https://python-course.eu/python-tutorial/passing-arguments.php">https://python-course.eu/python-tutorial/passing-arguments.php</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 按值传递 </tag>
            
            <tag> 按引用传递 </tag>
            
            <tag> argument passing </tag>
            
            <tag> pass by object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Virtual Memory（4）：page table过大如何解决？</title>
      <link href="/2022/11/06/ji-suan-ji-ji-chu/virtual-memory-4-page-table-guo-da-ru-he-jie-jue/"/>
      <url>/2022/11/06/ji-suan-ji-ji-chu/virtual-memory-4-page-table-guo-da-ru-he-jie-jue/</url>
      
        <content type="html"><![CDATA[<h1 id="问题：page-table过大"><a href="#问题：page-table过大" class="headerlink" title="问题：page table过大"></a>问题：page table过大</h1><p>前面说到，每个程序（或者进程）都有一个page table，以此来区分它和其他的进程，彼此之间互不干扰。而且，每个page table都保存在内存中。但是随着程序或者多进程程序的增多，内存的容量入不敷出。</p><h2 id="举例：page-table占据的空间"><a href="#举例：page-table占据的空间" class="headerlink" title="举例：page table占据的空间"></a>举例：page table占据的空间</h2><p>举例说明，对于32位的virtual address，4KiB的page size（12bits），page table中共有 $2^{20}$ 个entry，如果每个entry共4个bytes，则一个page table需要占据 $2^{22}$ 个bytes，共4MiB。</p><p>因此，一个process对应4MiB的page table，成百上千的process需要的内存空间非常大。更不用说，现在的地址均为64位的，则需要的内存空间更大。</p><h1 id="一些解决办法"><a href="#一些解决办法" class="headerlink" title="一些解决办法"></a>一些解决办法</h1><p>那么如何减少page table占据的内存空间呢？一般来说，有5种方法。</p><h2 id="dynamic-page-table-with-a-single-direction"><a href="#dynamic-page-table-with-a-single-direction" class="headerlink" title="dynamic page table with a single direction"></a>dynamic page table with a single direction</h2><p><strong>前面的page table的问题</strong>：容量的大小在初始阶段已经确定，但是一个process可能用不了那么大的page table。</p><p><strong>解决思路</strong>：最简单的方式是让page table的大小随着process使用的内存增多而逐渐增多。</p><p><strong>解决方式</strong>：这种方法可以通过设置一个limit register来解决，给每个process一个固定的初始page table容量，当超过该容量时，就随着process占据的virtual address space的增多而增加。</p><p><strong>方法的不足</strong>：这种方法，要求address space只能向一个方向扩展。</p><h2 id="dynamic-page-table-with-both-directions"><a href="#dynamic-page-table-with-both-directions" class="headerlink" title="dynamic page table with both directions"></a>dynamic page table with both directions</h2><p><strong>上述方法的问题</strong>：address space只能向一个方向扩展，<a href="https://juejin.cn/post/6844904099889020935">受到一些编程语言的限制</a>，比如C++：</p><ul><li>stack的内存地址向下增长；</li><li>heap的内存地址向上增长；</li></ul><p>解决思路：将address space划分，同时支持向两个方向扩展。</p><p>解决方法：与上述方法相同。此时，需要两个单独的page tables和对应的limit registers。对于virtual address也要进行划分，用来指定去哪个page table完成映射，如下所示，<strong>通过提供一个bit进行标识</strong>。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Virtual-Memory%EF%BC%884%EF%BC%89%EF%BC%9APage-table%E8%BF%87%E5%A4%A7%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/1.png" alt="使用一个bit划分两个page table"></p><ul><li>其中，通过hight-order bit决定去哪个page table完成映射；</li><li>每个分开的page table的大小最多是原来的一半；最小是limit register指定的数量；</li><li>这种划分，对于上层的应用来说完全感知不到，可以像往常一样操作；</li><li>此时，每个page table的大小取决于程序中使用的stack空间多还是heap 空间多。</li></ul><p>这种方法的主要缺点是<strong>当address space以稀疏sparse的方式使用，而不是以连续的virtual address的方式使用时，工作地并不好</strong>。</p><blockquote><p>这里效果不好的原因（包括上一个方法），我的理解是这样的，因为page table的初始大小受到limit register的限制，当地址扩展时，page table的容量也会扩展，但是地址的扩展有两种方式：</p><ol><li>一是稳定地扩展，这样page table的容量也会稳定的增长，方法在这种场景下表现很好；</li><li>二是不稳定扩展，例如，第一次访问内存的virtual page number是page table的第一个，而第二次访问的virtual page number是最后一个，则会导致，page table的容量一下子从初始大小扩展到最大的容量，这种稀疏的内存地址扩展方式，使得这种方法效果不好。</li></ol></blockquote><h2 id="inverted-page-table"><a href="#inverted-page-table" class="headerlink" title="inverted page table"></a>inverted page table</h2><p>通过对virtual address 使用<code>hashing function</code>，可以减少page table的size。因为，此时page table中的entry的数量是physical  pages的数量，不是virtual pages的数量（两者之间，相差2个bit，则相差4倍）。这样的结构称为<code>inverted page table</code>。</p><p>但是这种结构中，对于page table的查找很复杂，因为不能通过virtual page number索引整个page table。</p><p>关于inverted page table的内容，可以继续参考如下材料：</p><ul><li><a href="https://web.eecs.umich.edu/~akamil/teaching/sp04/040104.pdf">https://web.eecs.umich.edu/~akamil/teaching/sp04/040104.pdf</a></li><li><a href="https://www.educative.io/answers/what-is-an-inverted-page-table-in-operating-systems">https://www.educative.io/answers/what-is-an-inverted-page-table-in-operating-systems</a></li><li><a href="http://gauss.ececs.uc.edu/Courses/c4029/code/memory/inv_pt.pdf">http://gauss.ececs.uc.edu/Courses/c4029/code/memory/inv_pt.pdf</a></li></ul><h2 id="multilevel-page-table"><a href="#multilevel-page-table" class="headerlink" title="multilevel page table"></a>multilevel page table</h2><p>通过多级page table可以减少page table占据的空间。这种方式可以忽略一些不需要内存page的地址，也就不需要进行地址转换，即，<strong>核心在于，我们只需要存储那些需要访问的内存地址的映射关系即可</strong>。</p><p>上述的方法中，不管内存地址是否会被使用，只要后续的地址被访问，其前面的内存映射关系就会占据page table存储空间，举例说明：当process访问地址0x00020000对应的内存时，那么在page table中一定会为0x00010000保存了映射关系需要的存储空间。</p><p>多级页表可以有效解决这个问题，首先先看一下多级页表的结构，本质上是一个多叉树，如下：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Virtual-Memory%EF%BC%884%EF%BC%89%EF%BC%9APage-table%E8%BF%87%E5%A4%A7%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/2.png" alt="多级页表的结构"></p><p>对于一个virtual address分成两个部分：</p><ul><li>对应multilevel page table的索引；</li><li>page offset</li></ul><p>一个对应multilevel page table的索引又分为了4个部分，分别对应不同level的page table的索引，每个索引占据5个bits。</p><ul><li>对于第4级索引，对应一个page table，该索引能找到该table中的一个entry，整个表共有 $2^5 = 32$个entries，每个entry中存储的并不是physical page number，而是下一级page table的地址，因此一个4th page table可以对应32个3rd page tables。对于一个32位的地址来说，每个entry需要占据4KiB的空间，因此4th page table需要占据 32*4 = 128KiB的空间。</li><li>当通过4th entry中的地址找到对应的3rd page table时，就可以通过3rd level的索引在该page table中找到2nd page table的地址。同样的，每个3rd page table也有32个entries，占据了128KiB的空间。</li><li>找到2nd page table后，可以通过2nd level的索引找到1rt page table，之后在该page table中找到对应的physical page number，其与page offset结合，共同组成真实的physical address。</li></ul><p>这就是整个virtual address被划分为多级索引，从而在多级page table中映射physical address的过程。前面我们说了multilevel page table能够减少存储空间，下面分析一下上述的结构共占据多少空间。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Virtual-Memory%EF%BC%884%EF%BC%89%EF%BC%9APage-table%E8%BF%87%E5%A4%A7%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/3.png" alt="多级页表占据的存储空间"></p><p>整个结构为一个多叉树：</p><table><thead><tr><th>level</th><th>page table数量</th><th>每个page table的entry数量</th><th>每个entry的大小</th><th>占据的总空间</th></tr></thead><tbody><tr><td>4</td><td>1</td><td>32</td><td>4KiB</td><td>128KiB</td></tr><tr><td>3</td><td>32</td><td>32</td><td>4KiB</td><td>4096KiB</td></tr><tr><td>2</td><td>32 * 32=1024</td><td>32</td><td>4KiB</td><td>131072KiB</td></tr><tr><td>1</td><td>32 * 32 * 32=32768</td><td>32</td><td>4KiB</td><td>4194304KiB</td></tr></tbody></table><p>将所有的占据空间加和得到：</p><p>$$<br>128 + 4096 + 131072 + 4194304 = 4329600 \text{KiB} = 4.129\text{GB}<br>$$</p><p>WTF？用了多级页表后，怎么page table占据的空间更大了？注意，这只是理论上的，实际当中，基本不会需要这么大的存储空间。这是因为局部性原理，程序运行时，stack是从上向下增长的，heap是从下向上增长的，也就是说内存地址的空间趋向于连续，这是<strong>空间局部性原理</strong>产生的效果。</p><p>这会造成什么影响？在多级页表中进行查询时，只会沿着特定的路径完成地址映射，如上图中的红色框图，也就是说，对于一个process而言，其使用的4th pt和3rd pt，甚至是2nd pt可能一直是同一个，这种情况下，只需要一级page table保持32个（占满，实际也有可能不会满），则占据的存储空间为：</p><p>$$<br>4 + 4 + 4 + 128 = 140 \text{KiB}<br>$$</p><p>相比于之前的4MB存储空间，大大减少了。</p><p>除了减少了存储空间，这种方法还有一个好处，尤其是相比上述的dynamic page table，即支持address space以稀疏sparse的方式使用，即便再稀疏，只会保存使用的page的地址映射关系，对于不需要的，则不会保存，这种支持特别有利于以非连续的方式分配address space的软件程序。</p><p>但是这种方法也有缺点：前面说过page table是驻留在内存中的，在之前的方法中，一个virtual page number对应一个physical page number，只需要访问一次内存就可以完成地址转换。现在分成了4个level的page tables，需要访问4次内存，理论上需要的地址转换时间是之前的4倍，不仅更复杂了，而且还需要更多的时间。这是典型的以时间换空间的策略。</p><h2 id="Make-page-tables-paged"><a href="#Make-page-tables-paged" class="headerlink" title="Make page tables paged"></a>Make page tables paged</h2><p>这种方法有时也称为virtualized page tables，核心思想在于将page table视为普通的内存。因此，也可以将page table放到virtual address space，但是这种方法会有严重的问题——never-ending series of page faults，详细内容可以参考以下资料：</p><ul><li><a href="https://stackoverflow.com/questions/50321686/how-virtualized-page-table-works">https://stackoverflow.com/questions/50321686/how-virtualized-page-table-works</a></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Computer Organization and Design - 5.7</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtual memory </tag>
            
            <tag> page table </tag>
            
            <tag> multilevel page table </tag>
            
            <tag> inverted page table </tag>
            
            <tag> virtualized page tables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的可变参数使用总结</title>
      <link href="/2022/11/03/bian-cheng-zhi-dao/c-zhong-de-ke-bian-can-shu-shi-yong-zong-jie/"/>
      <url>/2022/11/03/bian-cheng-zhi-dao/c-zhong-de-ke-bian-can-shu-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>当调用一个函数时，会遇到以下问题：</p><ul><li>提前不知道传入的参数的数量；</li><li>也不知道传入参数的类型；</li></ul><p>这种问题，在日志记录中最为明显：</p><ul><li>记录的日志的信息可能有多条；</li><li>记录的日志的数据类型也可以是不同的；</li></ul><h2 id="实践解决方式"><a href="#实践解决方式" class="headerlink" title="实践解决方式"></a>实践解决方式</h2><p>针对这些问题，在实践中，我一般都是封装为一个数据结构，在Java中使用JavaBeans。在C++中，也可以这么干，但是C++也提供了一些标准的操作方式，具体有以下几种：</p><ol><li>ellipsis …</li><li>initializer_list</li><li>variadic template</li></ol><h1 id="C-标准提供的解决方式"><a href="#C-标准提供的解决方式" class="headerlink" title="C++标准提供的解决方式"></a>C++标准提供的解决方式</h1><h2 id="ellipsis-…"><a href="#ellipsis-…" class="headerlink" title="ellipsis …"></a>ellipsis …</h2><p>在C++中，通过ellipsis实现可变参数。</p><ul><li>这种方式是用于与C语言的代码进行交互，除此之外，不应该在C++语言中使用这种方式。</li><li>具体的实现方式通过C语言中的<code>varargs</code>完成；</li><li>在函数声明中，可变参数只能是最后一个parameter，即如下两种形式之一：<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>param_list<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li><li>另外，不同于基本的函数参数，对于传入函数的可变参数，不会进行类型检查；</li></ul><h2 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>这种形式可以表示一组特定类型的参数，这些参数的类型唯一。</p><ul><li><p>可以将initializer_list类比于<code>vector&lt;T&gt;</code>，也是一种template type，因此在定义该类型的变量时，需要指定类型，如下：</p><pre class=" language-cpp"><code class="language-cpp">initializer_list<span class="token operator">&lt;</span>string<span class="token operator">></span> ls<span class="token punctuation">;</span></code></pre></li><li><p>但是，与<code>vector</code>不同的是，<code>initializer_list</code>中的值均为<code>const</code>，即无法修改；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> il<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1. error, 返回的是pointer to const int</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> il<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. ok</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> il<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>a<span class="token operator">:</span> il<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>  当用1处的代码初始化 *p时，会报以下的错误：</p><blockquote><p>error: invalid conversion from ‘std::initializer_list::const_iterator’ {aka ‘const int<em>’} to ‘int</em>’</p></blockquote><p>  使用2处的代码则ok。同样的，我们说initializer_list<int>中的数据为const，当使用for循环遍历时，使用如下代码，没有问题。其中的问题来自于auto关键字，参考<a href="https://lifehit.cn/2022/10/12/bian-cheng-zhi-dao/c-zhong-lei-xing-de-kun-rao/#toc-heading-6">这篇文章</a>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token operator">:</span> il<span class="token punctuation">)</span><span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>  主要原因在于，这里发生了copy，即出现<code>auto a = il中的每一项</code>，虽然il中的数据为const，但是为top level const，在使用auto时，top level const被忽略。</p><p>  但是如下的代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>a<span class="token operator">:</span> il<span class="token punctuation">)</span><span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>  由于auto中用到了reference，此时top level const不会忽略，因此出现如下错误：</p><blockquote><p>error: assignment of read-only reference ‘a’.</p></blockquote></li><li><p>使用<code>initializer_list</code>参数的函数也可以定义其他的parameters，而且不要求<code>initializer_list</code>参数是最后一个；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> il<span class="token punctuation">,</span> string s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token operator">:</span> il<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> il <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span> <span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span>il<span class="token punctuation">,</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><p>关于initializer_list的操作，与vector、数组有点类似，如下：<br><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/1.png" alt="关于initializer_list的操作"></p><p>其中，可以利用这些API对initializer_list进行遍历：</p><ul><li>基于for循环；</li><li>基于begin/end的指针操作；</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>string<span class="token operator">></span> il<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> beg <span class="token operator">=</span> il<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> beg <span class="token operator">!=</span> il<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>beg<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>beg <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="variadic-template"><a href="#variadic-template" class="headerlink" title="variadic template"></a>variadic template</h2><p>这部分是模板和泛型编程中的内容，C++ Primer - 16.4 Variadic Templates中有详细地介绍，鉴于还没学到模版编程，这里就先提一嘴，后续遇到后再展开。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Primer - 6.2.6 Functions with Varying Parameters</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ellipsis </tag>
            
            <tag> initializer_list </tag>
            
            <tag> variadic template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的函数参数传递</title>
      <link href="/2022/11/02/bian-cheng-zhi-dao/c-zhong-de-han-shu-can-shu-chuan-di/"/>
      <url>/2022/11/02/bian-cheng-zhi-dao/c-zhong-de-han-shu-can-shu-chuan-di/</url>
      
        <content type="html"><![CDATA[<p>在函数调用的时候，parameters被创建和初始化，初始化操作使用传递来的arguments完成。</p><blockquote><p>Arguments are the initializers for a function’s parameters.</p></blockquote><p>这里先要理解两个概念，对于一个<code>func</code>函数：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token punctuation">}</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>a称为parameter</li><li>b称为argument</li></ul><p>parameters的初始化与变量的初始化过程相同，因此在函数初始化中会遇到：</p><ul><li>直接copy数据</li><li>绑定到argument的reference</li></ul><p>这两种方式也分别对应两种函数传递方式：</p><ul><li>pass arguments by value</li><li>pass arguments by reference</li></ul><h1 id="Pass-arguments-by-value"><a href="#Pass-arguments-by-value" class="headerlink" title="Pass arguments by value"></a>Pass arguments by value</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>这种参数传递方式，有以下2个特点：</p><ul><li>传入函数内的argument会被copy为parameter；</li><li>在函数内对于copy的参数parameter的写操作，不影响外部的argument；</li></ul><p>这种函数传递方式是最简单的一种，例如上述的<code>func(int a)</code>就是这种参数传递类型。</p><h2 id="pointer作为函数参数"><a href="#pointer作为函数参数" class="headerlink" title="pointer作为函数参数"></a>pointer作为函数参数</h2><p>按理说，pointer类型的函数参数与其他的类型没啥不同，但是由于pointer指向一个变量的地址，因此会有一些不同的玩法，导致起到和pass arguments by reference的效果。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ip<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    ip <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>执行上述代码后，b = 100, ip变成空指针，但是不影响b的地址。而通过，更改 <code>*ip</code>可以起到按引用传递的效果。</p><blockquote><p>但是在C++中更推荐使用下文中的pass arguments by reference，而不是这种指针的用法。</p></blockquote><h1 id="Pass-arguments-by-reference"><a href="#Pass-arguments-by-reference" class="headerlink" title="Pass arguments by reference"></a>Pass arguments by reference</h1><p>这种参数传递方式的特点是：</p><ul><li>允许在函数内部改变argument中的数据；</li><li>不需要进行copy操作；</li></ul><h2 id="用reference作为参数避免copy"><a href="#用reference作为参数避免copy" class="headerlink" title="用reference作为参数避免copy"></a>用reference作为参数避免copy</h2><p>函数传递中的问题：</p><blockquote><p>It can be inefﬁcient to copy objects of large class types or large containers. More-over, some class types (including the IO types) cannot be copied.</p></blockquote><p>针对该问题，使用按引用传值，避免了资源不必要的copy。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isShorter</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h2 id="用reference作为参数返回更多信息"><a href="#用reference作为参数返回更多信息" class="headerlink" title="用reference作为参数返回更多信息"></a>用reference作为参数返回更多信息</h2><p>函数传递中的另一个问题：</p><blockquote><p>A function can return only a single value. However, sometimes a function has more than one value to return</p></blockquote><p>利用按引用传递，可以返回函数内部的多个操作结果，一般有两种方式：</p><ul><li>一个是定义多个parameters；</li><li>另一个是定义数据结构，如结构体、类等；</li></ul><h1 id="const-Parameters-amp-Arguments"><a href="#const-Parameters-amp-Arguments" class="headerlink" title="const Parameters &amp; Arguments"></a><code>const</code> Parameters &amp; Arguments</h1><h2 id="top-level-const的问题"><a href="#top-level-const的问题" class="headerlink" title="top-level const的问题"></a>top-level const的问题</h2><p>在之前关于<a href="https://lifehit.cn/2022/10/07/bian-cheng-zhi-dao/c-const-guan-jian-zi/">const的总结</a>中提到了top-level const和low-level const：</p><ul><li>top level const：对象自己是const；</li><li>low level const：对象指向的对象是const；</li></ul><p>在函数参数传递时，关于top-level const有几点注意事项：</p><ul><li><p>top-level const on parameters are ignored.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ok</span><span class="token function">func</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, top-level const is ignored.</span></code></pre></li><li><p>虽然top-level const被忽略了，但是在func中不能修改ii；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ii<span class="token punctuation">)</span><span class="token punctuation">{</span>    ii <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// error</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// error: assignment of read-only parameter ‘ii’</span></code></pre></li><li><p>top level const不影响函数类型，在<a href="https://lifehit.cn/2022/10/12/bian-cheng-zhi-dao/c-han-shu-zhi-zhen/">函数指针的总结</a>中提到了函数类型，由参数类型和返回值类型决定，因此相同函数名也视为不同的函数，但是top level const可以被忽略，因此不会对函数参数类型产生影响；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// error: redefinition of ‘void func1(int)’</span></code></pre><p>  因此，上述两个func1不是函数重载，而是完全一样。</p></li></ul><h2 id="当const遇到Pointer-amp-Reference"><a href="#当const遇到Pointer-amp-Reference" class="headerlink" title="当const遇到Pointer &amp; Reference"></a>当const遇到Pointer &amp; Reference</h2><p>既然函数参数的初始化与变量的初始化一致，因此也有一些通用的指导规则：</p><ul><li>对于有low level const的对象，可以通过非const对象来初始化，但是反过来不行；</li><li>引用类型的parameters初始化必须由相同类型的arguments完成；</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// for every call in the following</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">;</span>string<span class="token operator">::</span>size_type ctr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ok，调用2th func</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error, 不能使用pointer to const int初始化 pointer to int，违反了low-level const的原则</span><span class="token function">func</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// ok,，1st func</span><span class="token function">func</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// error，不能使用const int初始化plain reference</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// error, 不能使用literal初始化plain reference</span><span class="token function">func</span><span class="token punctuation">(</span>ctr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error, mismatched type</span></code></pre><h2 id="推荐：使用referecne-to-const作为函数parameters"><a href="#推荐：使用referecne-to-const作为函数parameters" class="headerlink" title="推荐：使用referecne to const作为函数parameters"></a>推荐：使用referecne to const作为函数parameters</h2><p>在函数参数中使用按引用传递参数的方式，可能会导致以下问题：</p><ul><li>暗示函数调用者，可以改变该引用绑定的值，引起错误；</li><li>限制了能传入到该参数中的arguments的类型；<br>  如上例所示，调用 <code>func(int &amp;r)</code>时:<ul><li>不能传入42等字面值；</li><li>const int类型；</li><li>或者size_type等可以自动转换的类型；<blockquote><p>出现：error: cannot bind non-const lvalue reference of type ‘int&amp;’ to an rvalue of type ‘int’<br>基于上述问题，因此在函数传递时，推荐使用reference to const。</p></blockquote></li></ul></li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Primer - 6.2.1 Passing Arguments by Value</li><li>C++ Primer - 6.2.2 Passing Arguments by Reference</li><li>C++ Primer - 6.2.3 const Parameters and Arguments</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pointer </tag>
            
            <tag> 按值传递 </tag>
            
            <tag> 按引用传递 </tag>
            
            <tag> argument passing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的字符串</title>
      <link href="/2022/10/31/bian-cheng-zhi-dao/c-zhong-de-zi-fu-chuan/"/>
      <url>/2022/10/31/bian-cheng-zhi-dao/c-zhong-de-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>A string is a variable-length sequence of characters.</p></blockquote><p>使用C++中的string，必须包含<code>&lt;string&gt;</code>，而且相比于C语言中的char *，更推荐使用C++中的写法，更有效率，不容易出错。</p><h1 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h1><blockquote><p>Each class deﬁnes how objects of its type can be initialized.</p></blockquote><p>string的初始化可以分为两种：</p><ul><li>copy initialize</li><li>direct initialization</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// direct initialization</span>string s1<span class="token punctuation">;</span>string <span class="token function">s4</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// copy initialize</span>string <span class="token function">s2</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>string s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>string <span class="token function">s3</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// s3 have no '\0' like char *.</span>string s3 <span class="token operator">=</span> <span class="token string">"value"</span><span class="token punctuation">;</span></code></pre><h1 id="string的读写"><a href="#string的读写" class="headerlink" title="string的读写"></a>string的读写</h1><p>从控制台读取string，使用<code>cin</code>，读入的string被空格截断，即输入“hello world”，只会将hello放到s中。</p><pre class=" language-cpp"><code class="language-cpp">string s<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// empty string</span>cin <span class="token operator">>></span> s<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// read a whitespace-separated string into s</span>string s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// read ﬁrst input into s1, second into s2</span>cin <span class="token operator">>></span> s1 <span class="token operator">>></span> s2<span class="token punctuation">;</span>string word<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// read until end-of-ﬁle, use ctrl+c to stop</span><span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> word<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// write each word followed by a new line</span>    cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> </code></pre><p>除了使用<code>cin</code>，还可以使用<code>getline</code>读入整行，但是读入的string中不包含<code>\n</code>。</p><pre class=" language-cpp"><code class="language-cpp">string line<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// read input a line at a time until end-of-ﬁle </span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>    cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><h1 id="string的相关运算"><a href="#string的相关运算" class="headerlink" title="string的相关运算"></a>string的相关运算</h1><h2 id="判断大小"><a href="#判断大小" class="headerlink" title="判断大小"></a>判断大小</h2><ul><li><code>empty()</code></li><li><code>size()</code></li></ul><pre class=" language-cpp"><code class="language-cpp">string line<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>line<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>这里要注意的一点是<code>size()</code>返回的不是<code>int</code>，而是<code>string::size_type</code>，这是一个unsigned的整数，is a companion type. These companion types make it possible to use the library types in a machine-independent manner. 这里容易出问题的是有符号数与无符号数的转换，会出现奇怪的现象。</p></blockquote><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><ul><li>比较是大小写敏感的；</li><li>支持的操作符包括：==、!=、&lt;、 &lt;=、 &gt;、 &gt;=</li><li>遵循以下原则：<ul><li>Two strings are equal if they are the same length and contain the same characters.</li><li>If two strings have different lengths and if every character in the shorter string is equal to the corresponding character of the longer string, then the shorter string is less than the longer one.</li><li>If any characters at corresponding positions in the two strings differ, then the result of the string comparison is the result of comparing the ﬁrst character at which the strings differ.</li></ul></li></ul><pre class=" language-cpp"><code class="language-cpp">string str <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span> string phrase <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>string slang <span class="token operator">=</span> <span class="token string">"Hiya"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// str &lt; phrase &lt; slang</span></code></pre><h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><ul><li>加法等于字符串拼接<pre class=" language-cpp"><code class="language-cpp">string s1 <span class="token operator">=</span> <span class="token string">"hello, "</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token string">"world\n"</span><span class="token punctuation">;</span>string s3 <span class="token operator">=</span> s1 <span class="token operator">+</span> s2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// s3 is hello, world\n </span>s1 <span class="token operator">+</span><span class="token operator">=</span> s2<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// equivalent to s1 = s1 + s2</span></code></pre></li><li>literal与string的加法中，<code>+</code>左右必须有一个是string对象；<pre class=" language-cpp"><code class="language-cpp">string s1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>string s3 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> s2 <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>string s4 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">", "</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// ok</span>string s5 <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">", "</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// error</span>string s6 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> <span class="token string">"world"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// ok</span>string s7 <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> s2<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// error  </span></code></pre></li></ul><h1 id="string与char"><a href="#string与char" class="headerlink" title="string与char"></a>string与char</h1><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>在遍历中，又分为两种：</p><ul><li>不修改<pre class=" language-cpp"><code class="language-cpp">string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">"some string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li>修改<pre class=" language-cpp"><code class="language-cpp">string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"Hello World!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>c <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    c <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h2 id="操作单个char"><a href="#操作单个char" class="headerlink" title="操作单个char"></a>操作单个char</h2><p>在遍历中，或者直接操作string中的特定char，可以通过<code>[]</code>，类似数组，以0为开始。在访问的过程中，还可以对char进行判断，以便采取相关操作。</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/1.png" alt="针对char的操作"></p><p>这些函数来自于C语言中的<code>ctype.h</code>和C++中的<cctype>，使用时直接<code>#include</code>。</p><h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p>除了上述的最常用的内容，在<strong>C++ Primer的9.5</strong>还描述了一些额外的操作，但是并不太常用，包括：</p><ul><li>更复杂的初始化函数；</li><li>更多的改变string的函数</li><li>搜索字符串的函数</li><li>比较string的函数</li><li>string与其他类型的转换函数</li></ul><p>如果需要，可以去查阅。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C++ Primer - 3.2 Library string Type</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> string </tag>
            
            <tag> 字符数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan的Execution Model</title>
      <link href="/2022/10/30/ji-suan-ji-tu-xing-xue/vulkan/vulkan-de-execution-model/"/>
      <url>/2022/10/30/ji-suan-ji-tu-xing-xue/vulkan/vulkan-de-execution-model/</url>
      
        <content type="html"><![CDATA[<h1 id="vulkan执行中涉及的几个组件"><a href="#vulkan执行中涉及的几个组件" class="headerlink" title="vulkan执行中涉及的几个组件"></a>vulkan执行中涉及的几个组件</h1><h2 id="Device"><a href="#Device" class="headerlink" title="Device"></a>Device</h2><p>为了渲染图形，计算机中必须有显卡，或者独立显卡或者集成显卡，这些都是<code>PhysicalDeivce</code>，而在vulkan的术语环境下，这个<code>PhysicalDeivce</code>指的是支持vulkan的具体的物理设备。</p><p>同样地，为了在各种应用中表示该<code>PhysicalDevice</code>，vulkan中引入<code>Device</code>的概念，它是一个抽象的logical representation。</p><p>对于在应用中使用时，对于vulkan兼容的<code>PhysicalDeivce</code>（指的是通过vulkan的API可以操作该设备），我们要find；对于<code>Device</code>，我们要create。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><code>Queue</code>在数据结构中是先入先出的特性。根据这一点，在很多的消息队列中广泛使用，比如：生产者-消费者模型，尤其是多线程的环境下。如果你了解这一点，对于vulkan中<code>Queue</code>发挥的作用，就不会陌生了。</p><p>在vulkan中，<code>Queue</code>是execution engine和application之间的interface：</p><ul><li>application是command的生产者；</li><li>execution engine是command的消费者；</li></ul><p>具体来说，<code>Queue</code>的责任在于收集所有来自应用的commands,application将command提交到<code>Queue</code>，然后execution engine取走调度执行。</p><p>一个<code>PhysicalDevice</code>包含很多的<code>Queue</code>，每个<code>Queue</code>可能有不同的功能，这里的功能不同，我理解是：特定的<code>Queue</code>只能接受特定的command，比如：内存操作、并行计算等。</p><h3 id="Family"><a href="#Family" class="headerlink" title="Family"></a>Family</h3><p>按照功能不同，这些<code>Queue</code>并划分到<code>Family</code>，这样一组<code>Queue</code>内形成的<code>Family</code>内，支持多种功能的<code>Queue</code>：</p><ul><li>video decode；</li><li>video encode；</li><li>graphics（重点使用）；</li><li>compute（并行计算，深度学习模型等）；</li><li>transfer；</li><li>sparse memory management；</li></ul><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><p><code>Command</code>即application发出的，用来命令GPU执行的操作指令。一般可以分为3种类型：</p><ul><li><p>action</p><p>这是真正要工作的<code>Command</code>，利用GPU等绘制图形，拷贝buffer等。</p></li><li><p>state</p><p>这种类型的<code>command</code>，是用来对一些状态进行管理的，比如一些descriptor sets、buffers等。</p><blockquote><p>对descriptor sets、buffers等不了解很正常，提一下，后续会深入学习，学一个东西总是不断有新的名词冒出来，开始时很恼火，不过后来就习惯了。</p></blockquote></li><li><p>synchronization</p><p>这种command更多的是用来协调各种<code>Action command</code>，尤其是这些command对一些公共资源竞争时，或者彼此之间存在依赖关系，需要对它们进行排布，以更好地完成工作。</p></li></ul><h3 id="Command-buffer"><a href="#Command-buffer" class="headerlink" title="Command buffer"></a>Command buffer</h3><ul><li>a collection of commands</li><li>records the commands and submit them to queues</li></ul><h1 id="vulkan执行模型"><a href="#vulkan执行模型" class="headerlink" title="vulkan执行模型"></a>vulkan执行模型</h1><h2 id="简要过程"><a href="#简要过程" class="headerlink" title="简要过程"></a>简要过程</h2><p>vulkan中简要的执行过程如下图所示：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84Execution-Model/1.png" alt="vulkan的执行模型"></p><ol><li>application选择支持vulkan API的<code>PhysicalDevice</code>；</li><li>application创建<code>Device</code>来代表选择的<code>PhysicalDevice</code>；</li><li>根据自己的需求，选择<code>PhysicalDevice</code>中包含的特定<code>Queue</code>；</li><li>application发出的<code>Command</code>被记录在<code>Command Buffer</code>中；</li><li>之后，这些<code>Command buffer</code>被提交到<code>Queue</code>中；</li><li><code>PhysicalDevice</code>消费这些command，命令GPU执行对应的操作；</li><li>最后，<code>PhysicalDevice</code>将处理的结果显示到屏幕上，或者返回给application。</li></ol><h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><h3 id="command-buffer-construction-is-expensive"><a href="#command-buffer-construction-is-expensive" class="headerlink" title="command buffer construction is expensive"></a>command buffer construction is expensive</h3><p>在这个过程中，<code>command buffer</code>要接受application提交的<code>command</code>，之后再submit给对应的<code>queue</code>。但是<code>command buffer</code>的构造是昂贵的，这里中的昂贵一般指时间占用或者资源使用上的，因此要缓存下来重用。而且，很多的<code>command buffer</code>可以通过多线程并发构造。</p><h3 id="application是execution顺利进行的主要责任人"><a href="#application是execution顺利进行的主要责任人" class="headerlink" title="application是execution顺利进行的主要责任人"></a>application是execution顺利进行的主要责任人</h3><p>在之前说到Vulkan与OpenGL等的一个重要的不同在于——驱动的很大一部分工作交给了application完成，具体有：</p><ul><li>为<code>command</code>的顺利执行准备必要的条件；<ul><li>prepare resources</li><li>precompile shaders</li><li>attach the resources to shaders</li><li>specify render states</li><li>build a pipeline</li><li>call draw operations</li></ul></li><li>memory management</li><li>synchronization<ul><li>在不同的<code>queue</code>之间同步；</li></ul></li><li>Error checking</li></ul><h3 id="Queue的实际执行过程"><a href="#Queue的实际执行过程" class="headerlink" title="Queue的实际执行过程"></a>Queue的实际执行过程</h3><p>作为<code>command buffer</code>和<code>PhysicalDevice</code>的中介，负责沟通application和实际的GPU，<code>Queue</code>的实际执行过程影响了GPU的执行。</p><p>对于记录到<code>command buffer</code>中的一系列<code>command</code>，可以提交到：</p><ul><li><p>single queue</p><p>对于提交到一个queue的多个<code>command buffer</code>，它们后续执行的顺序与它们提交的顺序保持一致，严格恪守先入先出的规则；</p></li><li><p>multiple queue</p><p>但是当多个<code>command buffer</code>同时提交到多个<code>queue</code>时，它们的执行顺序默认情况下，是没有保证的。如果application想要控制它们的执行顺序，需要自己完成同步的操作。</p></li></ul><p>Vulkan中有多种保证同步的primitives，可以保证一个或者多个<code>queue</code>中<code>command buffer</code>的执行顺序：</p><ul><li>Semaphore</li><li>Events</li><li>Fences</li><li>Pipeline barriers</li></ul><p>这些同步机制在后续的学习中可能会有深入地阐述。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap3.html#fundamentals-execmodel">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap3.html#fundamentals-execmodel</a></p></li><li><p>Learning Vulkan - Chapter 1 - Learning the fundamentals of Vulkan</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
            <tag> Application </tag>
            
            <tag> Queue </tag>
            
            <tag> Device </tag>
            
            <tag> Command buffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Virtual Memory（3）：Page fault</title>
      <link href="/2022/10/30/ji-suan-ji-ji-chu/virtual-memory-3-page-fault/"/>
      <url>/2022/10/30/ji-suan-ji-ji-chu/virtual-memory-3-page-fault/</url>
      
        <content type="html"><![CDATA[<h1 id="Page-fault的基本内容"><a href="#Page-fault的基本内容" class="headerlink" title="Page fault的基本内容"></a>Page fault的基本内容</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>回顾cache中的miss，page fault表示的是同样的含义，只不过page fault一般是在main memory中miss，从而需要访问disk。这其中的时间差远远高于cache和main memory之间的时间差。</p><h2 id="如何判断发生了page-fault"><a href="#如何判断发生了page-fault" class="headerlink" title="如何判断发生了page fault"></a>如何判断发生了page fault</h2><p>在page table中有一个valid bit，当GPU发出的指令中，使用的virtual address中的virtual page number，用来定位page table中的一个entry时，检查该entry的valid bit，如果为1，则发生了page fault。</p><h1 id="Page-fault时发生了啥"><a href="#Page-fault时发生了啥" class="headerlink" title="Page fault时发生了啥"></a>Page fault时发生了啥</h1><h2 id="如何处理page-fault"><a href="#如何处理page-fault" class="headerlink" title="如何处理page fault"></a>如何处理page fault</h2><p>发生page fault后，virtual page number找不到对应的physical page number，此时触发异常。操作系统接过控制权，需要完成两件事：</p><ol><li>到memory的下层存储disk中找到对应于virtual page number的page；</li><li>将来自disk的page放到main memory中；</li></ol><h2 id="2个问题"><a href="#2个问题" class="headerlink" title="2个问题"></a>2个问题</h2><p>这里自然遇到了2个问题？</p><ol><li>如何找到virtual page number在disk中对应的page？</li><li>如何替换physical memory中的page以放置来自disk的page？</li></ol><h3 id="针对问题1"><a href="#针对问题1" class="headerlink" title="针对问题1"></a>针对问题1</h3><p>到目前为止，不管是virtual address与physical address直接映射，还是通过page table加快映射，都不涉及disk。但是现在出现了page fault，<strong>为了找到virtual page number对应的来自disk的page，因此需要记录两者之间的映射关系</strong>，如下图所示。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Virtual-Memory%EF%BC%883%EF%BC%89%EF%BC%9APage-fault/1.png" alt="Virtual address同时映射到Physical address和Disk"></p><p>这里通过page table分别维护了两种映射关系：</p><ul><li>virtual page number 到 physical page number；</li><li>virtual page number 到page address in disk；</li></ul><blockquote><p>有时，这两种映射关系是两个数据结构分别维护的，但是逻辑上看是一张表。</p></blockquote><p>在这里要澄清一个问题，在page table中，如果不出现page fault(valid bit=1)时，是否不需要维护virtual page number到page address in disk的关系？仍然需要，<strong>即需要对于所有的virtual page维护一个page address in disk的映射关系，无论它们当时是否page fault</strong>，因为我们不知道后续的执行中，哪个virtual page又会出现page fault（比如别的程序把main memory都占满了）。</p><p>这种操作通过操作系统在创建process时，同时在disk中创建<code>swap space</code>实现。此时，把virtual page number映射到disk的关系也全部记录下来。</p><h3 id="针对问题2"><a href="#针对问题2" class="headerlink" title="针对问题2"></a>针对问题2</h3><p>我们知道在memory hierarchy中，只有相邻的两个level之间才能传递数据，因此，即便virtual page number映射到page address in disk，也不能访问，需要将disk中的page放到physical memory中，进行访问。</p><p>前面介绍page table时提到，为了减少page fault，我们允许将virtual page映射到任意的physical page。当需要将disk中的page加载到physical memory时，有两种情况：</p><ol><li>physical memory未满，可以直接将disk中的page选择一个放入其中，因为是fully associative；</li><li>physical memory已满（很多程序同时运行时），操作系统需要在physical memory中选择一个page进行替换。</li></ol><p>第一种情况很简单，直接将disk中的page写入即可。</p><p>第二种情况则比较复杂，为了最大程度上减少page fault的发生，应该尽量保证替换的physical page后续不会被访问，这里又用到了之前replacement policy中提到的LRU。因此，在这个过程中发生两步：</p><ol><li>操作系统基于replacement policy（如LRU）替换虚选择的physical page；</li><li>同时，这个选择的physical page中的数据也要写回到disk中对应的swap space，以保证数据不会丢失；</li></ol><h3 id="virtual-memory中的replacement-policy"><a href="#virtual-memory中的replacement-policy" class="headerlink" title="virtual memory中的replacement policy"></a>virtual memory中的replacement policy</h3><p>前面也提到过，实现LRU很昂贵，因为每访问一次memory，都需要更新一次数据结构。面对这种问题，这里使用一种近似的方法来解决。</p><p>在physical page中设置一个reference bit(use bit)，当该physical page被访问，这个标识被设置为1。但是，操作系统在固定的时间段内不断地清除该bit，之后继续记录每个page的reference bit。</p><p>这种操作有什么用？举例说明，当第一次访问该page时，reference bit=1，之后被操作系统清0，之后在替换page时，发现该page的reference bit还是1，说明该page最近被访问了，它最好不要替换。这里边对于清0的时间间隔决定该page被访问的“有多近”。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Computer Organization and Design - 5.7 - Page faults</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtual memory </tag>
            
            <tag> page fault </tag>
            
            <tag> page table </tag>
            
            <tag> LRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Virtual Memory（2）：使用page table加快page的查找</title>
      <link href="/2022/10/30/ji-suan-ji-ji-chu/virtual-memory-2-shi-yong-page-table-jia-kuai-page-de-cha-zhao/"/>
      <url>/2022/10/30/ji-suan-ji-ji-chu/virtual-memory-2-shi-yong-page-table-jia-kuai-page-de-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>回顾在cache中，我们是如何降低miss rate的——<a href="https://lifehit.cn/2022/10/26/ji-suan-ji-ji-chu/cache-de-xing-neng-diao-you-2-set-associative/">set associative</a>。核心在于设计一个合理的placement schema。在virtual memory中则遇到了相同的问题，如何减少<code>page fault</code>？简单来说，就是保证virtual address都能映射到physical address，而不是到disk中。</p><h1 id="Page-table的提出"><a href="#Page-table的提出" class="headerlink" title="Page table的提出"></a>Page table的提出</h1><p>为了减少page fault，这里想到的最极端的方式，就是之前的<code>fully associative</code>，当出现<code>page fault</code>时，可以将virtual page替换为任意的physical page。但是，前面也说到这种方法虽然可以很大程度上减少miss或page fault，但是当进行查找时，效率低下，需要比较cache中的每一个line，或者physical memory中的每一个page。</p><p>为了解决这个问题，在virtual memory中使用——page table：</p><ul><li>该table通过virtual page number进行索引；</li><li>它保存virtual page和physical page的映射信息，将virtual page number映射到physical page number；</li><li>page table中的virtual page number不一定存在对应的physical page number，这时发生了page fault；</li><li>作为索引，这个table存储在memory中；<blockquote><p>这里先假设，这个table存储在memory中的一段固定且连续的区域（其实实际上不是这样）。</p></blockquote></li><li>每个程序（或者进程）有自己的page table；</li><li>为了定位page table中的数据，硬件中还有一个register来指向每个程序page table的起始位置，称为<code>page table register</code>。</li></ul><p>到这里，我们解决了fully associative在查找时的问题，通过建立一个索引结构，从而可以减低page fault。</p><h1 id="Page-Table的组成"><a href="#Page-Table的组成" class="headerlink" title="Page Table的组成"></a>Page Table的组成</h1><p>page table的组成示意图如下所示：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Virtual-Memory%EF%BC%882%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8page-table%E5%8A%A0%E5%BF%ABpage%E7%9A%84%E6%9F%A5%E6%89%BE/1.png" alt="Page table的结构示意图"></p><ul><li>首先看一下page table register，直接指向page table的首地址，因此一个register可以直接确定page table的位置；</li><li>不同于fully associative中，需要使用virtual page number与physical page number直接对比，来确定是否page fault，这里在page table中存在一一映射关系；</li><li>与cache结构的异同：<ul><li>也有valid bit，可以帮助快速判断是否存在page fault；<ul><li>当bit=1，virtual page有对应的physical page，无page fault；</li><li>bit=0，出现page fault；</li></ul><blockquote><p>这里与cache有一点不同，在page table中，只要你找到virtual page number对应的entry，之后只需验证该valid bit就能知道有无page fault。但是，在cache中，当知道index对应的cache line时，即便验证了valid bit，还不能确定是否hit，还需要继续验证tag field，如果匹配，则hit，否则miss，因为cache中将memory的地址拆成了index和tag两个部分。</p></blockquote></li><li>没有tag field，因为不同于cache中，一个cache line可以对应多个memory block（direct mapped cache），因此使用tag代表高位地址。在page table中，每个virtual page与physical page是一对一的，甚至是多对一的，因此不需要tag字段；</li><li>在page table中充当index的也不是memory的低位地址，而是直接使用virtual page number；</li></ul></li><li>在上图中，page table中的entry共有 $2^{19}$ 个。即 virtual page number的位数减去valid bit的位数，但是实际中一般设计为32位。</li></ul><h1 id="进程之间的切换"><a href="#进程之间的切换" class="headerlink" title="进程之间的切换"></a>进程之间的切换</h1><p>多任务执行一直是一个吸引人的目标，在早期的单核时代，为了并行执行，需要将CPU的时钟切成小段的时间片，分配给不同的程序使用。这里就存在一个问题，当一个程序使用的时间片结束后，如何切换到另一个程序执行呢？</p><p>程序的执行需要指令和数据，当切换到另一个程序继续执行时，核心就是要找到该程序的指令和数据存储位置。在virtual memory中，我们知道CPU提出的指令中都是virtual address，因此切换程序中需要找到该程序对应的virtual address，来映射到physical address，也就是page table。</p><p><code>page table</code>、<code>program counter</code>和相关的寄存器，指定了一个<code>state</code>，这个状态可以在切换程序执行时，用于恢复原来<code>process</code>的运行状态。操作系统通过加载该process对应的state，可以使该process变成active，从而继续执行。</p><p>操作系统不会加载process的完整的page table，而是加载page table register即可，就能定位整个page table，节省空间。</p><p>每个process都有自己的page table，因此不同的process可以用相同的virtual address。这些virtual address与physical address的映射，由操作系统来分配和更新，这样使得不同的process之间不会冲突。这样，page table的加入使得对于多个程序同时执行任务更加方便，而不会在访问内存时出现冲突。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Computer Organization and Design - 5.7 - Placing a Page and Finding It Again</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fully associative </tag>
            
            <tag> virtual memory </tag>
            
            <tag> page fault </tag>
            
            <tag> page table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Virtual Memory（1）：简介</title>
      <link href="/2022/10/29/ji-suan-ji-ji-chu/virtual-memory-1-jian-jie/"/>
      <url>/2022/10/29/ji-suan-ji-ji-chu/virtual-memory-1-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h1><blockquote><p>virtual memory: A technique that uses main memory as a “cache” for secondary storage.</p></blockquote><p>通俗的说，将一个整体的存储结构包装起来，让外部的使用者只将其视为main memory，至于内部是不是真实的main memory，则并不关心。为了区分于virtual memory，真实的main memory称为<code>physical memory</code>。</p><p>那，virtual memory这种技术提出，是要解决什么问题呢？</p><ol><li>在多个程序之间实现对内存高效、安全地共享；<blockquote><p>最早是为了解决time-sharing systems中共享资源的问题。</p></blockquote><ul><li>我们希望每个程序只能使用分配给它的内存，不能访问别的程序的内存；</li><li>但是，程序在运行时才能知道访问哪些内存空间，因此，我们需要在compile的时候就确定，每个程序只能在自己的<code>address space</code>中活动，这个space别的程序也无法访问；</li><li>virtual memory将每个程序的<code>address space</code>映射到真实的<code>physical address</code>；</li></ul></li><li>当面对小容量的内存时，解放开发人员，提高生产力；<ul><li>早期，内存很小，程序需要使用的内存甚至超过总的内存容量，这时需要开发人员小心应对，保证程序中对不同内存的访问不会冲突；</li></ul></li></ol><p>虽然技术的进步，内存容量越来越大，显然第2个问题不再是问题，那virtual memory主要是为了解决第1个问题而发展至今的。</p><h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p>virtual memory中提到的概念与cache中概念的含义差不多，但是有不同的叫法。</p><p>由于virtual memory是用main memory作为cache，那么cache中存在的一些术语在virtual memory也会存在。如在cache中有<code>cache line</code>或者<code>block</code>，但是在virtual memory中则称为<code>page</code>，当出现miss之后，称为<code>page fault</code>。</p><h2 id="address-mapping概述"><a href="#address-mapping概述" class="headerlink" title="address mapping概述"></a>address mapping概述</h2><p>在virtual memory中，CPU等处理器发出的指令中使用的都是<code>virtual address</code>，为了实际执行操作，需要将其转换为对应的<code>physical address</code>，来访问对应的内存，这个过程称为<code>address mapping</code> 或者 <code>address translation</code>。</p><p>在virtual memory被采用之前，各个程序（进程）之间为了避免访问的内存空间出现冲突，需要约定好每个程序访问内存的位置，最好是一段连续的内存空间，以避免冲突，方便管理。</p><p>但是，当出现了virtual memory之后，每个程序不一定要占据一段连续内存，只要virtual address看起来连续就行。这是通过<code>relocation</code>技术解决的。</p><p>这里举个不恰当的例子，你要一台服务器训练模型，在没有云服务器之前，你要自己买各种设备组件，然后搭建使用，还要满足内存和硬盘的要求。但是，现在有了云服务器，直接使用云服务器就行，你的那些要求可以满足，但是不是一直满足，比如当你不用服务器的时候，可能内存就不满足你的要求了，但是自己搭建的会一直满足要求。</p><p>virtual memory将CPU发出的指令用到的内存，relocate到一系列固定大小的<code>page</code>，在使用者看来，这满足了他的要求，但是实际上分配的<code>physical address</code>可以散落在<code>physical memory</code>上的各处。而现在的核心问题不是找到连续的内存空间，而是找到足够的<code>page</code>。</p><h2 id="实现address-mapping"><a href="#实现address-mapping" class="headerlink" title="实现address mapping"></a>实现address mapping</h2><p>virtual address包含2个部分：</p><ul><li>virtual page number：组成virtual address的高位</li><li>page offset：组成virtual address的低位，其位数代表main memory中每个page的大小；</li></ul><p>那么如何将virtual address映射为physical address呢？</p><ul><li>首先，virtual page number映射为physical page number，这两者可以不同，而且一般都不同。<ul><li>并且，virtual pages一般多于physical pages，这会导致出现多对一的情况，即多个virtual address映射到一个physical address，这不是冲突了吗？有什么用？如果你学过操作系统，可能会知道进程之间的通信方法，其中有一个共享内存，就是这一原理。  <img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Virtual-Memory%EF%BC%881%EF%BC%89%EF%BC%9A%E7%AE%80%E4%BB%8B/1.png" alt="共享内存"><blockquote><p>在学习计算机组成原理的过程中，发现一些知识不断和之前了解的内容有联系，这种感觉很爽！</p></blockquote></li><li>由于virtual pages更多，不能完全映射到physical pages，这时怎么办？根据上述的概念，此时出现了<code>page fault</code>，即对page的访问发现不在main memory中，那么就需要映射到更下一层的硬盘中。</li></ul><blockquote><p>有一个问题，现在计算机地址至少都有32位，除去page offset可能有4KiB(12 bits)，可以有4GiB的虚拟内存，但是现在物理内存动辄16GiB或者32GiB，这种从虚拟地址到物理地址的映射是不是没有意义了？对于一个程序或者一个进程来说，意义确实不大了，但是当成千上万个程序同时运行时，仍然需要virtual memory来管理这些程序对内存的共享。想想一个chrome就有多少个进程！</p></blockquote></li><li>之后，映射page offset，这一项是完全相同的，因为是用于定位一个page内的数据项；</li></ul><p>总结，address mapping如下：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Virtual-Memory%EF%BC%881%EF%BC%89%EF%BC%9A%E7%AE%80%E4%BB%8B/2.png" alt="Address mapping示意图"></p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Virtual-Memory%EF%BC%881%EF%BC%89%EF%BC%9A%E7%AE%80%E4%BB%8B/3.png" alt="具体address mapping过程"></p><p>在上述的mapping中：</p><ul><li>每个page是 $2^{12}$=4KiB；</li><li>virtual memory中共有$2^{20}$个pages = 4GiB；</li><li>physical memory中共有$2^{18}$个pages = 1GiB；</li></ul><h1 id="virtual-memory的设计原则"><a href="#virtual-memory的设计原则" class="headerlink" title="virtual memory的设计原则"></a>virtual memory的设计原则</h1><p>virtual memory作为下一层存储器的“cache”，核心问题和cache的一样，尽力避免<code>page fault(miss)</code>。因为不同于cache与main memory之间只差几十倍，在main memory和disk之间的访问时间可以相差几十万倍，毕竟一个是机械运动。</p><p>考虑到page fault的问题，有几个设计原则：</p><ul><li>page最好设计的大一点；<ul><li>利用空间局部性，减少访问次数，以避免过高的访问时间，与增加cache中的block size的作用是一样的。</li></ul></li><li>使用的placement schema需要减少page fault；<ul><li>在之前提到的最能减少page fault(miss)的placement schema是fully associative。</li></ul></li><li>设计软件减少page fault虽然也会带来负担，但是相比于对disk的访问，还是可以接受的。</li><li>对于virtual memory，write-through不适合，而是用write-back；<ul><li>因为对disk的写入太耗时间了；</li></ul></li></ul><h1 id="page-vs-segment"><a href="#page-vs-segment" class="headerlink" title="page vs. segment"></a>page vs. segment</h1><p>到目前为止，不管是在cache还是在virtual memory中使用的block还是page，都是固定大小的。但是，还是有block（page）长度可变的scheme——segmentation。它是一种可变长度的address mapping scheme。</p><p>在segmentation中：</p><ul><li>由<code>segment number</code>和<code>segment offset</code>组成；</li><li><code>segment number</code>映射到physical address；</li><li><code>segment offset</code>映射到地址内的更具体的位置；</li></ul><p>由于长度不固定，因此需要进行bounds check，保证segment offset在segment内；而且这种划分在逻辑上将address space分成了2部分，使得开发人员和compiler处理起来很麻烦。不像paging，对于开发人员和compiler几乎透明，不用考虑。</p><p>segment的使用场景包括：支持对address space的protection。</p><blockquote><p>这里说的protection指的是一系列的机制，可以保证多个进程对于main memory共享没有问题，不会因为读写的冲突而相互干扰。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Computer Organization and Design - 5.7</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtual memory </tag>
            
            <tag> physical memory </tag>
            
            <tag> address mapping </tag>
            
            <tag> page </tag>
            
            <tag> page fault </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache的性能调优（3）：减少miss penalty-multilevel cache</title>
      <link href="/2022/10/27/ji-suan-ji-ji-chu/cache-de-xing-neng-diao-you-3-multilevel-cache/"/>
      <url>/2022/10/27/ji-suan-ji-ji-chu/cache-de-xing-neng-diao-you-3-multilevel-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="Multilevel-cache"><a href="#Multilevel-cache" class="headerlink" title="Multilevel cache"></a>Multilevel cache</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在内存系统中，为了弥补CPU访问内存的性能限制，采用了memory hierarchy的设计。同样的，在cache中，为了miss penalty，也可以采用这种策略——multilevel cache。</p><ul><li>当第一层cache中发生了miss，第二层的cache就会被访问，这种大大减少了因对memory的访问造成的性能问题；</li><li>但所有的cache均出现miss时，才会访问main memory；</li></ul><blockquote><p>这种策略，同时考虑了成本和技术需求，在很多的问题上都是一样的思路。</p></blockquote><h2 id="设计考虑因素"><a href="#设计考虑因素" class="headerlink" title="设计考虑因素"></a>设计考虑因素</h2><p>对于一个层次化的cache结构，与设计单个cache使用的策略是很不同的。</p><ul><li>对于第一层cache，着重解决减少hit time的问题；  一般来说，该层的cache容量，相比于单级的cache，都很小，比如block size很小；</li><li>第二层的cache着重解决减少miss penalty，以避免访问main memory；  第二层的cache则一般使用较大的cache size，比如设计较大的block size，以降低 miss rate，比如可以将set associative中每个set中cache lines的数量增加。</li></ul><h1 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h1><h2 id="80486的高速缓存"><a href="#80486的高速缓存" class="headerlink" title="80486的高速缓存"></a>80486的高速缓存</h2><ul><li>80486采用指令和数据共用的8KB Cache；</li><li>缺陷：指令和数据的局部性相互影响；<ul><li>例如：一个数据密集的程序会很快占满Cache，几乎没有空间用于指令；</li></ul></li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%883%EF%BC%89%EF%BC%9Amultilevel-cache/1.png" alt="80486的高速缓存"></p><p>执行时间很短，取指时间很长，综合来看，并没有什么优势。</p><h2 id="Pentium的高速缓存"><a href="#Pentium的高速缓存" class="headerlink" title="Pentium的高速缓存"></a>Pentium的高速缓存</h2><ul><li><strong>将指令cache和数据cache分开</strong>，各自的局部性不会互相影响；</li><li>现代的L1 cache都会采用这种结构；</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%883%EF%BC%89%EF%BC%9Amultilevel-cache/2.png" alt="Pentium的高速缓存"></p><h2 id="Core-i7的多级高速缓存"><a href="#Core-i7的多级高速缓存" class="headerlink" title="Core i7的多级高速缓存"></a>Core i7的多级高速缓存</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%883%EF%BC%89%EF%BC%9Amultilevel-cache/3.png" alt="Core i7的多级高速缓存"></p><ul><li>现代的Cache结构均为多层的，并且从上到下，缓存的容量是递增的，即L1 cache是最小的，L3 cache最大。</li><li>L1 cache做的最小，有成本的考量，也有multilevel caches设计思想在里边，L1 cache的主要目的在于减少cache的hit time，而做大后，则会增加hit time。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Computer Organization and Design - 5.4 - Reducing the miss Penalty Using Multilevel Caches</li><li><a href="https://www.coursera.org/learn/jisuanji-zucheng/lecture/AlkKh/706-gao-su-huan-cun-de-zu-zhi-jie-gou">高速缓存的组织结构 - 第七讲 存储层次结构</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> multilevel cache </tag>
            
            <tag> L1 cache </tag>
            
            <tag> L2 cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache的性能调优（2）：减少miss rate-set associative</title>
      <link href="/2022/10/26/ji-suan-ji-ji-chu/cache-de-xing-neng-diao-you-2-set-associative/"/>
      <url>/2022/10/26/ji-suan-ji-ji-chu/cache-de-xing-neng-diao-you-2-set-associative/</url>
      
        <content type="html"><![CDATA[<p>在cache性能量化的文章中，提到使用平均访存时间在衡量cache的性能。由于miss cache是cache 访问的核心瓶颈之一，因此为了提升性能，可以通过有效减少miss rate来实现。</p><h1 id="不同的miss类型"><a href="#不同的miss类型" class="headerlink" title="不同的miss类型"></a>不同的miss类型</h1><p>对于造成cache出现miss的原因有很多，根据这些原因，可以将miss的类型分为3类：</p><ul><li>Compulsory misses/cold-start misses<ul><li>即，第一次访问main memory中的一个block，该block从未在cache中出现过；</li><li>典型的场景：在计算机开机后，很多的程序还未运行，只能从main memory中加载数据，这种场景的cold-start miss很难避免；</li><li>这种miss，可以通过增加cache line中block 的size，从而利用空间局部性，使得一些数据在没有访问时也会被加载到cache中，但是这种方法会增加miss penalty，因为block增加，从main memory读数据的时间就会增加。</li></ul></li><li>Capacity misses<ul><li>由于cache容量有限，导致无法容纳所有来自main memory的内存，造成了miss;</li><li>典型场景：block被放到cache中，但是还未查询hit，就被替换了；</li></ul></li><li>conflict misses/collision misses<ul><li>来自main memory不同地址的多个block竞争cache中的同一个位置；</li></ul></li></ul><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>那么如何减少miss rate呢？首先要明白miss产生的具体场景都有哪些：</p><ul><li>cache的空间不够：导致只能存储部分来自内存的数据，这样很多数据无法进入cache，导致出现miss；</li><li>来自多个main memory的数据竞争cache line：导致cache中的数据被频繁替换，刚进入cache中的数据还未被hit，就被替换，从而导致miss；</li></ul><p>这两种问题，其实可以通过扩大cache的容量来解决，但是扩大cache容量带来两个负面影响：</p><ul><li><code>hit time</code>会增加，根据平均访存时间的公式，这也会影响性能；</li><li>成本增加；</li></ul><p>那有没有一个方法，可以在不改变cache容量的前提下，能够提高cache的性能？这里要解决的一个关键问题是——如何解决来自内存中的数据在cache中频繁发生的替换问题？</p><p>那么<strong>为什么会有频繁替代呢？简单来讲，僧多肉少。</strong></p><p>main memory中的每个地址中的数据在cache中只有一个位置，即存在一对一的映射关系，但是一个cache line对内存中的数据则由一对多的映射关系。因此，多个内存中的数据竞争一个位置，当然会有频繁的替代了。</p><p>核心问题明确了，为了减轻竞争，我们要将之前的main memory中的地址与cache line一对一的关系，改为一对二，甚至一对三，这样就不会有激烈的竞争。实现这种策略的方法是——<code>set associative</code>。</p><h1 id="两个极端的方案"><a href="#两个极端的方案" class="headerlink" title="两个极端的方案"></a>两个极端的方案</h1><h2 id="direct-mapped-cache"><a href="#direct-mapped-cache" class="headerlink" title="direct mapped cache"></a>direct mapped cache</h2><p>到目前为止，之前提到的所有的cache的placement scheme均为direct mapped，简单讲，一个来自内存的block只能对应一个cache line，这个映射关系由main memory的地址决定。</p><p>但是对于cache中各种line的组织方式不仅仅这一种placement schema。这种方式只是一种极端的方式。</p><h2 id="fully-associative"><a href="#fully-associative" class="headerlink" title="fully associative"></a>fully associative</h2><p>相比于direct mapped cache，这种策略走到了另一个极端，非但不将内存中的数据映射到cache中一个位置，而是映射到任意的位置。</p><p>这种方式的好处是，将不同内存地址之间的冲突最大程度上缓解了，当direct mapped中两个内存地址映射到相同的cache line导致被替换时，在fully associative中只是简单的换一个位置即可。</p><p>有好处，就会有代价。当在cache中搜索时，就不如direct mapped策略中那么方便了，在direct mapped中，只要比较了index和tag就可以确定block，但是在fully associative中，必须比较block中各个words的地址，甚至byte offset（words中字节的偏移地址）。这种比较给硬件带来了极大的性能负担，为了在实际中应用，一般上述的比较过程都是并行的，即便如此，这种策略也只是在小容量的cache中使用。</p><h1 id="折中方案——set-associative"><a href="#折中方案——set-associative" class="headerlink" title="折中方案——set associative"></a>折中方案——set associative</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>上述两个方案均走了极端，一个是只映射到一个位置，一个是可以映射到任意位置。权衡之下，<code>set associative</code>只映射到n个位置。</p><p>在set associative，来自内存的数据可以随意映射到<code>n</code>个位置，这种策略称为<code>n-way set-associative cache</code>。</p><ul><li>其中包含一系列的<code>sets</code>，每个set中包含<code>n</code>个位置；  $$<br>  \text{The number of sets} \times n = \text{The number of cache lines}<br>  $$</li><li>每个来自内存的block可以映射到唯一的set；  不同于direct mapped cache，寻找对应的set，通过如下方式：  $$<br>  \text{(block number) modulo (number of sets)}<br>  $$</li><li>这个block可以放到所映射的唯一的set的任意位置；</li></ul><p>这种策略融合了direct mapped和fully associative的优点：</p><ul><li>direct mapped的快速寻找：block只能映射到唯一的set中；</li><li>fully associative的缓解cache line竞争：在唯一的set中可以随意放置；</li></ul><h2 id="三种策略对比"><a href="#三种策略对比" class="headerlink" title="三种策略对比"></a>三种策略对比</h2><p>针对如下的例子进行对比，对于一个block address为12的block，如何在上述3种策略中放置：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%882%EF%BC%89%EF%BC%9Aset-associative/1.png" alt="三种Placement Schema对比"></p><ul><li>direct mapped中，12 % 8 = 4，只能映射到一个位置，但是搜索该位置只需要1次；</li><li>2-set associative中，12 % 4 = 0，即只能映射到index=0的set，但是可以在其中的2个位置，任选一个，因此需要搜索两次；</li><li>fully associative中，12对应的block可以映射到任意位置，但是要对所有的cache lines进行搜索；</li></ul><p>综上，</p><ul><li>direct mapped可以看作 1-set associative，只能映射到一个位置，是一种特例；</li><li>fully associative可以看作m-set associative，可以映射到m个位置，其中共有m个cache lines，也是一种特例；</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%882%EF%BC%89%EF%BC%9Aset-associative/2.png" alt="三种策略的总结"></p><blockquote><p>这里有一个associativity的概念，本质就是一个set中有几个cache lines。</p></blockquote><p>对比3种策略，随着associativity的不断增加，也即set数量的不断减少（相同数量cache lines的情况下），cache的miss rate是不断下降的。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%882%EF%BC%89%EF%BC%9Aset-associative/3.png" alt="Miss Rate相对于Associativity的变化"></p><p>但是，随着cache size的不断增大（图中的不同折线），associativity的不断增加，所起到的作用不再明显，甚至微乎其微。</p><p>当然，associativity增加也会带来副作用，比如增加搜索的成本，同时hit time也会增加（因为搜索空间变大了嘛）。</p><h2 id="定位set-associative中的block"><a href="#定位set-associative中的block" class="headerlink" title="定位set associative中的block"></a>定位set associative中的block</h2><p>我们在<a href="https://lifehit.cn/2022/10/23/ji-suan-ji-ji-chu/cache-de-gong-zuo-yuan-li-2-du-shu-ju/#toc-heading-10">之前的文章</a>里，描述过如何将内存中的数据映射direct mapped cache中。现在placement schema变化了，那么这种映射方式如何变化呢？与direct mapped类似。</p><ul><li>在set associative cache的line中，也存在tag字段，对应内存的高位地址；</li><li>index字段也存在，不过不是用来索引lines，而是索引映射的set；</li><li>block offset：用来寻址block内部的数据，作为偏移量；</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%882%EF%BC%89%EF%BC%9Aset-associative/4.png" alt="set associative中block的定位"></p><p>与direct mapped cache中不同的是，虽然有唯一映射的set，但是在该set中，可以随意放置block，因此搜索是一个问题，如果一个一个的串行搜索导致hit time大幅提升，因此实际中一般是并行搜索。并行的速度受到sets数量的影响，当同样数量的cache lines时，sets数量越多，并行搜索的效率越高。</p><p>下例中，为了实现一个4-set associative cache，执行并行搜索需要的电路结构。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%882%EF%BC%89%EF%BC%9Aset-associative/5.png" alt="4-set associative cache并行搜索block"></p><p>图中标红的部分是由4个block组成的一个set，共有256个set。</p><p>总结来看，3种placement schema的block定位方法如下：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%882%EF%BC%89%EF%BC%9Aset-associative/6.png" alt="3种策略的定位方法"></p><p>考虑到miss rate带来的影响，以及实现set-associative需要付出的时间和额外硬件的成本，选择哪种placement schema还要具体问题具体分析。</p><h2 id="如何选择需要替换的block"><a href="#如何选择需要替换的block" class="headerlink" title="如何选择需要替换的block"></a>如何选择需要替换的block</h2><p>在set associative中出现一个新问题，选哪个block被替换？在direct mapped cache中不存在这个问题，因此是一对一的，新的替换旧的，如此简单。</p><p>但是，在set associative和fully associative中，因此在一个set中可以随意选择放置位置，因此需要决定当set中的block满了时候，如何替换？此时，一般有如下的几种策略。</p><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><ul><li>对于替换set中的哪个block，不是确定的，而是每次随机；</li><li>一般使用一些硬件电路实现，实现简单；</li></ul><h3 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round-Robin"></a>Round-Robin</h3><ul><li>按照预先设定的顺序依次选择Cache块替换；</li><li>硬件简单，性能一般；</li></ul><h3 id="LRU-Least-recently-used"><a href="#LRU-Least-recently-used" class="headerlink" title="LRU (Least recently used)"></a>LRU (Least recently used)</h3><ul><li>选择距离现在最长时间未被访问的Cache块替换，因为这些block已经不符合时间局部性了；</li><li>在实践中，通过记录该set中每个block相对于其他block的使用次数，来决定被访问次数最少得block。<ul><li>一般通过硬件实现替换算法，这个操作成本很高，一般只在4-set associative以下使用；</li></ul><blockquote><p>所谓性能优化，肯定是牺牲了一些，得到另一些，需要权衡。</p></blockquote></li><li>表现较好，但是硬件电路复杂；<ul><li>由于LRU在复杂的set associative中实现复杂，一般都是近似记录，而且这种实现在一些场景中没有比随机替换好；</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于cache中miss问题的解决，不能只从一个角度考虑，因为各种因素之间是互相影响的，回到开篇提到的3种miss，不同策略优点和缺点如下：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%882%EF%BC%89%EF%BC%9Aset-associative/7.png" alt="不同miss类型的解决方案及其优缺点"></p><p>set associative虽然能减小miss rate，但是会增加hit time，也会增加电路结构的复杂性，因此实际应用时，需要根据具体问题具体分析。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Computer Organization and Design - 5.4.1 - 5.4.3</li><li>Computer Organization and Design - 5.8</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> set associative </tag>
            
            <tag> fully associative </tag>
            
            <tag> direct mapped cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache的性能调优（1）：性能量化</title>
      <link href="/2022/10/24/ji-suan-ji-ji-chu/cache-de-xing-neng-diao-you-1-xing-neng-liang-hua/"/>
      <url>/2022/10/24/ji-suan-ji-ji-chu/cache-de-xing-neng-diao-you-1-xing-neng-liang-hua/</url>
      
        <content type="html"><![CDATA[<p>cache能够有效提升对存储器的访问速度，因此利用好这一组件，能够大大提升系统的整体性能，但是对cache的性能调优的第一步是如何量化对cache的访问性能。只有给出量化的方法，才能提出不同的策略，来改进策略。</p><h1 id="Review：Cache访问过程"><a href="#Review：Cache访问过程" class="headerlink" title="Review：Cache访问过程"></a>Review：Cache访问过程</h1><p>4个性能指标：</p><ul><li><code>hit rate</code>: 访存请求中发生cache Hit的请求所占比例；</li><li><code>hit time</code>: 从cache将命中数据返回的时间；<ul><li>L1 Cache约1~3个时钟周期；</li><li>L2 Cache约5~20个时钟周期；</li></ul></li><li><code>miss rate</code>: 1 - hit rate；</li><li><code>miss penalty</code>: 从主存读取数据并返回的时间，约100~300个周期；</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%881%EF%BC%89%EF%BC%9A%E6%80%A7%E8%83%BD%E9%87%8F%E5%8C%96/1.png" alt="Cache访问过程"></p><h1 id="内存访问的时间衡量"><a href="#内存访问的时间衡量" class="headerlink" title="内存访问的时间衡量"></a>内存访问的时间衡量</h1><p>在CPU运行过程中，CPU的时间可以具体分为两个部分：</p><ul><li>真实执行具体指令花费的时钟周期；</li><li>等待内存系统花费的时钟周期；</li></ul><blockquote><p>这里将访问cache的时间算在了执行指令的时间中。</p></blockquote><p>因此，得到如下计算公式：</p><p>$$<br>\text{CPU time = (CPU execution clock cycles + Memory-stall clock cycles)} \times \text{Clock cycle time}<br>$$</p><p>当CPU执行指令的时间越短，内存访问的瓶颈就越严重。</p><p>其中：</p><ul><li><p><code>Memory-stall clock cycles</code>主要是由于cache miss 导致，因此需要去读取main memory。而<code>Memory-stall clock cycles</code>又具体分为读和写两个部分：</p><p>  $$<br>  \text{Memory-stall clock cycles =  (Read-stall cycles + Write-stall cycles)}<br>  $$</p></li><li><p><code>Read-stall cycles</code>可以进一步分解为以下形式：</p><p>  $$<br>  \text{Read-stall cycles} = \frac{\text{Reads}}{\text{Program}} \times<br>  \text{Read miss rate} \times<br>  \text{Read miss pennalty}<br>  $$</p><p>  简单来说，读操作造成的停顿时间，由指令中读操作的数量，这些读操作导致的miss rate，每个miss rate需要的miss penalty组成。</p></li><li><p>相比于读操作，写操作的过程更复杂，这个过程中涉及不同的策略。</p><ul><li><p>当使用write through策略时，需要同时写入cache和memory。</p><blockquote><p>这里有个疑问，之前提到在hit cache时才会有write through，但是这里还会发生miss，是不是与之前的冲突？这里我是这么理解的，对于write through的理解，以同时写到cache和memory为核心，至于写到cache是否miss，不是关注重点。</p></blockquote><ul><li>当hit cache时，写入cache的时间可以忽略，但是write buffer stalls，则是写入memory造成的。</li><li>当miss cache时，此时需要将main memory中的数据先读到cache中，然后再写。</li></ul><p>  综上所示，使用write through时的write-stall cycles如下：</p><p>  $$<br>  \text{write-stall cycles} = \frac{\text{Writes}}{\text{Program}} \times<br>  \text{Write miss rate} \times<br>  \text{Write miss pennalty} + \text{Write buffer stalls}<br>  $$</p><p>  这里，因为memory处理写的速度超过CPU产生写操作的速度，因此<code>write buffer stalls</code>可以忽略。</p><p>  综合来看，假设：</p><p>  $$<br>  \begin{align}<br>  \text{write miss rate = read miss rate} \\<br>  \text{write miss penalty = read miss penalty}<br>  \end{align}<br>  $$</p><p>  得到：</p><p>  $$<br>  \text{Memory-stall clock cycles} =<br>  \frac{\text{Memory accesses}}{\text{Program}} \times<br>  \text{Misses} \times<br>  \text{Miss penalty}<br>  $$</p><p>  进一步拆解得到：</p><p>  $$<br>  \text{Memory-stall clock cycles} =<br>  \frac{\text{Instructions}}{\text{Program}} \times<br>  \frac{\text{Misses}}{\text{Instructions}} \times<br>  \text{Miss penalty}<br>  $$</p></li><li><p>当使用write back策略时，对于从cache中将数据写到memory也需要时间</p></li></ul></li></ul><h1 id="评价访存性能——平均访存时间"><a href="#评价访存性能——平均访存时间" class="headerlink" title="评价访存性能——平均访存时间"></a>评价访存性能——平均访存时间</h1><p>为了评价访问数据的性能表现，综合考虑hit和miss两种情况，人们想出了——平均访存时间，这个指标可以辅助cache性能的优化。</p><p>$$<br>\text{Average Memory Access Time} = \text{Hit Time} + \text{Miss Penalty} \times \text{Miss Rate}<br>$$</p><p>既然由3个因素决定，如果减少平均访存时间，就是分别减少这3项。</p><ol><li>降低hit time 要求将cache做得小一些，结构不要太复杂。 但是小容量的cache容易失效，导致miss rate提升。</li><li>减少miss penalty 可以通过提高主存性能；或者在当前的cache和主存之间再增加一层cache。但是新增的cache也会遇到相同的问题。</li><li>减少miss rate 提升cache的容量，但是这样hit time就会增加，因此也不一定可行。</li></ol><p>因此，这3个因素不是相互独立的，需要综合考虑才行。</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%881%EF%BC%89%EF%BC%9A%E6%80%A7%E8%83%BD%E9%87%8F%E5%8C%96/2.png" alt="实例分析"></p><p>命中率提高了2%，但是平均访存时间提升了1倍，因此提升命中率带来的性能提升非常明显。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
            <tag> 平均访存时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache的工作原理（2）：读数据</title>
      <link href="/2022/10/23/ji-suan-ji-ji-chu/cache-de-gong-zuo-yuan-li-2-du-shu-ju/"/>
      <url>/2022/10/23/ji-suan-ji-ji-chu/cache-de-gong-zuo-yuan-li-2-du-shu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="Cache内部的逻辑结构"><a href="#Cache内部的逻辑结构" class="headerlink" title="Cache内部的逻辑结构"></a>Cache内部的逻辑结构</h1><p>回顾之前的内容，为了确定cache中是否有数据以及如何找到这些数据，在cache中已有存在：</p><ul><li>valid bit：判断cache line中是否有来自内存的数据；</li><li>tag 字段：标识main memory的高位地址；</li><li>index：标识cache line的序号；</li></ul><p>从硬件上来说cache主要是SRAM和控制逻辑电路组成，但是其内部的逻辑结构可以看成是上述3者，加上数据字段，构成一个cache line，如下所示。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%EF%BC%9A%E8%AF%BB%E6%95%B0%E6%8D%AE/1.png" alt="Cache内部的逻辑结构"></p><ul><li>在该图中，cache共有16个cache lines；</li><li>数据段中对应一个block，也是main memory中访问得到数据的最小单位（利用了空间局部性原理），这里一个block是16个字节；</li></ul><h1 id="读数据的简要过程"><a href="#读数据的简要过程" class="headerlink" title="读数据的简要过程"></a>读数据的简要过程</h1><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%EF%BC%9A%E8%AF%BB%E6%95%B0%E6%8D%AE/2.png" alt="读数据的简要过程"></p><p>Cache的简单访问过程如上图所示：</p><ul><li>当数据在cache中，这种情况称为hit，数据直接从cache中返回，这种是最理想的情况，也是最能发挥cache作用的场景；</li><li>当访问的数据不在cache中时，称为miss，此时需要向main memory发起读请求，当得到数据后，注意，此时得到的数据不仅仅是访问的数据，而是包含访问数据的一个连续的序列，之后将cache中的数据更新，并返回读取的数据；</li></ul><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><ul><li><code>hit rate(hit ratio)</code>: The fraction of memory accesses found in the upper level of the memory hierarchy.<ul><li>这个概念一般用在cache上；</li><li>但是这里定义的很general，例如，理论上，main memory 对于disks也可以看作“cache”, 因此对于main memory也可以计算 hit rate;</li></ul></li><li><code>miss rate</code>: <code>1 - hit rate</code>, the fraction of memory accesses not found in the upper level.</li></ul><p>由于访问速度是memory hierarchy提出的核心诉求之一，因此基于上述两个概念，有几个相关的概念：</p><ul><li><code>Hit time</code> is the time to access the upper level of the memory hierarchy.<ul><li>including the time needed to determine whether the access is a hit or a miss. 即这部分时间也包括比较tag标签和valid bit的时间；</li></ul></li><li><code>miss penalty</code>  is the time required to fetch a block into a level of the memory hierarchy from the lower level, including:<ul><li>the time to access the block,</li><li>transmit it from one level to the other,</li><li>insert it in the level that experienced the miss,</li><li>and then pass the block to the requestor.</li></ul></li></ul><p>相比于miss penalty，hit time很小，因此优化访问性能的主要关注点一般在减小miss penalty。</p><h1 id="读数据过程的具体分析"><a href="#读数据过程的具体分析" class="headerlink" title="读数据过程的具体分析"></a>读数据过程的具体分析</h1><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>当CPU执行如下的汇编代码时，发生了什么？</p><pre class=" language-nasm"><code class="language-nasm">MOV <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token number">2011H</span><span class="token operator">]</span>MOV <span class="token register variable">BL</span>, <span class="token operator">[</span><span class="token number">4011H</span><span class="token operator">]</span>MOV <span class="token register variable">CL</span>, <span class="token operator">[</span><span class="token number">3732H</span><span class="token operator">]</span>MOV <span class="token register variable">DL</span>, <span class="token operator">[</span><span class="token number">401FH</span><span class="token operator">]</span></code></pre><ul><li>首先要确定汇编指令，这些指令均是将内存地址中的数据移到通用寄存器中；</li><li>确定访问的main memory的地址：<code>MOV AL, [2011H]</code>会直接访问2011H对应的内存地址吗？答案是不会的，因为，cache line在上图中，每个block为16个字节。为了利用空间局部性原理，cache一次要读取一个block——16个字节，因此需要16个字节对齐。因此虽然是将2011H地址上的数据移到AL寄存器上，但是cache发出的地址是2010H（这是16个字节对齐后的地址）。</li></ul><blockquote><p>如何判断地址是否对齐，可以<a href="https://stackoverflow.com/questions/19190502/how-do-i-check-a-memory-address-is-32-bit-aligned-in-c">参考Stack Overflow中的一个回答</a>。顺便想到，在x86中，word是2个字节对齐的，MIPS中是4个字节对齐的。</p></blockquote><p>根据读操作的具体过程，可以分为以下几种情况。</p><h2 id="miss：分配cache-line"><a href="#miss：分配cache-line" class="headerlink" title="miss：分配cache line"></a>miss：分配cache line</h2><p>在这种情况下，将[2011H]地址变为[2010H]地址，这里怎么理解？2011H地址是一个16进制的数，其中共有16位，也就是内存16位对齐。</p><p>转换为10进制的过程与2进制相同：</p><p>$$<br>2 \times 16^3 + 0 \times 16^2 + 1 \times 16^1 + 1 \times 16^0<br>$$</p><p>要保证16bit对齐，最后一位必须是0，所以这就是[2011H]到[2020H]内存地址转换的具体含义。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%EF%BC%9A%E8%AF%BB%E6%95%B0%E6%8D%AE/3.png" alt="miss：分配cache line"></p><p>cache访问内存的[2010H]地址获取数据，一共得到16bit的数据，就放在cache line的数据单元中，具体的放置规则如下：</p><ol><li>选取哪个cache line？根据倒数第二位，这是一个16进制的数，通过对16取余，正好是该位上对应的数字，恰好可以对应16个cache lines；</li><li>得到对应的cache line后，将数据放入其中，如何获取真实地址[2011H]对应的数据，看最后一位，是当前表项从开始的偏移量位置对应的数据，也就是A1H，返回给CPU即可；</li><li>填充tag：将除了末尾两位之外的其他地址数据放到标签中；</li><li>置valid bit为1；</li></ol><h2 id="miss：替换cache-line"><a href="#miss：替换cache-line" class="headerlink" title="miss：替换cache line"></a>miss：替换cache line</h2><p>当执行<code>MOV BL, [4011H]</code>指令时，发现这个内存地址对应的cache line也是1，但是发现tag部分不同，因此对应不同的内存地址，发生miss，需要去main memory重新读取数据，填充到cache line 1中，新的数据来临，与cache line 1中的数据发生冲突，将其替换即可。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%EF%BC%9A%E8%AF%BB%E6%95%B0%E6%8D%AE/4.png" alt="miss：替换cache line"></p><h2 id="miss：分配新cache-line"><a href="#miss：分配新cache-line" class="headerlink" title="miss：分配新cache line"></a>miss：分配新cache line</h2><p>当同样发生miss时，但是数据访问的内存地址在cache line 的tag中没有出现过，因此没有冲突，直接访问main memory继续访问数据即可。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%EF%BC%9A%E8%AF%BB%E6%95%B0%E6%8D%AE/5.png" alt="miss：分配新cache line"></p><h2 id="hit：读取cache-line"><a href="#hit：读取cache-line" class="headerlink" title="hit：读取cache line"></a>hit：读取cache line</h2><p>最好的情况是命中，按照之前写入的规则读取对应的数据返回。访问内存地址[401FH]对应的数据时，发现在cache line 1中出现index 和tag同时匹配，因为内存地址为concat(tag, index)，然后读取[4010H]对应的数据，再加上偏移量，得到BFH。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%EF%BC%9A%E8%AF%BB%E6%95%B0%E6%8D%AE/6.png" alt="hit：读取cache line"></p><h1 id="澄清：内存与cache的地址对应关系"><a href="#澄清：内存与cache的地址对应关系" class="headerlink" title="澄清：内存与cache的地址对应关系"></a>澄清：内存与cache的地址对应关系</h1><p>前面我们说到当CPU发出访问数据的请求时，直接给出的是内存地址，这些内存地址可以通过拆分对应到cache的位置上，如下：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%EF%BC%9A%E8%AF%BB%E6%95%B0%E6%8D%AE/7.png" alt="cache与内存地址的简要对应的关系"></p><p>但是，因为有<strong>内存地址对齐机制</strong>的存在，上述的地址转换并不完全准确。在MIPS中，当lh读半个word（MIPS中一个word为4个字节），存储器的地址必须是2的整数倍（地址结尾必须有1个0）； lw 读一个word时，存储器的地址必须是4的整数倍（地址结尾必须有2个0）。</p><p>我们以MIPS访问一个word为例进行说明，因为它也是以一个word，4个bytes实现地址对齐的。对于32位地址的情况，内存地址如下：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%EF%BC%9A%E8%AF%BB%E6%95%B0%E6%8D%AE/8.png" alt="MIPS内存地址对齐"></p><p>在前面提到过，为了更好地利用空间局部性原理，cache从main memory中读取数据时，一般按照以block为单位进行读取，一个block填入cache line中，而block中一般有若干个words。</p><p>基于这种情况，如何将main memory的地址对应到cache中呢？应该是分为以下几个步骤：</p><ol><li>确定index字段，确定具体的cache line;</li><li>确定cache line的tag字段，是否一致； 到此为止已经确定了一个cache line中block；</li><li>之后，需要确定是block中第几个word；</li><li>更进一步，因为一个word是4个字节，如果要访问一个字节的数据，还需要确定偏移量，这个偏移量一般是固定的，与对齐的方式有关，例如MIPS中是4个字节对齐，x86是2个字节对齐；</li></ol><p>到此为止，算是比较完整的main memory地址映射到cache上。</p><p>cache line中的block大小可以变化，扩大容量或者缩小容量，但是这种操作会影响其他字段，比如index或者tag字段。如下举几个例子：</p><h2 id="例1：tag-10，index-10"><a href="#例1：tag-10，index-10" class="headerlink" title="例1：tag=10，index=10"></a>例1：tag=10，index=10</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%EF%BC%9A%E8%AF%BB%E6%95%B0%E6%8D%AE/9.png" alt="tag=10，index=10"></p><p>这种情况下，32位地址中用于决定选择哪个word的bit只有10个，即能寻址 $2^{10}$ 个words，每个word都可以通过byte offset在一个word内部确定选择哪个byte，来应对MIPS中lh等指令。</p><h2 id="例2：tag-10，index-5"><a href="#例2：tag-10，index-5" class="headerlink" title="例2：tag=10，index=5"></a>例2：tag=10，index=5</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%EF%BC%9A%E8%AF%BB%E6%95%B0%E6%8D%AE/10.png" alt="tag=10，index=5"></p><p>这种情况下，32位地址中用于决定选择哪个word的bit有15个，即能寻址 $2^{15}$ 个words，但是此时index数量减少，因此这种情景下，cache line内部的block容量增加了，但是整体的cache lines数量减少了。</p><h1 id="减少miss——扩充cache-capacity？"><a href="#减少miss——扩充cache-capacity？" class="headerlink" title="减少miss——扩充cache capacity？"></a>减少miss——扩充cache capacity？</h1><h2 id="如何计算cache-capacity"><a href="#如何计算cache-capacity" class="headerlink" title="如何计算cache capacity"></a>如何计算cache capacity</h2><p>计算cache的容量，需要了解如何将main memory的地址放到cache中。</p><p>举例说明，如下场景中：</p><ul><li>32位地址；</li><li>direct-mapped cache structure</li><li>cache中共有 $2^n$ 个lines，也说明每个cache line中的index字段共有n个bits；</li><li>每个cache line中有一个block，每个block能存储 $2^m$ 个words，说明用于寻址words的地址中的位数有m位。</li></ul><p>根据这些信息，我们可以计算tag字段有几个bits：</p><p>$$<br>32 - ( n + m + 2)<br>$$</p><ul><li>n为index 的bits;</li><li>m为寻址words的bits;</li><li>2是byte offset的bits，MIPS中固定为2个bits；</li></ul><p>在一个direct-mapped cache中所有的<strong>bits</strong>如下：</p><p>$$<br>2^n \times (\text{block size} + \text{tag size} + \text{valid field size})<br>$$</p><ul><li>block size  $$<br>  2^m \times 32<br>  $$</li></ul><p>因此，所有的bits为：</p><p>$$<br>2^n \times (2^m \times 32 + (32 - n - m - 2) + 1)<br>$$</p><p>这个计算结果是cache中所有的bits，但是一般我们只考虑用于存储数据的bits，即：</p><p>$$<br>2^n \times 2^m \times 32<br>$$</p><p>根据这个计算公式，可以知道上述的例1和例2中的容量（只有数据的）分别为：</p><p>$$<br>2^{10} \times 2^{10} \times 32<br>$$</p><p>$$<br>2^5 \times 2^{15} \times 32<br>$$</p><p>均为4MiB的cache。</p><h2 id="分析cache-capacity的影响"><a href="#分析cache-capacity的影响" class="headerlink" title="分析cache capacity的影响"></a>分析cache capacity的影响</h2><p>在读数据的具体过程中，发生miss的情况，非常影响访问性能，那么从硬件的角度来看，增加cache的容量，使得main memory中的多数尽可能的驻存在cache中，理论上可以降低miss rate，也是空间局部性的体现。</p><p>但是，情况并不是我们理想的那样。当cache line中的block size增加后，会发生什么？</p><p>一个cache line中存储的words数量增加，但是从上述的例1和例2中可以看出，block size增加（即用于寻址的bits增加），对应的cache lines的数量或者tag的位数就会减少，这导致了对于cache lines的争夺激烈，会发生当一个main memory的数据进入cache后，还未来得及被hit，就已经被新进来的main memory的数据替换，大量发生冲突。</p><p>另外一个是，当block size增加后，miss时引入的性能下降也会增加。即，当发生miss时，需要cache从main memory中读取数据，这个过程在上面提到共2个部分：</p><ul><li>对于block数据中第一个word的定位时间延迟；</li><li>将所有的数据传输到cache；</li></ul><p>因为block size增加，导致传输时间大幅增加，因此<code>miss penalty</code>大幅增加，因此可能会导致block size带来的性能的提升抵不上miss penalty带来的性能下降。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%EF%BC%9A%E8%AF%BB%E6%95%B0%E6%8D%AE/11.png" alt="From Computer Organization and Design"></p><p>从上图看出：</p><ul><li>同样cache size，随着block size的增加，其miss rate先下降之后上升，就是因为上述的原因；</li><li>而cache size的增加，增加的可以是cache lines的数量，这样可以减少冲突，从而减少miss rate.</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://www.coursera.org/learn/jisuanji-zucheng/lecture/sYRYl/703-zhu-cun-de-gong-zuo-yuan-li">703-主存的工作原理 - 第七讲 存储层次结构 | Coursera</a></p></li><li><p>Computer Organization and Design : the hardware/software interface</p></li><li><p><a href="https://stackoverflow.com/questions/20593850/cache-and-memory">Cache and memory</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1727794">一文轻松理解内存对齐</a></p></li><li><p><a href="https://stackoverflow.com/questions/381244/purpose-of-memory-alignment">Purpose of memory alignment</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
            <tag> cache </tag>
            
            <tag> 内存对齐 </tag>
            
            <tag> cache capacity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache的工作原理（3）：写数据</title>
      <link href="/2022/10/23/ji-suan-ji-ji-chu/cache-de-gong-zuo-yuan-li-3-xie-shu-ju/"/>
      <url>/2022/10/23/ji-suan-ji-ji-chu/cache-de-gong-zuo-yuan-li-3-xie-shu-ju/</url>
      
        <content type="html"><![CDATA[<p>cache在CPU读取数据时扮演着重要的角色，同样的，虽然，在CPU写数据时，没有发挥直接作用，但是可以发挥间接作用，比如将数据写的地方离自己近一点，这样有利于下次的读取。</p><p>但是，写数据与读数据不太一样，主要有两个方面的问题：</p><ul><li>hit cache：因为涉及到数据的变化，可能会存在不一致的情况，例如：只写入cache，但是不写入main memory。</li><li>miss cache，此时如何处理？</li></ul><h1 id="当hit-cache时"><a href="#当hit-cache时" class="headerlink" title="当hit cache时"></a>当hit cache时</h1><p>首先要明确一点，hit cache是什么意思？之前在读数据时，如果数据在cache中，称为hit。同样的，<strong>在写操作中，hit指的是写入的内存地址在cache中能找到。</strong></p><p>在hit的情况下，cache与main memory中对写入内存地址的数据不一致的问题，发生的原因在于只写到了cache中，没有同步到memory中。针对这种情况，最简单的办法是write-through。</p><h2 id="write-through（写穿透）"><a href="#write-through（写穿透）" class="headerlink" title="write-through（写穿透）"></a>write-through（写穿透）</h2><ul><li>数据同时写入Cache和主存，保证内存和cache数据一致；</li><li>但是这种策略效率较低，因为涉及到写到memory中，优点是简单、直接；</li></ul><p>针对这种方法的缺点，有一个改进的策略——使用write buffer。</p><blockquote><p>A <strong>write buffer  as a queue</strong>, it stores the data while it is waiting to be written to memory. After writing the data into the cache and into the write buffer, <strong>the processor can continue execution.</strong></p></blockquote><ul><li>这种方法的优点在于，处理器不用等待写入memory的操作，而是写入write buffer就可以继续执行别的指令（之前基本的write-through策略需要CPU等待写入内存完成），而写入buffer显然比写入memory要快；<blockquote><p>又是，以空间换时间的策略。</p></blockquote></li><li>当write buffer中的数据被写入memory后，它就会被清空，以等待下一次使用；</li><li>当CPU需要写数据时，而write buffer已满，这时CPU也需要等待有空闲位置；</li></ul><p>这种write buffer的策略有个问题：</p><blockquote><p>当CPU发出写操作的速度，大于memory完成写操作的速度，总有时间点，write buffer会被填满，即便buffer再大，CPU也会等待。</p></blockquote><h2 id="Write-back（写回）"><a href="#Write-back（写回）" class="headerlink" title="Write-back（写回）"></a>Write-back（写回）</h2><p>对于write-through的替代策略，write-back使用不同的处理策略：</p><ul><li>第一次只向cache中写入；</li><li>当对应内存地址的cache line中的数据被更新了，才会将数据写回到memory中；</li></ul><p>相比于write-through：</p><ul><li>这种策略性能好，特别是当CPU生成写操作的速度大于memory执行写入操作的速度时，因为写到内存的次数减少；</li><li>可能对同一块cache的区域多次写入，但是只要将最后一次写回到内存即可，减少了内存访问次数；</li><li>但是要实现这个目标，要求cache具有复杂的结构；</li></ul><h1 id="当miss-cache时"><a href="#当miss-cache时" class="headerlink" title="当miss cache时"></a>当miss cache时</h1><p>此时，写指令中的内存地址在cache中没有对应的cache line。在这种情况下，如果要写入数据，有两种策略：</p><ul><li>no write allocate;</li><li>write allocate;</li></ul><h2 id="no-write-allocate"><a href="#no-write-allocate" class="headerlink" title="no write allocate"></a>no write allocate</h2><ul><li>这种策略中，写操作的对象只有main memory，不涉及cache，即数据不会写入cache中。</li><li>实现简单、直接，但是性能不好；</li></ul><h2 id="write-allocate"><a href="#write-allocate" class="headerlink" title="write allocate"></a>write allocate</h2><p>这种策略下，情况要复杂一点：</p><ol><li>首先，根据写操作指令中的内存地址，将对应的数据从main memory中得到，并将数据写到cache的cache line中的block；</li><li>将写操作中新的数据写到1中对应的block中，完成覆写；</li></ol><blockquote><p>这块我一直不太明白为啥要先从内存中将数据写到cache中，直接将数据写到cache中不就行了，这样先写的数据也会被覆盖，何必呢？</p><p>我个人理解，因为是Miss，cache中没有新数据对应的内存地址，因此处理器直接写cache，找不到对应的位置，也就无法完成操作，而先从内存中写cache旧数据的目的是，将对应内存的地址也放到cache中，这样后面写入新数据时就可以找到地址了。</p></blockquote><p>这种策略，</p><ul><li>第一次写入时麻烦，但是有利于后续的读取；</li></ul><h1 id="策略使用"><a href="#策略使用" class="headerlink" title="策略使用"></a>策略使用</h1><p>现代cache的设计和使用中：</p><ul><li>write through和write Non-allocate搭配使用；<ul><li>适用于那些性能要求不高但是希望设计简单的系统；</li></ul></li><li>Write Back 和Write Allocate搭配使用<ul><li>适用于性能较好的场景；</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%883%EF%BC%89%EF%BC%9A%E5%86%99%E6%95%B0%E6%8D%AE/1.png" alt="总结write policy"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://www.coursera.org/learn/jisuanji-zucheng/lecture/sYRYl/703-zhu-cun-de-gong-zuo-yuan-li">703-主存的工作原理 - 第七讲 存储层次结构 | Coursera</a></p></li><li><p>Computer Organization and Design - 5.3 - handling writes</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
            <tag> cache </tag>
            
            <tag> write allocation </tag>
            
            <tag> no write allocation </tag>
            
            <tag> write through </tag>
            
            <tag> write back </tag>
            
            <tag> write policy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache的工作原理（1）：基本介绍</title>
      <link href="/2022/10/18/ji-suan-ji-ji-chu/cache-de-gong-zuo-yuan-li-1-ji-ben-jie-shao/"/>
      <url>/2022/10/18/ji-suan-ji-ji-chu/cache-de-gong-zuo-yuan-li-1-ji-ben-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="Cache是什么"><a href="#Cache是什么" class="headerlink" title="Cache是什么"></a>Cache是什么</h1><p>CPU和内存之间速度的差距越来越大，cache的出现能够弥补这个gap，从计算机组成原理的角度看，cache位于CPU/GPU等处理器和main memory之间的组件，为啥添加一个cache就能提高性能呢？根据之前的<a href="https://lifehit.cn/2022/10/16/ji-suan-ji-ji-chu/ji-suan-ji-de-cun-chu-qi-ceng-ci-jie-gou/ji-suan-ji-de-cun-chu-qi-ceng-ci-jie-gou/">存储结构层次</a>，这取决于计算机程序运行的一个特点——程序局部性原理。但是这个概念可以很宽泛。</p><blockquote><p>cache, the term is also used to refer to any storage managed to take advantage of locality of access.</p></blockquote><p>即，只要利用了局部性原理的存储策略，均可以认为是cache，因此在各种网站、数据库中为了负载均衡使用的各种Redis、memcached均为cache。</p><h2 id="Cache作为bridge"><a href="#Cache作为bridge" class="headerlink" title="Cache作为bridge"></a>Cache作为bridge</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/1.png" alt="Cache作为bridge"></p><p>软件工程师意识不到cache的存在，只是认为在访问内存中的一个地址对应的存储单元。</p><h1 id="关于cache的疑问"><a href="#关于cache的疑问" class="headerlink" title="关于cache的疑问"></a>关于cache的疑问</h1><p>对于cache的使用和访问，以下问题是核心内容：</p><ol><li>如何知道是否有数据在cache中？</li><li>如果在cache中，如何找到该数据？</li></ol><p>为了回答上述的问题，需要了解<code>direct-mapped cache structure</code>。</p><h2 id="direct-mapped-cache-structure"><a href="#direct-mapped-cache-structure" class="headerlink" title="direct-mapped cache structure"></a>direct-mapped cache structure</h2><p>这种cache结构，为了将cache中的数据与内存中的数据关联，直接基于这些数据在main memory中的地址，来分配它们在cache中的位置。</p><ul><li>每个内存地址唯一对应cache中的一个位置；</li><li>但是cache中的一个位置，可以对应多个内存地址中的位置；</li></ul><p>那么如何建立地址之间的映射关系呢？最简单的方式，是取模。</p><p>$$<br>\text{Block address}  \text{  mod  } \text{Number of blocks in the cache}<br>$$</p><p>如下图：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/2.png" alt="内存地址和cache地址之间的映射"></p><ul><li>cache中有8个blocks(lines);</li><li>因为8个blocks，对应 $2^3$ ，因此所有main memory中的地址低3位相同的数字都会映射到相同的cache地址上；</li></ul><h2 id="回答问题2：如何找到cache中的数据"><a href="#回答问题2：如何找到cache中的数据" class="headerlink" title="回答问题2：如何找到cache中的数据"></a>回答问题2：如何找到cache中的数据</h2><p>解决方案：在cache line中添加一个tag字段。</p><p>这个字段含有请求数据的main memory地址信息。但是，有意思的是，<strong>这个tag段，只需要包含前半部分的地址信息，而不是所有，则是因为低部分的地址是cache line的索引序号</strong>。</p><p>以上图为例：</p><ul><li>对于00001，其对应的cache位置是001，这是它的低3位，因此在001cache line上的tag字段只需要记录00，即剩下的高两位即可，两者组成在一起就是main memory的地址；</li><li>例如，对于访问内存地址11101上的数据时，发现101对应cache line中序号为101的位置，其tag字段还是11，那么该访问就hit the cache了；</li></ul><h2 id="回答问题1：如何确定cache中有数据？"><a href="#回答问题1：如何确定cache中有数据？" class="headerlink" title="回答问题1：如何确定cache中有数据？"></a>回答问题1：如何确定cache中有数据？</h2><p>为啥先回答问题2，再回答问题1，因为问题1可以由上述的答案解决，逐次对比每个cache line，肯定能知道访问的数据在cache中是否存在。</p><p>但是，有几种情形：</p><ul><li>开机时，cache中为空，tag中的地址信息无意义，进行比较纯属浪费时间；</li><li>即便执行了很多指令，cache中仍然没有存入数据，这时tag字段也无意义；</li></ul><p>因此，啥时候可以不看tag呢？最常用的办法是在cache line中添加一个valid bit。</p><ul><li>这个bit表明是否该line包含有效的main memory地址；</li><li>这个bit如果没有设置，说明数据访问时无法与该line进行匹配；</li></ul><p>加了这个bit，现在访问cache中的数据分为两步：</p><ol><li>确定valid bit有效；</li><li>识别tag字段和cache line的index字段，生成main memory的地址；</li></ol><blockquote><p>这种策略在很多的场景都有用到，通过添加一个标志位，就可以省略了很多的无意义的操作，以空间换时间的典型做法。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://www.coursera.org/learn/jisuanji-zucheng/lecture/sYRYl/703-zhu-cun-de-gong-zuo-yuan-li">703-主存的工作原理 - 第七讲 存储层次结构 | Coursera</a></p></li><li><p>Computer Organization and Design : the hardware/software interface</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《邻家的百万富翁》们如何《财富自由》的？</title>
      <link href="/2022/10/16/du-shu-gan-wu/lin-jia-de-bai-wan-fu-weng-men-ru-he-cai-fu-zi-you-de/"/>
      <url>/2022/10/16/du-shu-gan-wu/lin-jia-de-bai-wan-fu-weng-men-ru-he-cai-fu-zi-you-de/</url>
      
        <content type="html"><![CDATA[<p>这本书是《邻家的百万富翁》的作者搜集的材料，他的儿子写的，因为在刚要写这本书时，因为车祸去世了，人生总有一些遗憾，所幸这本书还出版了。</p><p>当我读完了《邻家的百万富翁》后，按照作者找也发现了这本书，从名字来看，这本书显然比之前的书的鸡汤味还要浓，尤其是在当今的社会中，切中人们的要害，但是如果想从这本书中获得快速致富的秘诀，恐怕要失望了。</p><p>另外，一个疑问是：既然是一个作者写的，读完《邻家的百万富翁》是否还有必要读这本书，我读完的答案是——值得读。</p><h1 id="本书要回答的核心问题"><a href="#本书要回答的核心问题" class="headerlink" title="本书要回答的核心问题"></a>本书要回答的核心问题</h1><p>《邻家的百万富翁》是在1996年出版的，现在已经快要过去30年了，时代在变化，《邻家的百万富翁》中提到的那些致富的行为方式，和策略是否还有效？简单说，这些是否还能帮人们致富？</p><p>作者的答案，简单明了：<strong>虽然社会在发展，但是数据显示，过去的那些行为方式：节俭、努力工作、克制欲望，仍然可以让人们踏入财富自由的大门；即便存在一些困难，但仍然是可能的。</strong></p><blockquote><p>我们最新的研究和参考数据表明推动财富积累的行为、习惯和生活方式在过去20年没有发生改变。它们独立于时代发展带来的经济、社会或科技问题。我们发现，即使在非富裕阶层，这些特征也会使善于将收入转换成财富者脱颖而出。</p></blockquote><h1 id="与《邻家的百万富翁》的关系"><a href="#与《邻家的百万富翁》的关系" class="headerlink" title="与《邻家的百万富翁》的关系"></a>与《邻家的百万富翁》的关系</h1><p>本书与《邻家的百万富翁》在时间上存在承接的关系，它们都在探讨相同的问题，区别在于：在不同的时空背景下。</p><p>因此，本书中提到的很多内容在《邻家》中已经提到过，只不过是在数据上有了更新，从而回答本文开篇中提到的那个问题。因此，如果读了《邻家》，并且与作者的认知相同，如果时间有限，可以速读。</p><p>但是，我在时间闲暇中，完全读完了这本书，里边的内容，相比于《邻家》，将逻辑阐述地更加清晰。书中分别从几个方面阐述了百万富翁的画像，以及他们做对了什么，让他们成为富翁。</p><p>首先是，富豪们什么样：</p><ul><li>第1章：强调<strong>普通</strong>的百万富翁；</li></ul><p>之后，根据调研，作者驳斥人们对富豪的固有印象：</p><ul><li>第2章：收入高，不代表财富高；</li><li>第3章：积累财富的前提是，尊重金钱；</li></ul><p>最后，总结了富豪们的行为模式，以给读者以启发：</p><ul><li>第4章：避免消费主义陷阱；</li><li>第5章：守住财富的技巧；</li><li>第6章：努力工作很重要；</li><li>第7章：投资必不可少；</li></ul><p>我觉得整个脉络很清晰，比之前的《邻家的百万富翁》要清晰，首先是介绍了富翁们都是什么样的；然后引出人们印象中的2个富翁形象，并加以驳斥；然后梳理富翁们的真实情况是什么样的。</p><h1 id="收入高不代表财富高"><a href="#收入高不代表财富高" class="headerlink" title="收入高不代表财富高"></a>收入高不代表财富高</h1><p>在作者看来，这是普通人对富翁最大的偏见。当然，从大样本来说，这里的富翁不包括作者提到的“闪闪发光的富人“，这些人是old money，不用预算和计划，也有花不完的财产，他们只是极其小的部分，但是可能普通人的眼里都是这些人。</p><p>但是，每天朝九晚五上班的人，可能也是隐形的富豪。所以判断的标准取决于一个简单的公式：<code>收入-支出-负债=资产</code>，你的财富看的是资产，不是收入。</p><blockquote><p>如果想要长期积累和维持财富，你必须以一种不同于他人、更有自制力的方法来处理所有的财务管理——支出、储蓄、创收、投资。</p></blockquote><p>为了实现资产的提升，必须降低支出和负债，提高收入。我见过那些收入5万但是花费3万的人，诚然他们攒了2万（可能并没有），但是如果有合适的计划，他们可以攒下4万。为了与周围的人”合群“，去玩，买不必要的东西，进行一些娱乐活动，换来的是人脉（质疑？）、社交满足感（需要吗？）、不孤独（消除孤独有很多办法），但是牺牲的是什么？我想他们肯定有考虑过这个问题，因为他们也会投资，但是没有长期的计划。</p><p>如果攒下的钱投到资本市场，以每年4%的利率计算，多2万，可以多800块，每年多24万，可以多9600元。有人说这都是小钱，我心底里对这种说法嗤之以鼻，当你有1块钱，看不起1分钱；那么你有100万，也会看不起1万块。当你有难处的时候，你会体会到1万块的价值，可以让你不用看银行工作人员的脸色，和向朋友开口的窘迫。所以，要尊重金钱。</p><h1 id="尊重金钱"><a href="#尊重金钱" class="headerlink" title="尊重金钱"></a>尊重金钱</h1><p>本书中，作者提到要尊重金钱，有以下几个方面：</p><ul><li>为自己的财务决策负责；</li><li>有良好的财务纪律和自制力来管理自己的财务；</li><li>对不尊重金钱的行为表示”冷漠“；<ul><li>警惕”消费主义“陷阱；</li></ul></li><li>不要仇视富人，而是向他们学习；</li></ul><p>有人说，钱不是攒出来的，而是赚出来的，如果下次有人这么说，可以给他一个白眼然后走掉，因为要不他是”闪闪发光的富人“，这样的人没有可比性；要不他账户上没有多少钱，小心跟你借钱。本书通篇都在强调一个观点——运用强大的自制力来节俭、储蓄、投资，尤其是当你是一个普通人时，储蓄是必须的，甚至是最重要的，就像松鼠为冬天储备粮食一样，才能避免被冻死。</p><p>最后一点在之前的书中着墨较少，但是本书中讲了很多，甚至还提到了一个里奇先生对富人充满仇恨。我想提一下这一点，我承认这种现象的出现不是没有原因的，一些富豪确实做了一些伤害平民、社会和国家的事情，但是普通人对这一切无法改变，我想作者的意思更多的是强调，为什么不从他们身上学习那些优点呢？如果只看到别人的缺点，不仅影响心情，总是愤世嫉俗，还会停止进步。</p><p>那么这些富人有什么优点？对国家来说， 他们消费多，纳税多，国内总是对各种茅台、高档消费品进行价格管制，但是也挡不住大家的购买热情，我觉得还是放开了好，这种商品的消费者也不会因为高了1000多块就不买了，不是它的消费者，也不会因为价格管制就不断消费。如果放开了，有人买，价格高，纳税多，茅台的普通工作人员的薪资也能上涨，所以价格管制了是啥，想来想去，只有普通人对富翁们的嫉妒心吧！</p><p>对个人来说，人们只看到马斯克是世界首富和那些花边新闻，看不到他为了管理企业付出的努力，而这些努力更值得我们看到，因为这是与我们有关的事情，而不是那些花边新闻。</p><h1 id="投资的那些事儿"><a href="#投资的那些事儿" class="headerlink" title="投资的那些事儿"></a>投资的那些事儿</h1><p>本书相比于《邻家》新增的一个主题，就是投资。</p><p>作者在书中对于投资陈述了几点原则：</p><ul><li>谨慎对待投资，拿出客观的时间研究，像是对待工作一样；<ul><li>了解你的目标和自己本身，因为风险是自己不知道自己不知道什么，所以会无所畏惧；</li></ul></li><li>分配资源时，不要随波逐流；<ul><li>学习一下行为金融学；</li><li>好的时候稳如泰山，不好的时候坚定不移；</li></ul></li><li>不要轻易相信那些所谓的“理财顾问”；</li><li>舍得花钱购买“有价值”的建议；</li><li>多样化配置资产；</li></ul><p>这些原则即便是经过再长的时候也不过时，其中其他的原则我自己还坚持地不错，但是其中对于花钱购买“有价值的建议，我觉得自己做的还不够。我觉得这一点跟合理消费是一致的，合理消费不是只买便宜的东西，而是买合适的东西，我可以买3万的笔记本，也可以为了节省公交钱走回家，两者并不冲突，合适最好。</p><p>同样的，不要相信“理财顾问”，也是有道理的，<strong>永远不要轻易听那些从向你提供建议的过程中获得佣金的人的意见</strong>，例如：不要向交易员询问是否要买卖，不要向理发师问是否要理发。但是，也不是所有的意见都是无价值的，但是如何判断是否有价值需要自己的知识背景，这也是需要将投资作为工作看待的原因。</p><p>那么，如何花钱买“有价值”的意见呢？不要看结论，看过程，看顾问的数据分析过程，逻辑是否严谨，然后从这个过程中自己得出结论。我觉得是正确的方式。专业的人做专业的事情，当意见合理且有用，应该得到丰厚的回报，这是对知识的尊重。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本书总的来说，是对《邻家》的进一步阐述，其中提到的很多内容在《邻家》已经提到，本文中选了我觉得比较新的部分进行了阐述：</p><ul><li>收入不等于财富；</li><li>尊重金钱；</li><li>投资要谨慎；</li></ul><p>书中的部分内容和我已有的知识结构有一些已经建立了联系，还有一些内容是新增的，我觉得总体看是一本好书，尤其是对那些经常看抖音快速致富秘诀的人来说。</p>]]></content>
      
      
      <categories>
          
          <category> 读书感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 致富 </tag>
            
            <tag> 投资 </tag>
            
            <tag> 计划 </tag>
            
            <tag> 自由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机的存储器层次结构</title>
      <link href="/2022/10/16/ji-suan-ji-ji-chu/ji-suan-ji-de-cun-chu-qi-ceng-ci-jie-gou/"/>
      <url>/2022/10/16/ji-suan-ji-ji-chu/ji-suan-ji-de-cun-chu-qi-ceng-ci-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在计算机中，除了CPU之外，另外一个非常重要的组件是——存储器，根据冯•诺依曼结构的设计思想，计算机中含有存储功能的有：</p><ul><li>运算器 central arithmetical</li><li>存储器 main memory</li><li>外部记录介质 outside recording medium</li></ul><p>对于计算机中的存储器，我们人类都是用贪婪的眼光看待：</p><blockquote><p>We are … forced to recognize the possibility of constructing a hierarchy of memories, each of which has greater capacity than the preceding but which is less quickly accessible.<br>——  A. W. Burks, H. H. Goldstine, and J. von Neumann</p></blockquote><blockquote><p>我比较认同懒惰是人类技术进步的驱动力，同时，认为贪婪也是技术进步的推动力之一。</p></blockquote><p>既想要容量大，又想要访问快。从技术角度来看，这样是可以的吗？可以的，但是需要很多成本。但是考虑现实因素，这样做性价比不高，<strong>所以人们希望建立一个“虚拟”的存储器，能够同时实现这两者，以完成人们的“梦想”，这就是通过memory hierarchy实现的</strong>。这种技术方案是在两者之间取得一个均衡，而不是过分极端，同时考虑成本等因素。</p><h1 id="一些存储器选择的考虑因素"><a href="#一些存储器选择的考虑因素" class="headerlink" title="一些存储器选择的考虑因素"></a>一些存储器选择的考虑因素</h1><ul><li>非易失性<ul><li>即电路断电后，存储器中的信息仍然存在，不会消失。</li><li>CPU中的通用存储器和main memory均为易失性存储器，即断电后数据消失。</li><li>BIOS和硬盘均为非易失性存储器；</li></ul></li><li>可读可写<ul><li>硬盘和main memory均为可读可写的；</li><li>BIOS为只读存储器，用于引导计算机启动，避免任何写入；</li></ul></li><li>随机访问<ul><li>随机访问指，当<strong>对存储器中任意位置数据的访问时间与其所在的位置没有关系。</strong></li><li>这种典型的数据结构是数组和hashmap</li><li>一种典型的非随机访问的设备是磁带，只能顺序访问，否则就要倒带。</li><li>如果不支持随机访问，会对存储器有很大的影响。</li></ul></li><li>访问时间<ul><li>这里所说的访问时间，指的是CPU对存储器的访问时间。</li><li>不同存储器装置的电路结构、与CPU的距离决定了访问时间；</li><li>例如：硬盘由于有机械装置的存在，因此其访问速度难以媲美main memory。</li></ul></li><li>功耗<ul><li>功耗在移动设备上尤其重要；</li><li>也与存储器的电路结构有关，比如是否需要刷新；有时还与总线有关；</li></ul></li><li>还有其他的，如：容量、价格等等；</li></ul><blockquote><p>📌 虽然有这么多考虑因素，但是其中访问速度和容量使我们考虑的核心因素，memory hierarchy也是围绕着两者设计的。</p></blockquote><h1 id="不同类型存储器件的特点"><a href="#不同类型存储器件的特点" class="headerlink" title="不同类型存储器件的特点"></a>不同类型存储器件的特点</h1><h2 id="问题1：硬盘的优点和缺点"><a href="#问题1：硬盘的优点和缺点" class="headerlink" title="问题1：硬盘的优点和缺点"></a>问题1：硬盘的优点和缺点</h2><p>我们都了解硬盘，动辄几百GB，甚至TB，也很常见，<strong>这是它的突出的特点，容量大，同时很便宜，但是缺点是访问速度慢</strong>。导致CPU与硬盘难以直接进行数据交互。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/1.png" alt="硬盘的相关数据"></p><p>如上图所示：</p><ul><li>CPU对比Disk，发现2010相对于1980，CPU的时钟周期，变快了2500倍，但是Disk只提升了29倍，而且两者完全不在一个数量级上。因此CPU直接与Disk交互时，会等待Disk完成IO操作，期间闲置，因此会严重被Disk拖累；</li><li>DRAM相比于Disk则更快一些，其速度提升了9倍，但是与CPU的时钟周期处在同一个数量级上。</li><li>但是Disk的成本降低了1600000倍，而DRAM只降低了130000倍。</li></ul><h2 id="问题2：DRAM存储器性能的影响"><a href="#问题2：DRAM存储器性能的影响" class="headerlink" title="问题2：DRAM存储器性能的影响"></a>问题2：DRAM存储器性能的影响</h2><blockquote><p>DRAM相比于Disk，虽然在访问时间上有提升，但是比CPU的时钟周期还是慢100倍，这种造成怎样的结果呢？</p></blockquote><p>计算执行一条指令，分为4个步骤: </p><ul><li>fetch 取码</li><li>decode 译码</li><li>execute 执行</li><li>write-back 写回</li></ul><p>受限于存储器的性能，当CPU执行其中的特定步骤时，需要等待存储器的访问结束才能进行下一个步骤。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2.png" alt="计算机访问内存执行指令的过程"></p><p>针对这种问题，在CPU和DRAM之间添加SRAM来获得高速访问的效果，以保证程序和数据大部分时间都在SRAM中，SRAM的访问时间一般为3个时钟周期。当使用SRAM作为cache后，指令执行时间大幅下降。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3.png" alt="计算机访问cache执行指令的过程"></p><h2 id="问题3：SRAM的问题"><a href="#问题3：SRAM的问题" class="headerlink" title="问题3：SRAM的问题"></a>问题3：SRAM的问题</h2><p>虽然SRAM的访问速度能够大幅提升性能，但是我们并不用SRAM作为main memory，因为其价格是DRAM的1000倍。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/4.png" alt="SRAM的相关数据"></p><p>但是考虑到其优秀的访问性能，仍作为Cache被不断地引入计算机中。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/5.png" alt="1980 x86-CPU的cache设计"></p><h1 id="Memory-hierarchy的设计"><a href="#Memory-hierarchy的设计" class="headerlink" title="Memory hierarchy的设计"></a>Memory hierarchy的设计</h1><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>考虑到上述不同组件而特点，同时兼顾现实场景，我们对于存储器数据的的访问是等概率的吗？当然不是，肯定有最常访问的数据和程序；那些特定文件夹内吃灰的大部头书籍，肯定很少访问。基于这个现实考虑，人们依据 <code>principle of locality</code> 设计整个结构，有两种 locality:</p><ul><li><code>Temporal locality</code> (locality in time): if an item is referenced, it will tend to be referenced again soon.</li><li><code>Spatial locality</code> (locality in space): if an item is referenced, items whose addresses are close by will tend to be referenced soon.</li></ul><p>依据这两个locality进行了整体结构的设计。</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>这个结构有如下的特点：</p><ul><li>整个结构包含多个层次，每个层次的组件有不同的访问速度和容量；</li><li>访问速度越快，越靠近CPU，也越贵，同时容量也越小；速度慢的则完全相反；</li><li>不仅存储器呈现层次化，其中的数据也呈现层次化，<strong>靠近CPU存储器中的数据是底层存储器的子集，越靠近底层存储的数据越完整</strong>；</li><li>在这个结构中，<strong>仅仅两个相连的levels之间可以进行数据传递</strong>，所以我们只需要关注两个level即可；</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/6.png" alt="Memory Hierarchy整体结构"></p><h2 id="locality如何在结构中体现"><a href="#locality如何在结构中体现" class="headerlink" title="locality如何在结构中体现"></a>locality如何在结构中体现</h2><p>在整体结构中：</p><ul><li><code>temporal locality</code>: 体现在将访问频次高的数据放到顶层，靠近CPU；</li><li><code>spatial locality</code>: 体现在数据读取的最小单位上，电路中数据的存储以bit为单位，但是在memory hierarchy两个levels之间数据的传递，不是按照bit，甚至不是按照byte，而是按照 <code>block (line)</code>，这个是传递信息的最小单位，在底层level中的一段连续的存储单元，即要读就一起，因为彼此相连，可能会被访问。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://www.coursera.org/learn/jisuanji-zucheng/home/week/8">北京大学-计算机组成-第七讲：存储层次结构</a></p></li><li><p>Computer Organization and Design : the hardware/software interface</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储器 </tag>
            
            <tag> memory hierarchy </tag>
            
            <tag> memory </tag>
            
            <tag> cache </tag>
            
            <tag> disk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>述说Vulkan的历史及特点</title>
      <link href="/2022/10/14/ji-suan-ji-tu-xing-xue/vulkan/vulkan-de-li-shi-ji-te-dian/"/>
      <url>/2022/10/14/ji-suan-ji-tu-xing-xue/vulkan/vulkan-de-li-shi-ji-te-dian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>📌 由于工作的原因，开始进入计算机图形学的领域，开始研究Vulkan，后面会有一系列的学习总结文章，在此挖坑为证。</p></blockquote><h1 id="Vulkan的来源"><a href="#Vulkan的来源" class="headerlink" title="Vulkan的来源"></a>Vulkan的来源</h1><p>不管什么东西，我都喜欢了解一下历史，这样才会激起兴趣，了解它为什么出现、发展，乃至我为什么学习它。</p><p>在我最开始了解图形学时，还是本科的时候，那时候还是OpenGL的天下，因为后面也没有深入图形学领域，也就没有深究，现在开始工作了，发现虽然还是OpenGL占据主流，但是Vulkan、DirectX等API也在不断发展。</p><p>Vulkan最开始起源于AMD的Mantle，之后大家发现这个东西很不错，showcased cutting-edge capabilities，于是AMD就将它开源了，并捐给了Khronos，没错，就是那个掌握OpenGL的组织，这个Khronos是一个产业联盟，里面有很多的软硬件厂商，不包括巨硬。</p><blockquote><p>我发现，国外的企业很愿意把好东西捐给社区，一方面，建立了技术生态，为自己赚取名声，另一方面，由于是自己设计开发的，经常还可以占据主导地位，从而做大做强。</p></blockquote><p>从2016年开始，发布版本（我的mac是2015款的，不过后来发现即便是新款也需要<a href="https://github.com/KhronosGroup/MoltenVK">MoltenVK</a>, 经过一个中介才可以）。</p><h1 id="Vulkan到底是啥"><a href="#Vulkan到底是啥" class="headerlink" title="Vulkan到底是啥"></a>Vulkan到底是啥</h1><blockquote><p>Vulkan is a <strong>software interface</strong> that is capable of controlling GPU hardware settings to <strong>harness the power of paralleling computing.</strong></p></blockquote><ul><li>是一个interface，叫标准、协议也罢，就是大家约定一下，干同样的活遵循同样的步骤，别瞎干，形成了统一的规范后，有利于提高生产率，对于规范的实现，各家GPU厂商自己决定，这是竞争力的体现；</li><li>目的是啥？利用GPU并行计算的能力，说白了，让GPU好好干活，隐含地暗示，之前的API在这件事上做的不好；</li><li>怎么干？通过控制GPU的硬件设置，GPU可复杂了，如果要完全控制，那工作可繁琐了，这也是vulkan的优点，也是它的缺点。</li></ul><h1 id="Vulkan之前的API有啥问题"><a href="#Vulkan之前的API有啥问题" class="headerlink" title="Vulkan之前的API有啥问题"></a>Vulkan之前的API有啥问题</h1><p>之前最主要的是OpenGL，OpenGL本质上是一个state machine，通过控制各种状态，形成不同的组合，从而以最优的方式，达到最高的性能。但是，关键是但是，它的操作是implicit的，开发者有时候并不知道，而且OpenGL太想帮开发者做好各种工作了，但是随着各种复杂场景的出现，力有不逮，频频出错，导致各种问题。</p><p>核心是，OpenGL在之前的场景中，帮大家干得不错，管理的很高，但是现在人们群众的生活水平提高了，大家想要更好的游戏体验，但是OpenGL无法完全满足这种场景，或者说如果要满足，需要付出很大的代价。</p><p>相比于OpenGL这种，希望帮开发者多做事的设计思想，vulkan就很流氓了，老子不管了，出了问题是你们自己的事情，美其名曰开发者最了解自己的需求（当然这也没错啦），将所有的操作全部放到台面上，要干什么，让开发者自己决定，出了错也自己承担，这就是vulkan最核心的思想。</p><blockquote><p>这种思想我不止一次看到，之前在读书的时候，看到很多的设计思想也是这样的，而且，如果仔细看，有没有发现这两种思想和欧洲、美国的政治、社会文化很像，欧洲比社会主义还社会主义，就是OpenGL，太想把大家都照顾好了，可是各种出问题，福利、医疗等等，美国就是自己的事情自己负责，就是Vulkan代表的思想嘛，好处嘛：自己的事情自己负责，成功了是你的本事，上不封顶；坏处嘛：失败了你也别来找我，政府不给你兜底。</p></blockquote><h1 id="Vulkan有啥特点"><a href="#Vulkan有啥特点" class="headerlink" title="Vulkan有啥特点"></a>Vulkan有啥特点</h1><p>说起Vulkan，其实不只有他一家API，除了上面提到的OpenGL，还有巨硬家的DirectX，为了推自己的API，做的事情名声不太好。还有苹果家的Metal API，永远那么特立独行。但是后两个都是针对特定的平台的。</p><blockquote><p>这里Vulkan将跨平台作为优点说，也不是不可以，但是并不意味着针对特定平台的就不好，我觉得还是要中立看待，从商业角度看，苹果家只针对自己的平台做，软硬件融合的很好，只要对市场有足够的掌控力，这就是现金奶牛。</p></blockquote><p>由于OpenGL和Vulkan均是跨平台的，而且又都是Khronos家的，因此他俩比最合适。</p><h2 id="Vulkan减少了driver的工作"><a href="#Vulkan减少了driver的工作" class="headerlink" title="Vulkan减少了driver的工作"></a>Vulkan减少了driver的工作</h2><p>这就是前面提到的，将一些OpenGL driver做的工作放弃，全部交给开发者去做，让他们直接操纵底层硬件，这对于优秀的开发者来说就是好事，对于一些新手来说就是灾难。</p><p>这种设计，使得Vulkan的driver很thin，抛弃了很多责任，可以轻装上阵，因此可以使得GPU渲染地更快。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E7%89%B9%E7%82%B9/1.png" alt="Vulkan Driver的设计——thin"></p><p>Vulkan Driver的设计——thin</p><h2 id="Explicit的设计"><a href="#Explicit的设计" class="headerlink" title="Explicit的设计"></a>Explicit的设计</h2><p>之前说过OpenGL是implicit的，即悄悄地帮你把很多工作都做了，你还不知道（真是个好人）。但是呢，并不招人喜欢，因为管了太多的闲事，有时候还管不好。因此，Vulkan放弃了当这种好人的机会，把之前resource management等工作都甩给开发者，这种方式使得开发者可以看到所有的操作，也会知道哪里出现了问题。</p><h2 id="支持Multithread-scalability"><a href="#支持Multithread-scalability" class="headerlink" title="支持Multithread scalability"></a>支持Multithread scalability</h2><p>多个计算机中多CPU和多核的发展，多线程的能力决定了程序的性能。有<a href="https://www.youtube.com/watch?v=rvCD9FaTKCA">一个视频</a>对比了vulkan和OpenGL ES的能力：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E7%89%B9%E7%82%B9/2.png" alt="Vulkan和OpenGL多核CPU利用的对比"></p><p>对于多核CPU的利用：</p><ul><li>Vulkan是雨露均沾；</li><li>OpenGL ES是独宠一个；</li></ul><p>这是Vulkan多线程能力的一个体现。</p><h2 id="对内存的控制"><a href="#对内存的控制" class="headerlink" title="对内存的控制"></a>对内存的控制</h2><p>由于Vulkan是explicit，因此对于内存的控制，也是开放、透明的，允许开发者选择不同类型的内存来应用在资源上；相比之下，OpenGL把这部分工作也帮你做了，因为是implicit的。</p><p>这一点，还是在上面的视频中有体现，因为内存的访问不仅决定了性能，还决定了功耗：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E7%89%B9%E7%82%B9/3.png" alt="Vulkan和OpenGL功耗的对比"></p><p>vulkan比OpenGL ES更省电。</p><h2 id="统一的API"><a href="#统一的API" class="headerlink" title="统一的API"></a>统一的API</h2><p>我觉得可能是OpenGL被提出的太早，早期的API都是针对桌面的，后面以手机为代表的嵌入式设备不断发展，因此OpenGL中又提出了OpenGL ES，相比之下，Vulkan只有一套API，这样更统一、清晰。同时，手机等移动设备在Vulkan中是第一等公民的角色，而OpenGL中会先更新桌面版，之后再同步到ES。</p><h2 id="Error-check-amp-validation"><a href="#Error-check-amp-validation" class="headerlink" title="Error check &amp; validation"></a>Error check &amp; validation</h2><p>对于程序的错误和异常行为的检查是很重要的，尤其是在debug时，但是在release时就不需要这部分了。OpenGL ES隐式地帮所有程序都进行了错误的检查和验证，不管程序本身是否需要，一个不恰当的比喻，这就好比去西餐厅吃饭，餐厅不管你是否同意，默认帮你找了一个小提琴手演奏，但是之后你发现，这个服务不便宜，而且自己压根不需要。</p><p>相比之下，Vulkan将选择权交给了开发者本身，我们知道，Vulkan在driver中尽量少做事，因此错误的检查和验证不是标准的一部分，标准内的错误验证的功能也很弱。但是它作为了extension出现，形成validation layers，这部分不用被Vulkan的API显示调用，而是通过hook函数注入的，所以使用过程中可能会感知不到。</p><h2 id="Precompiled-shaders"><a href="#Precompiled-shaders" class="headerlink" title="Precompiled shaders"></a>Precompiled shaders</h2><p>在OpenGL ES中shader的代码通过GLSL编写，并且是动态编译的，也就是说在渲染时，OpenGL ES还要去编译shader，这显然更慢了。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E7%89%B9%E7%82%B9/4.png" alt="Untitled"></p><p>对比而言，Vulkan使用一种中间语言——Standard Portable Intermediate Language (SPIR-V)来表示shader程序，这个shader程序是预先编译好的，其中源代码可以是GLSL，通过Vulkan提供的工具预先编译成SPIR-V，从而减少了后续的工作时间，提升效率。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Book —— Learning Vulkan</li><li><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">Shader modules</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++:函数指针</title>
      <link href="/2022/10/12/bian-cheng-zhi-dao/c-han-shu-zhi-zhen/"/>
      <url>/2022/10/12/bian-cheng-zhi-dao/c-han-shu-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<blockquote><p>📌 参考C++ primer 6.7</p></blockquote><blockquote><p>A function pointer is just that—a pointer that denotes a function rather than an object.</p></blockquote><ul><li>a function pointer points to a particular type.</li><li>A function’s type is determined by its return type and the types of its parameters. The function’s name is not part of its type.  函数的类型，由返回值类型和参数类型决定，名称不起作用，这也是函数重载能成功的原因。</li></ul><h1 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h1><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 函数指针的声明, pf as a pointer to function bool(const string &amp;, const string &amp;)</span><span class="token comment" spellcheck="true">// (*pf)是整体，bool(const string &amp;, const string &amp;)是整体</span><span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 函数的声明, 该函数的类型为bool(const string &amp;, const string &amp;)</span><span class="token keyword">bool</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>函数指针</strong>的声明特别容易与<strong>返回指针类型的函数</strong>的声明混淆，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 不是函数指针的声明，而是一个返回指向bool类型指针的函数</span><span class="token comment" spellcheck="true">// pf(const string &amp;, const string &amp;) as a pointer to bool</span><span class="token comment" spellcheck="true">// pf(const string &amp;, const string &amp;) 是整体</span><span class="token keyword">bool</span> <span class="token operator">*</span><span class="token function">pf</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>所以，<strong>不要忘记那对括号</strong>。</p><p>当使用函数名称作为一个value，其自动转化为一个pointer。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 两种初始化方式等价，&amp;是可选的。</span>pf <span class="token operator">=</span> lengthCompare<span class="token punctuation">;</span>pf <span class="token operator">=</span> <span class="token operator">&amp;</span>lengthCompare<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可以使用空指针初始化，意味着该函数指针未指向任何函数</span>pf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pf <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 函数指针声明的类型，必须与用于初始化的函数类型相同</span><span class="token keyword">int</span> <span class="token function">sumLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cstringCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pf <span class="token operator">=</span> sumLength<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// error, 返回值类型不匹配</span>pf <span class="token operator">=</span> cstringCompare<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// error, 参数类型不匹配</span></code></pre><h1 id="函数指针的使用"><a href="#函数指针的使用" class="headerlink" title="函数指针的使用"></a>函数指针的使用</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>我们可以使用指向一个函数的指针，调用这个函数。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 三种方式等价，*也是可选的</span></code></pre><p>当调用重载函数时，compiler会根据函数指针中声明的类型，选择对应的重载函数之一进行调用，不要忘记，<strong>函数的类型由返回值类型和参数类型决定</strong>。</p><h2 id="函数指针作为参数"><a href="#函数指针作为参数" class="headerlink" title="函数指针作为参数"></a>函数指针作为参数</h2><p>函数中也不能定义函数类型(<code>function type</code>)作为参数，而是需要使用<code>pointer to function</code>, 和<a href="https://lifehit.cn/2022/10/11/bian-cheng-zhi-dao/c-shu-zu-zuo-wei-can-shu-jin-xing-chuan-di/">数组的方式</a>有点像。</p><p>在函数中如果要传递函数类型的参数，使用如下方式：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 两者的声明等价，</span><span class="token comment" spellcheck="true">// 一个隐式转为pointer to function</span><span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 一个显式定义为pointer to function</span><span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用如下</span><span class="token function">userBigger</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> lengthCompare<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中，当传递的参数为function type时，编译器会自动将其转为pointer to function. 这两种类型的区别，可以通过一个小例子查看：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pf <span class="token operator">=</span> lengthCompare<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">using</span> F <span class="token operator">=</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    F f<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">bool</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出：</span><span class="token comment" spellcheck="true">// PF: pointer to function</span><span class="token comment" spellcheck="true">// PFbRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7_E</span><span class="token comment" spellcheck="true">// F: function</span><span class="token comment" spellcheck="true">// FbRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7_E</span></code></pre><p>之前提过，C++中的类型过于复杂会导致问题，这里函数指针就遇到了这个问题，因此可以使用<strong>类型别名</strong>进行替代。在这里需要注意<code>function type</code>和<code>pointer to function</code> 两种类型的区别。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Func and Func2 have function type</span><span class="token keyword">typedef</span> <span class="token keyword">bool</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>lengthCompare<span class="token punctuation">)</span> Func2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// equivalent type</span><span class="token comment" spellcheck="true">// FuncP and FuncP2 have pointer to function type </span><span class="token keyword">typedef</span> <span class="token keyword">bool</span><span class="token punctuation">(</span> <span class="token operator">*</span>FuncP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>lengthCompare<span class="token punctuation">)</span> <span class="token operator">*</span>FuncP2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// equivalent type</span></code></pre><ul><li>Func和Func2均为function type;</li><li>FuncP和FuncP2均为pointer to function type;</li></ul><p>当作为函数的参数传递时，这两种方式均可以：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 两者声明等价</span><span class="token comment" spellcheck="true">// 编译器自动将function type转为pointer to function</span><span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> Func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接传递pointer to type</span><span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> FuncP2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="函数指针作为返回值"><a href="#函数指针作为返回值" class="headerlink" title="函数指针作为返回值"></a>函数指针作为返回值</h2><ul><li>函数指针还可以作为返回值，但是仍然不能返回函数类型，而是需要使用pointer to function.</li><li><strong>编译器不会自动将函数类型转为指针类型，需要显式给出</strong>；注意，这一点与将函数类型作为参数传递不同（那里会自动转为指针类型）。</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// F是function type</span><span class="token keyword">using</span> F <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// PF是pointer type</span><span class="token keyword">using</span> PF <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, return pointer to function</span>PF <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error, return function type</span>F <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, return pointer to function</span>F <span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 可以使用auto + trailing return 简写</span><span class="token keyword">auto</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">(</span> <span class="token operator">*</span> <span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="推导函数指针类型"><a href="#推导函数指针类型" class="headerlink" title="推导函数指针类型"></a>推导函数指针类型</h2><p>这里的pointer to function 和 function type各种写法混在一起，非常容易出错，无法理解。因此，可以使用<code>decltype</code>等来推导，如下：</p><pre class=" language-cpp"><code class="language-cpp">string<span class="token operator">::</span>size_type <span class="token function">sumLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> string<span class="token operator">::</span>size_type <span class="token function">largerLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>sumLength<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">getFcn</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里需要注意的是：当对函数使用decltype时，返回的是<code>function  type</code>，不是 <code>pointer to function</code>, 因此在<code>getFcn</code>前的<code>*</code>千万不能忘记。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> 函数指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++:表达式类型带来的困扰</title>
      <link href="/2022/10/12/bian-cheng-zhi-dao/c-zhong-lei-xing-de-kun-rao/"/>
      <url>/2022/10/12/bian-cheng-zhi-dao/c-zhong-lei-xing-de-kun-rao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>📌 参考C++ primer 2.5</p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在大型程序中，对象的类型往往十分复杂，例如，一个函数指针的类型，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> b <span class="token operator">&amp;</span><span class="token punctuation">)</span></code></pre><p>当作为一个整体放到函数中作为参数时，即冗长，不好理解，又容易出错，鉴于这种情况，我们需要一些解决办法。</p><h1 id="类型别名-type-alias"><a href="#类型别名-type-alias" class="headerlink" title="类型别名 type alias"></a>类型别名 type alias</h1><blockquote><p>A type alias is a name that is a synonym for another type.</p></blockquote><p>定义类型的别名，可以通过两种方式。</p><h2 id="通过typedef定义"><a href="#通过typedef定义" class="headerlink" title="通过typedef定义"></a>通过typedef定义</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 定义double的别名是wages</span><span class="token keyword">typedef</span> <span class="token keyword">double</span> wages<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 定义wages(double)的别名是base, 定义double *的别名是p;</span><span class="token comment" spellcheck="true">// 相当于typedef wages base; typedef wages * p;</span><span class="token keyword">typedef</span> wages base<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>wages i <span class="token operator">=</span> <span class="token number">1.3</span><span class="token punctuation">;</span>p k <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出Pd, 代表pointer to double</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><h2 id="通过using定义"><a href="#通过using定义" class="headerlink" title="通过using定义"></a>通过using定义</h2><blockquote><p>The new standard introduced a second way to deﬁne a type alias, via an <strong>alias declaration</strong>.</p></blockquote><ul><li>An alias declaration starts with the keyword <em><strong>using</strong></em> followed by the alias name and an =.</li><li>The alias declaration deﬁnes the name on the left-hand side of the = as an alias for the type that appears on the right-hand side.</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">using</span> SI <span class="token operator">=</span> Sales_item<span class="token punctuation">;</span>SI si<span class="token punctuation">;</span></code></pre><h2 id="Pointer-amp-const中使用的注意事项"><a href="#Pointer-amp-const中使用的注意事项" class="headerlink" title="Pointer &amp; const中使用的注意事项"></a>Pointer &amp; const中使用的注意事项</h2><p>当类型别名与复杂类型，如pointer等一起使用时，会出现一些难以理解的事情。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span> pstring<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 定义pstring为指向char的指针类型， pointer to char</span><span class="token keyword">const</span> pstring cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// cstr is a constant pointer to char </span><span class="token keyword">const</span> pstring <span class="token operator">*</span>ps<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// ps is a pointer to a constant pointer to char</span></code></pre><p>在我们的使用，如果要判断具体的类型，会倾向于将类型替换为原始类型，如：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> pstring cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可以变成， 容易误解</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// cstr is a pointer to const char</span></code></pre><p>但是这种替换，导致了错误的理解，这里cstr不是<code>pointer to const char</code>, 而是 <code>const pointer to char</code>.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span> pstring<span class="token punctuation">;</span><span class="token keyword">const</span> pstring cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 能修改</span><span class="token operator">*</span>cstr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 错误，不能修改</span>cstr <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>pstring<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出：Pc 代表pointer to char</span></code></pre><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E4%B8%AD%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%B0%E6%89%B0/1.png" alt="上述代码输出"></p><ul><li>这里对于 *cstr = 1，没有报错，说明并不是<code>pointer to const char</code>;</li><li>对cstr = &amp;a报错，说明cstr本身是const，即<code>const pointer to char</code>;</li></ul><blockquote><p>这里进行类型替换理解时，需要将pstring整体考虑，即全部都是类型，不能将char * 拆开来看。可以这样理解，pstring是一个指针类型，这是正确的，将pstring视为一个类似int等的简单类型，因此 const pstring就是const pointer，不是pointer to const.</p></blockquote><h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>当类型很复杂时，判断表达式的类型有时很困难，容易出错，C++11提出auto来告诉编译器推断表达式的类型。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// item为int</span><span class="token keyword">auto</span> item <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, int i, int *p</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error, int sz, double pi</span><span class="token keyword">auto</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span></code></pre><p><strong>当在一个声明中，出现多个初始化操作时，要保证所有变量的base type是一致的。</strong></p><h2 id="复杂类型中auto的奇异表现"><a href="#复杂类型中auto的奇异表现" class="headerlink" title="复杂类型中auto的奇异表现"></a>复杂类型中auto的奇异表现</h2><p>对于复杂类型，比如，指针、引用等，auto的结果并不一定是基本数据类型中那么直接，而是编译器会调整。</p><ul><li>对于reference<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// c 为int, 不是 int&amp;</span><span class="token keyword">auto</span> c <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出: i</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre></li><li>对于const<ul><li>忽略 top-level const</li><li>保留 low-level const</li></ul>  top-level const和low-level const是啥，可以参考<a href="https://lifehit.cn/2022/10/07/bian-cheng-zhi-dao/c-const-guan-jian-zi/">这里</a>.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cr <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token keyword">auto</span> b <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token keyword">auto</span> c <span class="token operator">=</span> cr<span class="token punctuation">;</span><span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">auto</span> e <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出</span>i<span class="token operator">:</span> <span class="token keyword">int</span>i<span class="token operator">:</span> <span class="token keyword">int</span>Pi<span class="token operator">:</span> pointer to <span class="token keyword">int</span>PKi<span class="token operator">:</span> pointer to <span class="token keyword">const</span> <span class="token keyword">int</span></code></pre>  因为，auto忽略了top-level const，如果想要保证变量为const，需要显式说明:<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">auto</span> f <span class="token operator">=</span> ci<span class="token punctuation">;</span></code></pre></li><li>对于自动推导类型的reference:  此时，<strong>top-level const不再忽略了，而是保留下来。</strong><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// g 为reference to auto - int, ci的const被保留，因此为const int &amp;, 不是 int或int &amp;</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>g <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error, 是字面量，无法取引用</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>h <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok. j 为 const reference, 不是 reference to const int</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span></code></pre>  这里，跟typedef一样，使用const修饰auto或者typedef定义的类型时，const得到的是const reference(技术上不存在这个概念)或者 const pointer。</li></ul><h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>使用auto时, a variable that uses auto as its type speciﬁer must have an initializer. 但是，并不是每个变量都要初始化，比如函数返回值，此时auto无法使用，可以使用<code>decltype</code>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 不会调用f(), 而是使用返回值类型作为sum的类型</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> sum <span class="token operator">=</span> x<span class="token punctuation">;</span></code></pre><h2 id="复杂类型下的表现"><a href="#复杂类型下的表现" class="headerlink" title="复杂类型下的表现"></a>复杂类型下的表现</h2><ul><li>decltype returns the type of that variable, including top-level const and references.  这一点与auto的表现不同。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cj <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// x has type const int </span><span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// y has type const int&amp; and is bound to x </span><span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> z<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: z is a reference and must be initialized</span></code></pre></li><li>Generally speaking, decltype returns a reference type for expressions that yield objects that can <strong>stand on the left-hand side of the assignment</strong>.  即，decltype推断表达式的类型时，当该表达式可以作为左值时，返回的是它的引用，不是原始类型。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// r + 0 不能作为左值</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: addition yields an int; b is an (uninitialized) int </span><span class="token comment" spellcheck="true">// *p 可以作为左值，接受赋值</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> c<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: c is int&amp; and must be initialized</span></code></pre></li><li>Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression.  在decltype中使用()将变量包起来，会影响类型的推断。<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// decltype of a parenthesized variable is always a reference </span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> d<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: d is int&amp; and must be initialized </span><span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> e<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: e is an (uninitialized) int</span></code></pre><blockquote><p>📌 Remember that decltype((variable)) (note, double parentheses) is always a reference type, but decltype(variable) is a reference type only if variable is a reference.</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> auto </tag>
            
            <tag> decltype </tag>
            
            <tag> typedef </tag>
            
            <tag> 表达式类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++:数组作为参数进行传递</title>
      <link href="/2022/10/11/bian-cheng-zhi-dao/c-shu-zu-zuo-wei-can-shu-jin-xing-chuan-di/"/>
      <url>/2022/10/11/bian-cheng-zhi-dao/c-shu-zu-zuo-wei-can-shu-jin-xing-chuan-di/</url>
      
        <content type="html"><![CDATA[<blockquote><p>📌 来自C++ primer中的6.2.4部分</p></blockquote><h1 id="数组的特性"><a href="#数组的特性" class="headerlink" title="数组的特性"></a>数组的特性</h1><ul><li>数组名称作为指向其中第一个元素的pointer；</li><li>数组不能被copy<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 错误，不能用一个数组初始化另一个数据</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误，不能数组赋值和copy</span></code></pre><blockquote><p>📌 有些编译器允许数组赋值，但是这种是作为compiler extension存在的，不是标准支持的语法，跨编译器时可能会存在问题。</p></blockquote></li></ul><h1 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h1><p>基于数组的特性，不能复制，因此无法使用数组作为函数的形参，也就不能按值传递数组；但是，可以利用另一个特性，向函数传递数组名称作为第一个元素的指针。</p><h2 id="声明数组作为函数参数"><a href="#声明数组作为函数参数" class="headerlink" title="声明数组作为函数参数"></a>声明数组作为函数参数</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 三种声明等价，忽略它们定义的样子</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述三种方式中，函数的参数均为<code>const int*</code>. 因此，当函数调用时，判断传入的参数时，只会按照这个类型进行匹配。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, int *类型，可以传入</span><span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ok, 数组的维度不相关</span></code></pre><p>这里，数组的维度即使不匹配也没问题，因为不影响。</p><p>但是，因此函数也不知道数组的大小了，为了进行遍历，需要一些额外的方法，共有3种。</p><h2 id="依赖数组中的变量类型存在标识符"><a href="#依赖数组中的变量类型存在标识符" class="headerlink" title="依赖数组中的变量类型存在标识符"></a>依赖数组中的变量类型存在标识符</h2><p>典型的就是C风格的字符串，结尾有“\0” null charactor. 因此，可以根据这个判断是否到结尾，如下:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">*</span>cp<span class="token punctuation">)</span><span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>cp<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这种方法对于字符串等类型友好，但是不适用于如int等类型的数据，因为没有结尾标识符。</p><h2 id="传递数组的收尾指针"><a href="#传递数组的收尾指针" class="headerlink" title="传递数组的收尾指针"></a>传递数组的收尾指针</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> beg<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>beg <span class="token operator">!=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>beg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        beg<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中：</p><ul><li>begin返回第一个元素的指针；</li><li>end返回最后一个元素之后的指针，注意，这个指针指向的元素不在数组中，但是是有效的指针value；</li></ul><p>这种方法，通用，安全，不受类型的限制。</p><h2 id="显式传递数组长度"><a href="#显式传递数组长度" class="headerlink" title="显式传递数组长度"></a>显式传递数组长度</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> ia<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">int</span> j<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种方法也是安全的，但是要保证size与ia的长度是一致的。</p><h1 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h1><ul><li>上述函数的定义中，参数均为 pointer to const；<blockquote><p>When a function does not need write access to the array elements, the array parameter should be a pointer to const. A parameter should be a plain pointer to a nonconst type only if the function needs to change element values.</p></blockquote></li><li>reference对于数组参数的影响  对于一个数组变量，可以定义它的reference, 对于函数参数中数组，也可以定义数组的reference，但是会有一点迷惑。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> elem <span class="token operator">:</span> arr<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> elem <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 1. arr[10] stores ten reference to ints.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 2. 表示，arr is a reference to an array of ten ints, (&amp;arr)中括号必须存在</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>  对第一个来说，因为数组的维度是数组类型的一部分，当调用函数<code>print(int (&amp;arr)[10])</code>时，必须保证维度相同。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> k<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: argument is not an array of ten ints </span><span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: argument is not an array of ten ints </span><span class="token function">print</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: argument is an array of ten ints</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 参数传递 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++:const关键字</title>
      <link href="/2022/10/07/bian-cheng-zhi-dao/c-const-guan-jian-zi/"/>
      <url>/2022/10/07/bian-cheng-zhi-dao/c-const-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💡 本篇的内容来自C++ Primer中的2.4节</p></blockquote><h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><h2 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h2><blockquote><p>We can make a variable unchangeable by deﬁning the variable’s type as <strong>const</strong>.</p></blockquote><ul><li>因为const变量，不能改变，因此必须初始化。</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确，runtime初始化 </span><span class="token keyword">const</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 正确，compile time初始化</span><span class="token keyword">const</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 错误，没有初始化</span></code></pre><p>const变量可以接受那些无法改变变量本身数据的操作，例如赋值和copy等。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token keyword">int</span> j <span class="token operator">=</span> ci<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 正确，j初始化后，与ci无关。</span></code></pre><h2 id="特性：const-Objects-Are-Local-to-a-File"><a href="#特性：const-Objects-Are-Local-to-a-File" class="headerlink" title="特性：const Objects Are Local to a File"></a>特性：const Objects Are Local to a File</h2><ul><li>const variables are deﬁned as local to the ﬁle.</li><li>When we deﬁne a const with the same name in multiple ﬁles, it is as if we had written deﬁnitions for separate variables in each ﬁle.</li></ul><p>对于const变量，规定其只在本文件中起作用。</p><blockquote><p>为什么这样规定？这要提到compiler。对于<code>const int bufSize = 512</code>这种使用编译时常量初始化const变量时， 在编译时，编译器会将所有提到的变量进行替换，为了完成替换，编译器必须知道初始化值，当程序分成多个文件时，为了支持编译器的这种操作，需要在所有使用该变量的多个文件中定义同名的const变量，这是我们不愿见到的，因此定义const变量只在本文件生效。</p></blockquote><p>当在一个文件中定义了const变量，但是想在另一个文件中使用，需要使用<code>extern</code>关键字。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// file_1.cc deﬁnes and initializes a const that is accessible to other ﬁles </span><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bufSize <span class="token operator">=</span> <span class="token function">fcn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// file_1.h </span><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bufSize<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// same bufSize as deﬁned in file_1.cc</span></code></pre><p>这样可以实现const变量的共享。</p><h1 id="References-to-const"><a href="#References-to-const" class="headerlink" title="References to const"></a>References to const</h1><blockquote><p>我想，有时候学技术，还是要看英文原版的说明，用词更准确和直接。</p></blockquote><h2 id="澄清概念"><a href="#澄清概念" class="headerlink" title="澄清概念"></a>澄清概念</h2><p>这里首先明确 <strong>references to const</strong> 指的是：</p><ul><li>bind a reference to an object of a const type.</li><li>the object is a reference that refers to a const type;</li></ul><p>但是，这种对于const的引用，不能通过引用改变其值。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: both reference and underlying object are const </span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> ci<span class="token punctuation">;</span> r1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// error: r1 is a reference to const</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> ci<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// error: nonconst reference to a const object</span></code></pre><p>我们在之前讲引用时，提到<strong>引用必须初始化，且在整个生命周期中，不能改变其绑定的变量</strong>。因此，这里需要澄清一下references to const 中易于混淆的概念：</p><ul><li>有人认为：references to const即为 const references，这会造成误解，其实本质不同；</li><li>由于引用本身不能更换引用的对象，因此 in some sense all references are const，或者说，技术上，不存在const references；</li><li>我们一直提的const，不能改变，其实指的是reference to const中，不能通过该引用改变其绑定的值；</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在引用中，引用本身的类型必须与绑定的变量的类型匹配，但是加入了const后，就出现了例外。</p><h3 id="const对reference初始化的影响"><a href="#const对reference初始化的影响" class="headerlink" title="const对reference初始化的影响"></a>const对reference初始化的影响</h3><p>reference必须初始化，且终生不能改变绑定对象；而且其引用的对象类型必须与自己相匹配；且初始化时使用的表达式只能是objects, 不能是 literal 或者运算表达式。</p><p>但是const的使用改变了这些规则。</p><blockquote><p>we can initialize a <strong>reference to const</strong> from any expression that can be converted to the type of the reference.</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// ok: r1 is a reference to const </span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r3 <span class="token operator">=</span> r1 <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: r3 is a reference to const</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r4 <span class="token operator">=</span> r <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//error: r4 is a plain, nonconst reference</span></code></pre><p>对于类型不匹配的也是可以的，其中存在隐式类型转换。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>i <span class="token operator">=</span> dval<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 输出3</span></code></pre><blockquote><p>这里可以这样理解，编译器会生成一个临时变量  const int temp = dval, 然后通过i 引用该temp，所以i 并没有直接引用dval。</p></blockquote><h3 id="references-to-const可以绑定非常量对象"><a href="#references-to-const可以绑定非常量对象" class="headerlink" title="references to const可以绑定非常量对象"></a>references to const可以绑定非常量对象</h3><p>我们提到references to const不能改变绑定对象的值，但是并不意味着绑定对象只能是const变量，只要保证无法通过references to const改变其值即可，因此绑定对象可以为非常量。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> i<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// ok </span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok </span>r1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// ok, i可以改变</span>r2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// error， i不能通过r2改变</span></code></pre><p>所谓，功成不必在我。</p><h1 id="Pointers-and-const"><a href="#Pointers-and-const" class="headerlink" title="Pointers and const"></a>Pointers and const</h1><h2 id="pointer-to-const"><a href="#pointer-to-const" class="headerlink" title="pointer to const"></a>pointer to const</h2><p>使用指针指向一个const变量，是可行的，但是前提是该pointer是一个pointer to const。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>   <span class="token keyword">double</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// error: ptr is a plain pointer</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, pointer to const</span><span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// error: cannot assign to *cptr</span></code></pre><p>注意事项：</p><ul><li>pointer to const: 指向的对象不一定是const，这个有一点离奇，但是就是这么回事，其核心要强调的点是：通过该pointer to const不能改变指向对象的值，但是该对象的值可以通过别的方式改变；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span><span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token number">1.23</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span><span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">1.23</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span></code></pre></li></ul><h2 id="const-pointer"><a href="#const-pointer" class="headerlink" title="const pointer"></a>const pointer</h2><ul><li>与reference不同，pointer是一个object, 因此其本身也可以是const的。</li><li>const pointer指的是该pointer本身不能改变，即不能指向其他的对象；</li><li>同一般的reference一样，也必须进行初始化；</li><li>最容易的理解方式：还是从右往左读；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> errNumb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> curErr <span class="token operator">=</span> <span class="token operator">&amp;</span>errNumb<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// const pointer</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>errNUmb<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pointer to const </span><span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span><span class="token keyword">const</span> pip <span class="token operator">=</span> <span class="token operator">&amp;</span>pi <span class="token comment" spellcheck="true">// const pointer and pointer to const</span></code></pre></li><li>对于const pointer，与pointer to const一样，对于所指向的对象是否为const，没有限制；</li></ul><h2 id="Top-level-const"><a href="#Top-level-const" class="headerlink" title="Top-level const"></a>Top-level const</h2><p>这里只是一个名词的解释：</p><ul><li>top-level const: indicate that the pointer itself is a const;</li><li>low-level const: indicate that a pointer can point to a const object;</li></ul><p>这两个名词，从英文来看很好理解，有什么用呢？语法规定：</p><ul><li>Top-level const can appear in any object type;</li><li>Low-level const appears in the base type of compound types such as pointers or references;  因为只有指针和引用可以指向别的对象。</li></ul><aside>📌 The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level consts are ignored and low-level const is never ignored.</aside><p>什么意思？</p><ul><li>在const对象和非const之间可以随便赋值，拷贝对象，不限制一定是const；</li><li>但是，在pointer to const对象中，如果进行赋值和拷贝，两者必须都是pointer to const.  这样保证，即便发生了复制，也不能通过新的pointer改变指向的对象的值。</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// error</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span></code></pre><h1 id="Constant-Expressions"><a href="#Constant-Expressions" class="headerlink" title="Constant Expressions"></a>Constant Expressions</h1><blockquote><p>A constant expression is an expression whose value cannot change and that can be evaluated <strong>at compile time</strong>.</p></blockquote><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const修饰的一定是constant expression吗？不一定，因为这些值不一定是compile time时确定的, 即：const并不会区分runtime 和compile time变量。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// sz is not a constant expression</span></code></pre><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><h3 id="编译时检查"><a href="#编译时检查" class="headerlink" title="编译时检查"></a>编译时检查</h3><p>由于const与constant expression, 即不是充分条件，也不是必要条件，但是会让人混淆。在C++11中，constexpr被提出，让compiler确认，通过其修饰的一定是compile time常量，即constant expression, 因此其一定必须初始化。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> mf <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 20 is a constant expression constexpr </span><span class="token keyword">int</span> limit <span class="token operator">=</span> mf <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mf + 1 is a constant expression constexpr </span><span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok only if size is a constexpr function</span></code></pre><p>因此，最好使用constexpr代替const，使得能够在compile time时进行检查。</p><blockquote><p>数组的维度，也是在compile time检查的，可以结合进行验证。</p></blockquote><h3 id="literal-types"><a href="#literal-types" class="headerlink" title="literal types"></a>literal types</h3><p>由于constexpr变量在编译时验证，因此其应用的类型也受到限制，只能是literal types:</p><ul><li>arithmetic, reference, and pointer types are literal types.</li><li>the library IO and string types are not literal types.</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> string i <span class="token operator">=</span> <span class="token string">"hello, world"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error, c++20可以</span></code></pre><h3 id="pointers"><a href="#pointers" class="headerlink" title="pointers"></a>pointers</h3><blockquote><p>when we deﬁne a pointer in a constexpr declaration, the constexpr speciﬁer applies to the pointer, not the type to which the pointer points.</p></blockquote><p>constexpr产生的是 <strong>top-level const</strong> on the objects it defines.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// p is a pointer to a const int</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// q is a const pointer to int</span><span class="token keyword">constexpr</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p is a constant pointer to the const int i</span></code></pre><p>这语法，C++ NB。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常量 </tag>
            
            <tag> const </tag>
            
            <tag> constexpr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++:数组的使用以及相关内容</title>
      <link href="/2022/10/07/bian-cheng-zhi-dao/c-shu-zu-de-shi-yong-yi-ji-xiang-guan-nei-rong/"/>
      <url>/2022/10/07/bian-cheng-zhi-dao/c-shu-zu-de-shi-yong-yi-ji-xiang-guan-nei-rong/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💡 本篇的内容来自C++ Primer中的3.5节</p></blockquote><h1 id="Define-amp-Initialize"><a href="#Define-amp-Initialize" class="headerlink" title="Define &amp; Initialize"></a>Define &amp; Initialize</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>数组像指针和引用一样是复杂类型，数组的形式<code>a[d]</code>,</p><ul><li>其中 a为name；</li><li>d为dimension，必须大于0。<blockquote><p>The number of elements in an array is part of the array’s type.</p></blockquote>  因此，dimension必须<strong>在编译时已知</strong>，因此它必须是一个constant。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> cnt <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// not a constant expression </span><span class="token keyword">constexpr</span> <span class="token keyword">unsigned</span> sz <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// constant expression</span></code></pre><blockquote><p>📌 但是，这种问题在g++和clang++编译时可能不会报错，这是因为这些<strong>编译器提供了扩展</strong>，将这种写法视为正确，但是建议禁止这些特性，因为会导致无法在别的compiler中成功运行，在g++和clang++对应的选项是-pedantic-errors。</p></blockquote></li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="隐式"><a href="#隐式" class="headerlink" title="隐式"></a>隐式</h3><p>数组的初始化与数据元素的类型（内置类型、复合类型）、变量作用域（全局变量、局部变量）有关。</p><ul><li>string类型数组全部初始化为空串，无论全局还是局部；</li><li>int类型在全局则全部初始化为0，在函数内部则undefined，如果尝试拷贝或者输出这些变量，会有奇怪的事情发生；</li></ul><p>因此，<strong>千万要显示初始化，不要留有悬疑空间</strong>。</p><h3 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h3><ul><li>将初始化元素全部列出，此时可以忽略dimension；<ul><li>compiler会自动推导；</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li><li>如果给定dimension，初始化元素不能超过它；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a5<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: too many initializers</span></code></pre></li><li>如果初始化元素数量小于dimension，使用默认初始化；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a3<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// equivalent to a3[] = {0, 1, 2, 0, 0} </span>string a4<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"hi"</span><span class="token punctuation">,</span> <span class="token string">"bye"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// same as a4[] = {"hi", "bye", ""} </span></code></pre></li></ul><h2 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h2><p>通过对数组遍历可以访问其中的元素，在C++中遍历数组，除了经典的for循环和while循环外，在C++11中还可以使用类似Java中for…each循环。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> ai<span class="token operator">:</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> ai <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在数组的访问中，<strong>当出现数组越界等问题时，会出现buffer overflow等bug</strong>，而且这些bug在编译时往往难以检查出来，只能在运行时出现异常。</p><h1 id="Array-vs-Vector"><a href="#Array-vs-Vector" class="headerlink" title="Array vs Vector"></a>Array vs Vector</h1><table><thead><tr><th></th><th>array</th><th>vector</th></tr></thead><tbody><tr><td>存放数据类型</td><td>必须是相同类型</td><td>必须是相同类型</td></tr><tr><td>访问存放元素</td><td>无名字，必须通过位置访问</td><td>无名字，必须通过位置访问</td></tr><tr><td>容量</td><td>固定，不能扩展，性能较好</td><td>不固定，能扩展，但是损害性能</td></tr><tr><td>数组维度获取</td><td>无size函数：(1)对于字符数组，可以用<code>strlen</code>；(2)其他数组，只能用<code>sizeof(array)/sizeof(array[0])</code>计算长度；(3)<code>end(array) - begin(array)</code>(c++11)</td><td>有size函数</td></tr><tr><td>下标类型</td><td>可以为负值，涉及指针的算数运算，即便为负值，也需要指向原始数组中的元素。</td><td>必须为非负值</td></tr></tbody></table><p>两者之间的转换：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> int_arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ivec has six elements; each is a copy of the corresponding element in int_arr </span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ivec</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>int_arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>int_arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// subset</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">subVec</span><span class="token punctuation">(</span>int_arr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> int_arr <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="Array-amp-Pointer"><a href="#Array-amp-Pointer" class="headerlink" title="Array &amp; Pointer"></a>Array &amp; Pointer</h1><ul><li><strong>arrays hold objects, 因此可以存储pointers，但是references不是objects, 因此不能存储references。</strong></li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li>数组中的元素均为objects（因此有地址，对比reference不是objects, 因此没有地址）, 因此可以将这些元素的地址赋值给指针；<pre class=" language-cpp"><code class="language-cpp">string nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> string <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p points to the ﬁrst element in nums</span></code></pre></li><li>存储指针的数组<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>parr<span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// array of 42 pointers to int</span><span class="token comment" spellcheck="true">// -----</span><span class="token comment" spellcheck="true">// parr[sz] stores pointers to int. </span></code></pre>  这里容易混乱.<blockquote><p>By default, <em><strong>type modiﬁors bind right to left</strong></em>.</p></blockquote></li></ul><h2 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h2><ul><li>特殊性质：<strong>多数情况下，编译器将数组名称视为第一个元素的指针</strong>；<pre class=" language-cpp"><code class="language-cpp">string <span class="token operator">*</span>p2 <span class="token operator">=</span> nums<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//equivalent to p2 = &amp;nums[0]</span></code></pre></li><li>数组的操作经常可以认为是指针的操作；<ul><li>when we use an array as an initializer for a variable deﬁned using <strong>auto</strong>, the deduced type is a pointer, not an array.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ia is an array of ten ints </span><span class="token keyword">auto</span> <span class="token function">ia2</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ia2 is an int * that points to the ﬁrst element in ia </span>ia2 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: ia2 is a pointer, and we can’t assign an int to a pointer</span></code></pre></li><li>when we use <strong>decltype</strong>. The type returned by decltype(ia) is array of ten ints.<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ia3 is an array of ten ints </span><span class="token keyword">decltype</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span> ia3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span> ia3 <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: can’t assign an int * to an array </span>ia3<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: assigns the value of i to an element in ia3</span></code></pre></li></ul>  <aside>  📌 建议：这里容易混乱的，就不要在实践中使用。    </aside>  </li></ul><h2 id="Pointers-are-Iterators"><a href="#Pointers-are-Iterators" class="headerlink" title="Pointers are Iterators"></a>Pointers are Iterators</h2><h3 id="off-the-end-pointer"><a href="#off-the-end-pointer" class="headerlink" title="off-the-end pointer"></a>off-the-end pointer</h3><p> 前面提到数组的名字可以视为指向其中第一个元素的指针，因此可以通过对名称进行加减操作，来移动指向地址的位置，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p points to the first element in arr </span><span class="token operator">++</span>p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p points to arr[1]</span></code></pre><p>基于这种特性，可以使用point对array中的元素进行遍历。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pointer just past the last element in arr</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> b <span class="token operator">=</span> arr<span class="token punctuation">;</span> b <span class="token operator">!=</span> e<span class="token punctuation">;</span> <span class="token operator">++</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// print the elements in arr</span><span class="token punctuation">}</span></code></pre><p>其中，<code>&amp;arr[10]</code>是4种有效的指针数据之一，在<a href="https://lifehit.cn/2022/09/18/bian-cheng-zhi-dao/reference-he-pointer/">指针知识部分</a>有说明, 这是一种off-the-end pointer, 非常易于出错。</p><h3 id="begin-amp-end"><a href="#begin-amp-end" class="headerlink" title="begin &amp; end"></a>begin &amp; end</h3><p>在c++11种提出，begin和end函数：</p><ul><li>begin returns a pointer to the ﬁrst;</li><li>end returns a pointer one past the last element in the given array:</li><li>These functions are deﬁned in the iterator header.</li></ul><p>使用如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>pbeg <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>pend <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>pbeg <span class="token operator">!=</span> pend<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pbeg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    pbeg<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这种方法，本质上与off-the-end pointer的做法相同，end函数得到的还是末端之外的指针，但是不用显式操作指针计算，更加安全。</p><h3 id="pointer算数运算"><a href="#pointer算数运算" class="headerlink" title="pointer算数运算"></a>pointer算数运算</h3><p>Pointers that address array elements can use all the iterator operations listed in  the following tables.</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++:%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/table1.png" alt="pointer算数运算1"></p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++:%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/table2.png" alt="pointer算数运算2"></p><p>几个典型的使用如下：</p><ul><li>指针偏移形成新的指针；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ip <span class="token operator">=</span> arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// equivalent to int * ip = &amp;arr[0] </span><span class="token keyword">int</span> <span class="token operator">*</span>ip2 <span class="token operator">=</span> ip <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ip2 points to arr[4]</span><span class="token comment" spellcheck="true">// 注意：这两种写法，意义完全不同</span><span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// == arr[4]</span>last <span class="token operator">=</span> <span class="token operator">*</span>arr <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// == arr[0] + 4</span></code></pre>  此时要保证，新的指针ip2必须指向ip所指向的数组，否则出错。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> arr <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确，但是使用*p3取数据出错，因为是off-the-end pointer</span><span class="token keyword">int</span> <span class="token operator">*</span>p4 <span class="token operator">=</span> arr <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误，超出范围</span></code></pre></li><li>指针之间相减<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//n is 5, the number of elements in arr</span></code></pre><ul><li>The result of subtracting two pointers is a library type named <code>ptrdiff_t</code>.</li><li>Like <code>size_t</code>, the <code>ptrdiff_t</code> type is a machine-speciﬁc type and is deﬁned in the <code>cstddef</code> header.</li><li><code>ptrdiff_t</code> is a signed integral type.</li></ul>  相减的结果，可以为负数，因此，指针不同于vector，其下标可以为负值，但是必须指向原始数组中的元素。</li><li>指针相比较<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span> b <span class="token operator">=</span> arr<span class="token punctuation">,</span> <span class="token operator">*</span>e <span class="token operator">=</span> arr <span class="token operator">+</span> sz<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// use *b</span>    <span class="token operator">++</span>b<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre>  此时，进行的比较的指针必须均对应相同的数组（或者off-the-end元素），否则没有意义。  <aside>  📌 对于null pointer 也是可以比较的。    </aside>  <pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p <span class="token operator">-</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ia <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ia <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> ia <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// --- output ---</span><span class="token number">0x0</span><span class="token number">0x4</span><span class="token number">1</span><span class="token number">10</span><span class="token number">10</span><span class="token number">0x7ffee03e32fc</span></code></pre></li></ul><h1 id="Array-amp-String"><a href="#Array-amp-String" class="headerlink" title="Array &amp; String"></a>Array &amp; String</h1><h2 id="C-Style-Character-Strings"><a href="#C-Style-Character-Strings" class="headerlink" title="C-Style Character Strings"></a>C-Style Character Strings</h2><p>因为C++继承了C语言，因此C语言中关于字符串的使用方式也被继承下来。</p><aside>📌 但是，C语言中的字符串很难使用，而且是很多安全问题的根源，容易引入各种bugs，因此在C++语言中应该强烈避免使用这种风格的字符串形式，而应该使用<strings>代替，不仅安全，而且效率更高。</aside><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>C语言中的字符串，是使用char[]表示的，一个重要的地方是，这些字符数组必须均以null charactor <code>\0</code>结尾。</p><ul><li>C-style strings are not a type.<ul><li>they are a convention for how to represent and use character strings.</li><li>Strings that follow this convention are stored in character arrays and are null terminated.</li><li>By null-terminated we mean that the last character in the string is followed by a null character (’\0’).</li></ul></li><li>Ordinarily we use pointers to manipulate these strings.</li></ul><p>在C语言，操作字符串，更多是使用pointer完成，这也是此处将pointer和string放到一起的原因之一。</p><p>这种使用方式中，字符串的初始化可以有以下几种：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">char</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'+'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 声明没有问题，但是未使用\0结尾，只能当做字符数组使用，当做字符串使用或相关函数中会出现问题</span><span class="token keyword">char</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确方式</span><span class="token keyword">char</span> a3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"C++"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 正确方式，结尾自动添加了\0</span><span class="token keyword">const</span> <span class="token keyword">char</span> a4<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Daniel"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译时错误，该字符串包括\0占据7个，空间不够</span><span class="token comment" spellcheck="true">// 查看长度</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">end</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出3</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">end</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出4</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">end</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出4</span><span class="token comment" spellcheck="true">// 输出字符串</span>cout <span class="token operator">&lt;&lt;</span> a1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// --- output ---</span><span class="token comment" spellcheck="true">// C++PSj��: 因为a1没有使用\0结尾。</span><span class="token comment" spellcheck="true">// C++: 正确输出，找到第一个\0作为结尾。</span><span class="token comment" spellcheck="true">// C++: 正确输出</span></code></pre><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>C语言中，有很多字符串函数，如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++:%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/strfunc.png" alt="C语言中的字符串函数"></p><p>当这些函数用在char[]中时，也会受到\0的影响, 接上例。</p><pre class=" language-cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// --- output ---</span><span class="token number">9</span><span class="token number">3</span><span class="token number">3</span></code></pre><p>第一个为什么输出9？因为字符串函数strlen()会寻找第一个\0, 然后计算长度，但是a1中没有\0, 因此结果undefined, 也可能是别的。</p><h3 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h3><p>C语言中字符串的比较与C++中strings中不同, 字符串的比较有两个角度，比较数组地址，和比较数组内容。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 比较不同数组的地址，无意义</span><span class="token keyword">const</span> <span class="token keyword">char</span> ca1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"A string example"</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">char</span> ca2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"A different string"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// undeﬁned: compares two unrelated addresses</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ca1 <span class="token operator">&lt;</span> ca2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 比较数组的数据，使用strcmp</span><span class="token comment" spellcheck="true">// same effect as string comparison s1 &lt; s2</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>ca1<span class="token punctuation">,</span> ca2<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><p>C语言风格下，只能使用strcmp来比较字符串，结果为0，字符串相同。</p><p>在C++中，字符串可以简单的使用 ca1 &lt; cal2 完成。</p><h3 id="字符串拼接和复制"><a href="#字符串拼接和复制" class="headerlink" title="字符串拼接和复制"></a>字符串拼接和复制</h3><p>在C语言风格中，也不能使用如下风格的写法：</p><pre class=" language-cpp"><code class="language-cpp">string largeStr <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> s2<span class="token punctuation">;</span></code></pre><p>而是通过<code>strcpy</code>和<code>strcat</code>完成字符串的拼接和复制。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">strcpy</span><span class="token punctuation">(</span>largeStr<span class="token punctuation">,</span> ca1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// copies ca1 into largeStr </span><span class="token function">strcat</span><span class="token punctuation">(</span>largeStr<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// adds a space at the end of largeStr </span><span class="token function">strcat</span><span class="token punctuation">(</span>largeStr<span class="token punctuation">,</span> ca2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// concatenates ca2 onto largeStr</span></code></pre><p>这种使用，必须事先计算好largeStr是否能够容纳最终的结果，否则就会出错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><aside>📌 Modern C++ programs should use vectors and iterators instead of built-in arrays and pointers, and use strings rather than C-style array-based character strings.</aside>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 数组 </tag>
            
            <tag> array </tag>
            
            <tag> 字符串 </tag>
            
            <tag> string </tag>
            
            <tag> pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《邻家的百万富翁》如何生活？</title>
      <link href="/2022/09/25/du-shu-gan-wu/lin-jia-de-bai-wan-fu-weng-ru-he-sheng-huo/"/>
      <url>/2022/09/25/du-shu-gan-wu/lin-jia-de-bai-wan-fu-weng-ru-he-sheng-huo/</url>
      
        <content type="html"><![CDATA[<h1 id="阅读思考"><a href="#阅读思考" class="headerlink" title="阅读思考"></a>阅读思考</h1><p><strong>📌 这本书从名称上看好像是是市面上那种俯拾皆是的成功学的书，但是深入书的内容，可以发现它不仅对于你的财务生活有用，而且还有很多日常生活经验，能够让我们反思自己的行为。</strong></p><p>本书中提到的所谓财富自由，作者特意做出了说明：</p><blockquote><p>本书所论述的百万富翁都达到金钱上的充分自立，即拥有无须工作而能过舒适生活的财富。他们即使连一个月的工资也得不到，仍然能够年复一年地保持他们的日常生活方式不变。</p></blockquote><p>其核心上不是指钱越来越多，而是担心钱的烦恼越来越少，直到消失。</p><p>本书中，通篇都在尝试回答：</p><ul><li>人为什么会致富？</li><li>这些人有哪些特点？</li><li>如何才能致富？</li></ul><h1 id="先读调查方法"><a href="#先读调查方法" class="headerlink" title="先读调查方法"></a>先读调查方法</h1><p>这本书中对于百万富翁的调查取样方法就是很值得学习的，在书的结尾中，作者提到参与市场营销调查课程的成绩为C的学生，认为只要搞到一张豪华汽车车主的名单，就能完成取样的工作，但是全书看下来，如果按照这种方法，我们大概是无缘看到这本书的，因为大多数百万富翁不用豪车。</p><p>鉴于这种情况，从穿着外表、使用的物品和住的房子都不能决定性地判断一个人是不是百万富翁，作者采用了不同的调查方法。因此，译者也建议先读调查方法，可能会让我们对于富翁的情形有一个新的认识。</p><h1 id="百万富翁什么样"><a href="#百万富翁什么样" class="headerlink" title="百万富翁什么样"></a>百万富翁什么样</h1><h2 id="你的误解"><a href="#你的误解" class="headerlink" title="你的误解"></a>你的误解</h2><p>在我们这些平常人的印象中，富人应该是什么样子：</p><ul><li>穿着华丽；</li><li>拥有各种代表社会地位的奢侈品，如手表、珠宝和豪车；</li><li>出入各种高档场所，等等；</li></ul><p>当然，这些印象不一定错误，尤其是当今这种（自）媒体发达的社会，每个人都会将自己包装为成功人士，没有人愿意让自己看起来是个穷人，而且各种炫富的新闻充斥着网络，但是这些人中都是作者定义的富翁吗？不一定，可能他们还在为下个月的房租发愁，也未可知。</p><p>作者的书中提到的人物，无论是路人还是富豪本身，对这种对富人的印象与我们大差不差。</p><h2 id="什么是富"><a href="#什么是富" class="headerlink" title="什么是富"></a>什么是富</h2><p>在作者看来：</p><blockquote><p>许多人夸耀自己高消费的生活方式，却只有很少一点投资或完全没有投资，没有规模足够大的值得注意的资产、能产生收入的资产……与此相反，我们所定义的富人却有着大量的值得重视的资产，所有者从中得到的快乐要比展示高消费生活方式得到的快乐大得多。</p></blockquote><p>因此，我们得到作者的一个核心观点：</p><p><strong>📌 高消费，但是没有增值的投资品的人是不应该称为富人的。</strong></p><p>如何判断一个人是否富有呢？作者给出了一个定量的方法：</p><p><strong>📌 年龄乘以实现的税前年家庭收入，除以10，减去所得到的遗产价值，就是你该有的净值。</strong></p><p>当然，这只是一种粗略的算法，但是可以让我们大致估算一下自己当前的水平，以及努力的空间。而要成为高级财富积累者，还要在此基础上double。</p><h2 id="积累财富的富人的特点"><a href="#积累财富的富人的特点" class="headerlink" title="积累财富的富人的特点"></a>积累财富的富人的特点</h2><p>作者在开篇总结了富人的7个特点，这些特点将他们送往富裕的世界：</p><ol><li>多入少出的生活；</li><li>有效率地安排时间、精力和金钱，致力于财富的积累；</li><li>认为：金钱的充分自立比展示高层次的社会地位更重要；</li><li>没有接受过父母的经济援助；</li><li>他们的孩子经济上能自给自足；</li><li>准确把握市场机会；</li><li>选择了合适的职业；</li></ol><p>我将这些特点分为了三个方面：</p><ul><li>这些富翁信奉的准则，包括：1、2、3；</li><li>他们的家庭和子女关系，包括：4、5；</li><li>努力的方向，包括6、7；</li></ul><h1 id="他们信奉的准则"><a href="#他们信奉的准则" class="headerlink" title="他们信奉的准则"></a>他们信奉的准则</h1><h2 id="多入少出"><a href="#多入少出" class="headerlink" title="多入少出"></a>多入少出</h2><p>人们普遍认为美国是一个高消费的社会，事实也是如此，每当美国禁止一些国家将产品输入时，便会给当事国造成很大麻烦，因此美国是一个巨大的消费市场。</p><p>但是，作者书中提到的这些富翁们却强调一个观点——<strong>避免高消费，或者说合理消费。</strong></p><blockquote><p>财富，是积累下来的东西，而不是你花掉的东西。作者认为构筑财富的大厦虽然要有一定的收入作为前提条件，但主要是依靠克己自律、肯作牺牲和辛勤工作。</p></blockquote><p>你消费的越多，积累的就越少，这是一个很朴素的道理，但是很多人看不明白，或者受限于特殊原因和场景，无法达到。</p><blockquote><p>汽车趋向于迅速减值，而金融资产则趋向于增值。</p></blockquote><p>这些富翁通过多积累能增值的东西，减少贬值的东西来达到多入少出的目标。对于人们的质疑，或者排斥，比如是否有乡村俱乐部的会员资格等等，他们的回应是这样的：</p><blockquote><p>我的企业看起来不漂亮。我不扮那富豪角色……不摆那谱。</p></blockquote><p>在这些人看来，节俭是财富大厦的基石，特别你是从0开始，没有积累，没有家庭的帮助，所以控制好你的手。媒体上那些充满噱头的高消费者被推崇的太过分了。很少有人可以一方面一掷千金，另一方面又是百万富翁。</p><p>有一类人往往被认为是富翁，就是那些收入很高的人，但是如果实地了解的话，他们的大部分收入都纳税、高消费花掉了，想买什么就买什么，希望理解满足需求，因此延迟满足也是一种有效的手段来多入少出。</p><p>相比于那些很高的收入，财富积累的基石是防守，即减少不必要的支出，利用预算和计划监督支出，这里要铭记于心：消费品几乎等同于贬值，不能指望它可以钱生钱。</p><h2 id="合理安排时间、精力和金钱"><a href="#合理安排时间、精力和金钱" class="headerlink" title="合理安排时间、精力和金钱"></a>合理安排时间、精力和金钱</h2><p>这些富翁在制定计划，努力工作方面也有一些为人称道的特质，这些特质可能已经超过本书的主题，但是正是这些隐藏在背后的努力造就了今天的他们。</p><blockquote><p>他们经济有效地分配时间、精力和金钱，致力于构筑他们的财富大厦。</p></blockquote><h3 id="越早开始越好"><a href="#越早开始越好" class="headerlink" title="越早开始越好"></a>越早开始越好</h3><p>即便我们无法做到其他的方面，但是在合理安排计划方面，这些富翁的经验也是值得借鉴的。<strong>为了致富，越早开始自己的投资，成功的机会越大，这是第一点要记住的</strong>，而在学校待得越久，致富的目标可能会延迟。</p><p>相比那些花费大量时间在消费上的人，这些富翁认识到：</p><blockquote><p>把时间和精力花在追求摆阔上，常常会得到一种注定将得到的结果，那就是较差的经济成就。</p></blockquote><h3 id="认真计划工作和投资"><a href="#认真计划工作和投资" class="headerlink" title="认真计划工作和投资"></a>认真计划工作和投资</h3><p>因此，他们对待工作要严谨认真的多：</p><blockquote><p>约翰尼·卢卡斯，作为富裕的企业主是十分守时的。他从来不会迟到，每个工作日早上6点半准时到公司上班。</p></blockquote><blockquote><p>我坚持凡事都定好目标。我有一整套经过明确阐释的每天目标、每周目标、每月目标、每年目标和整个一生的目标。我甚至连洗澡都有个目标。我经常对我们那些年轻的经理说，他们必须定有目标。</p></blockquote><p>相比之下：</p><blockquote><p>低级的财富积累者每月所浪费的时间要数倍于他们用于计划投资策略的时间。</p></blockquote><p>这份认真当然也带到了金钱的管理上。</p><blockquote><p>这些人首先每年已实现的收入至少15%用于投资，然后才用于支付食物、衣服、住房、信用等方面的需要。</p></blockquote><p>对消费的计划和控制是财富积累的关键。因此，做预算和计划投资是十分必要的，作者调查的很多人都会进行预算规划，甚至精确到1美元。</p><blockquote><p>计划工作只是构筑财富大厦的许多关键部件中的一件。大多数财富积累能手都规定有一套系统的计划工作日程。每周、每月、每年，他们都计划自己的投资。</p></blockquote><p>一些不是那么富裕的人认为没有必要，甚至鄙视：</p><blockquote><p>然而她快乐吗？这是谈到节俭的百万富翁时别人经常向我们提出的问题。是的，她快乐。她有金钱上的保障。</p></blockquote><p>这是因为：</p><blockquote><p>金钱上充分自立的人，要比那些处于同样的收入年龄组而没有金钱上的保证的人更加快乐。</p></blockquote><p>而这些鄙视富翁的人，花费在计划和管理上的时间远远不够，这或许也是他们未能致富的原因吧。</p><p>在开展计划时，我们这些未能致富的人们总有一些误解：进行计划就意味着生活标准的下降，也就是生活的不好。而在我们一般看来，所谓生活的好，意味着通过消费各种高级商品来展示自己的高收入。但是之前我们也提到，本书的富翁对这种行为从来不感冒。</p><p>有时即便是受过高等教育的人，也不一定认可计划的重要性或者制定好计划，</p><blockquote><p>这是因为受过良好教育的高收入者并不会自动转化为能在金钱上充分自立的人。这需要有计划工作和作出自我牺牲。</p></blockquote><blockquote><p>如果你的目标是要达到金钱上的充分自立，那该怎样做呢？你的计划应该是，牺牲现在的消费，取得将来金钱上的充分自立。</p></blockquote><h3 id="富贵不能淫"><a href="#富贵不能淫" class="headerlink" title="富贵不能淫"></a>富贵不能淫</h3><p>这些富翁的一个显著的特点是，即便已经达到本书中所说的财务独立，但是他们依然简朴，属于是“富贵不能淫”了。我觉得做到这一点还是挺难的，有些在奋斗的开始阶段，尚能做到上述中提到的各种品质，但是达到一定的层次后，开始抛弃之前的行为。</p><p>但是这些富翁，即便已经富裕了：</p><ul><li>仍然买二手汽车；</li><li>处在普通居民区；</li><li>为了200美元参加本书中的调查；</li><li>不吃昂贵的食品；</li></ul><p>这里有必要提一点他们的看法，<strong>一件超出当前财富水准的物品是不能单独存在的</strong>。举例来说，你在农村的房子里挂了一幅梵高的画，显然是不太合适的，你要买个符合风格的房子，配一辆符合这个房子的车，出入符合这辆车的餐厅，等等，所以不只是一幅画的事情。</p><p>因此，这些人</p><blockquote><p>克己自律，低消费，有危机感，能刻苦工作。</p></blockquote><h1 id="家庭与子女的关系"><a href="#家庭与子女的关系" class="headerlink" title="家庭与子女的关系"></a>家庭与子女的关系</h1><p>这些能够致富的人，其所在的家庭也对其有很大的影响。</p><blockquote><p>一个家庭有两种不同的用钱习惯，是不可能积累大量财富的。</p></blockquote><p>在这里，我将其分为了妻子和下一代。但是这些人的父母对孩子也起到了决定性的影响，一般来说，父母节俭的人，其孩子一般也会很节俭。但也不一定，这点在下文中展开说明。</p><h2 id="妻子"><a href="#妻子" class="headerlink" title="妻子"></a>妻子</h2><blockquote><p>我们的妻子在金钱上远比我们保守得多。</p></blockquote><p>本书中提到的大多数富翁的妻子比他们自己要更节俭。甚至作者还问了3个问题：</p><ol><li>你们的父母很节俭吗？</li><li>你节俭吗？</li><li>你的配偶比你更加节俭吗？</li></ol><p>多数的富翁给出的都是肯定的回答。这种情况对我们寻找自己的配偶可能有一点点启示：</p><blockquote><p>如果跟爱浪费的人结婚，大多数人都决不可能在一个世代就变为富翁。一对配偶如果有一方是高消费者，那就不能积累财富。</p></blockquote><p>我觉得这一点在当前的中国社会也是很有借鉴，虽然男主外女主内的格局逐渐被打破，女性的家庭地位随着经济地位的上升也得到提升，但是操心家庭事务的仍然是多数的女性，如果她是一个大手大脚的人，显然你的日子不会好过。</p><h2 id="下一代"><a href="#下一代" class="headerlink" title="下一代"></a>下一代</h2><p>龙生龙，凤生凤，老鼠的孩子会打洞。我们一般认为富翁的孩子仍然是富翁，但是情况并不一定如此。</p><blockquote><p>一般说来，成年子女接受的美元越多，他们的财富积累就越少；而给的美元越少，积累则越多。</p></blockquote><p>这与我们的认知有差别。书中为我们揭示了部分原因：</p><ul><li>富翁们倾向于向不能经济独立人提供更多经济支持，因此逻辑是颠倒的；</li><li>富翁有一种情结：不想让孩子经历自己经历过的苦日子和风险；</li></ul><p>因此，这些富翁经常向孩子转钱，这些钱一般都会被拿来消费，即富翁自己避免了消费陷阱，但是自己的孩子没有成功摆脱这种陷阱，一个讽刺。</p><p>但是，更一般的是，</p><blockquote><p>父母积累的财富越多，他们的成年子女就越有可能在经济上得到更多的训练。</p></blockquote><p>这种也是符合我们的认知的。</p><h3 id="为什么接受经济支持的人更弱呢？"><a href="#为什么接受经济支持的人更弱呢？" class="headerlink" title="为什么接受经济支持的人更弱呢？"></a>为什么接受经济支持的人更弱呢？</h3><p>作者探索了那些从父母那里拿到更多钱的人，为什么经济会更差？</p><ol><li>从天而降的财富多用于消费，而不是储蓄和投资；</li><li>这些人未将自己的财富与父母分割，认为父母的就是自己的；</li><li>这些人本来财务状况就不好，才会得到更多的支持；</li><li>他们的投资聊胜于无；</li></ol><h3 id="应该给下一代做-留什么呢？"><a href="#应该给下一代做-留什么呢？" class="headerlink" title="应该给下一代做/留什么呢？"></a>应该给下一代做/留什么呢？</h3><p>一些经验和原则：</p><ol><li>告诉他们：不管你有多少收入， 生活永远要多入少出；</li><li>教会他们钓鱼，而不是直接给他们鱼；</li><li>教会孩子节俭；</li><li>让他们自己做决策，吃苦头；</li><li>自律地生活；</li><li>不要给出承诺：我的钱全部留给你；</li><li>有勇气尝试，即便失败也好；<blockquote><p>当你把全部心思都放进去的时候，你能干出些什么来，那是很不可思议的。</p></blockquote></li><li>教导他们靠自己生活；<blockquote><p>应为子女创造一种环境，使独立的思想和业绩受到尊敬，个人的成就受到珍惜，责任心才能得到应有的报偿。不错，生活中最重要的常常是自由。要教育你的子女依靠自己生活。</p></blockquote> 孩子也应该避免成为父母的经济奴隶，因为在经济上受制于别人，你的精神也受制于人。</li><li>不要告诉他们：自己的家庭很富裕；</li><li>父母对孩子的教导要与父母自己的行为一致；<blockquote><p>行动比规则更有号召力；规则只是言词，不是行动。</p></blockquote></li><li>绝不把给钱作为谈判策略的一部分<blockquote><p>给予，是因为爱，甚至是出于义务、责任或仁慈。父母如果采用高压的谈判策略，常常会失去成年子女的尊敬与爱戴。</p></blockquote></li><li>不参与成年子女家事；</li><li>不要试图与子女竞争；不夸耀自己的学历，不炫耀自己的财富。</li><li>强调子女的成就，促使他们拼搏奋斗；</li><li>告诉他们：很多东西比金钱更宝贵；</li></ol><h1 id="努力的方向"><a href="#努力的方向" class="headerlink" title="努力的方向"></a>努力的方向</h1><h2 id="瞄准富人"><a href="#瞄准富人" class="headerlink" title="瞄准富人"></a>瞄准富人</h2><p>跟着金钱走，是富翁给出的建议，谁有最多的金钱，也是富人，因此这些人提供服务，是致富的便捷通道。作者在书中提到的几个方向，可能在中国并不能适用，但是这个原则是没错的，尤其现在对高质量保姆、育婴、家政等都需求很大。</p><h2 id="选好职业"><a href="#选好职业" class="headerlink" title="选好职业"></a>选好职业</h2><p>另外一个建议是：选择好的职业，书中提到很多的富翁作为企业家，并不希望自己的孩子从事相同的职业，而是希望他们从事医生、律师等职业，这里引用书中的一个例子：</p><blockquote><p>我们问一位在二战期间因纳粹集中营大屠杀而逃离欧洲的富人，为什么他所有的成年子女都是自营的专业人员？他的回答是：“他们能拿走你的企业，但是他们拿不走你的才识！”</p></blockquote><p>因此选择一个需要丰富学识的职业会给你致富之路助力。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这本书是1998年出版的，已经过去将近25年了，但是其中的原则和经验一点也不过时，甚至我们认为再过100年，也不过时。</p><p>当今的社会风潮显然在朝着书中富人生活的相反面发展，也给了部分人机会。当然，在书中作者有预见性地提到，一旦你从事书中描述的富翁那样生活，大概率会遇到各种刁难和鄙视，或者与当前的社会环境格格不入，不过，管他呢！</p><blockquote><p>一种敌意环境，即使是在美好人群之中，对于狗——或者对于财富积累能手来说，也不是一个好地方。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 致富 </tag>
            
            <tag> 投资 </tag>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reference and Pointer</title>
      <link href="/2022/09/18/bian-cheng-zhi-dao/reference-he-pointer/"/>
      <url>/2022/09/18/bian-cheng-zhi-dao/reference-he-pointer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💡 本篇的内容来自C++ Primer中的2.3节</p></blockquote><p>在C++中除了基本数据类型，还包括复杂数据类型，主要有2种：</p><ul><li>reference 引用</li><li>pointer 指针</li></ul><blockquote><p>A compound type is a type that is deﬁned in terms of another type.</p></blockquote><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p>Technically speaking, when we use the term reference, we mean “lvalue reference.”</p></blockquote><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ul><li>A reference deﬁnes an <strong>alternative name</strong> for an <strong>object</strong>;</li><li>A reference type “refers to” another type;</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal <span class="token operator">=</span> ival<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// right, refVal refers to(is another name for) ival</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal2<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// error, 引用必须被初始化</span></code></pre><h3 id="定义过程"><a href="#定义过程" class="headerlink" title="定义过程"></a>定义过程</h3><ul><li>引用只能是object的别名；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal4 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10 不是变量</span></code></pre></li><li>引用的类型与其所指向的对象的类型要匹配；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal5 <span class="token operator">=</span> dval<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误，类型不匹配</span></code></pre></li></ul><h2 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h2><p>对于基本类型的变量而言，当初始化一个变量时，用于初始化的对象的值被拷贝到创建的对象上。但是当创建reference时，不拷贝该值，而是将reference与该对象绑定。</p><p>这一点对于需要性能的场景很重要，不希望拷贝数据，只希望引用同样的数据，这样避免了拷贝操作。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>所有对象引用的声明都必须要初始化；</li><li>引用一旦初始化，没有任何方式能够解绑其引用另外一个对象，即整个生命周期和初始化对象“死磕”；</li><li>当引用与初始化对象绑定后，所有针对该引用操作引起的变化都会反映到初始化对象上；<pre class=" language-cpp"><code class="language-cpp">refVal2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此时，ival也是2；</span></code></pre></li><li>Reference is not an object, and it is just another name for an already existing object.  因此我们不会定义reference的reference，因为reference只能定义object的别名；</li><li>一个技巧：由于reference使用的&amp;后续的获取变量的地址时也会使用，因此会让人困惑，  因此一种读法是，如下：<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>val <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//val refers to a int variable a. 从右向左读，&amp;换成refer to </span></code></pre></li></ul><h1 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h1><h2 id="含义说明"><a href="#含义说明" class="headerlink" title="含义说明"></a>含义说明</h2><blockquote><p>A pointer is a compound type that “points to” another type.</p></blockquote><p>与reference对比：</p><ul><li>a pointer is an object in its own right.<ul><li>reference is not an object;</li></ul></li><li>Pointers can be assigned and copied;</li><li>a single pointer can point to several different objects over its lifetime;</li><li>a pointer need not be initialized at the time it is deﬁned;</li></ul><h2 id="声明和使用方式"><a href="#声明和使用方式" class="headerlink" title="声明和使用方式"></a>声明和使用方式</h2><ul><li>使用<code>*</code><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// dp1是指针，dp是浮点数</span><span class="token keyword">double</span> dp<span class="token punctuation">,</span> <span class="token operator">*</span>dp1<span class="token punctuation">;</span></code></pre></li><li>the types of the pointer and the object to which it points must match;<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> dval<span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token operator">*</span> pd <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: initializer is the address of a double </span><span class="token keyword">double</span> <span class="token operator">*</span> pd2 <span class="token operator">=</span> pd<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: initializer is a pointer to double </span><span class="token keyword">int</span> <span class="token operator">*</span> pi <span class="token operator">=</span> pd<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: types of pi and pd differ </span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: assigning the address of a double to a pointer to int</span></code></pre></li><li>use the dereference operator (the * operator) to access that object;<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span> p<span class="token punctuation">;</span></code></pre></li><li>同时定义多个变量时的误解<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>i<span class="token punctuation">,</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// i为指向int的指针，j为int变量，不是指针； </span></code></pre>  这种写在一起时会引发误解，两种方法可以避免：<ol><li>写成 <code>int *i</code>, 而不是 <code>int* i</code>;</li><li>写在两个声明语句中，就不会误解；</li></ol></li></ul><h2 id="Pointer指向对象地址"><a href="#Pointer指向对象地址" class="headerlink" title="Pointer指向对象地址"></a>Pointer指向对象地址</h2><ul><li>A pointer holds the address of another object;</li><li>Because references are not objects, they don’t have addresses. Hence, <strong>we may not deﬁne a pointer to a reference</strong>.</li><li>Because a pointer is an object, we can deﬁne a reference to a pointer.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>r <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// r is a reference to the pointer p</span>r <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 更改r所引用对象的值</span></code></pre></li><li>we can store the address of a pointer in another pointer as pointers are also objects.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p is a pointer to val;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>pp <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pp is a pointer to pointer to p.</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"val is "</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">" by val"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"val is "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> <span class="token string">" by *p"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"val is "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token operator">*</span>pp <span class="token operator">&lt;&lt;</span> <span class="token string">" by **pp"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre>  对于存在多种符号，如<code>&amp;</code>，<code>*</code>等涉及reference或者pointer的声明时，遵守以下原则就不会出错；<ul><li>The easiest way to understand the type of r is to read the deﬁnition right to left.</li><li>The symbol closest to the name of the variable (in this case the &amp; in &amp;r) is the one that has the most immediate effect on the variable’s type.</li></ul>  将<code>*</code>称为pointer to, <code>&amp;</code>称为reference to.</li></ul><h2 id="Pointer-Value"><a href="#Pointer-Value" class="headerlink" title="Pointer Value"></a>Pointer Value</h2><p>指针在实践中很容易出错，但是pointer的value只能是下面4种之一：</p><ol><li>point to an object; （正常，我们希望的状态）</li><li>point to the location just immediately past the end of an object; 这种情况如何理解呢？比如在一个数组中，最后一个元素之后的位置，在循环和迭代器中，我们会有指向最后元素之后的元素的指针，可以阅读<a href="https://stackoverflow.com/questions/21850108/what-is-pointer-past-the-end-of-an-object-means">这篇文章</a>；</li><li>null pointer: not bound to any object; （注重注意的情况）</li><li>invalid: 除了上述三者之外的所有情况；（极力避免）<ul><li>It is an error to copy or otherwise try to access the value of an invalid pointer.</li><li>The result of accessing an invalid pointer is undeﬁned.</li></ul></li></ol><h2 id="Null-Pointers"><a href="#Null-Pointers" class="headerlink" title="Null Pointers"></a>Null Pointers</h2><h3 id="具体含义"><a href="#具体含义" class="headerlink" title="具体含义"></a>具体含义</h3><blockquote><p>A null pointer does not point to any object.</p></blockquote><h3 id="获取null-pointers"><a href="#获取null-pointers" class="headerlink" title="获取null pointers"></a>获取null pointers</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// method 1</span><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// method 2</span><span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// method 3</span><span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 必须#include &lt;cstdlib></span></code></pre><p>在这三种方法中：</p><ul><li>法1最被推荐使用，新的标准，可以转换为任意其他的指针类型；</li><li>法2是之前的方法；  一种“骚操作”：<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">int</span> zero <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pi <span class="token operator">=</span> zero<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 错误，不允许将int赋值给pointer</span></code></pre></li><li>法3等价于法2，继承自C语言，<code>NULL</code>是一个preprocessor variable，在compiler编译之前，会将其替换为0；</li></ul><blockquote><p>💡 强烈建议：在pointer声明时，最好初始化，以免出现未定义的pointer；如果不定义，最好使用nullptr赋值。</p></blockquote><h2 id="Pointer的其他操作"><a href="#Pointer的其他操作" class="headerlink" title="Pointer的其他操作"></a>Pointer的其他操作</h2><h3 id="条件语句中"><a href="#条件语句中" class="headerlink" title="条件语句中"></a>条件语句中</h3><blockquote><p>if the pointer is 0, then the condition is false, any nonzero pointer evaluates as true.</p></blockquote><p>只要pointer为null pointer, 其条件判定即为0；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p is null pointer"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p is not null poiner"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出：p is not null poiner</span></code></pre><h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><p>Given two valid pointers of the same type, we can compare them using the equality (==) or inequality (!=) operators.</p><ul><li>Two pointers are equal if they hold the same address and unequal other-wise.</li><li>Two pointers hold the same address (i.e., are equal)<ul><li>if they are both null,</li><li>if they address the same object,</li><li>or if they are both pointers one past the same object.</li></ul></li><li>Using an invalid pointer as a condition or in a comparison is undeﬁned. 这种情况指的是，pointer values中的第四种情况。</li></ul><h2 id="void-Pointers"><a href="#void-Pointers" class="headerlink" title="void * Pointers"></a><code>void *</code> Pointers</h2><ul><li>The type <code>void *</code> is a special pointer type that can hold the address of any object.</li><li>a <code>void *</code> pointer holds an address, but the type of the object at that address is unknown:</li></ul><blockquote><p>💡 之前我一直以为这是指向一个void地址，这个起名太奇怪了。</p></blockquote><p>虽然这种指针类型可以指向任意类型的指针，但是其只支持有限的操作。</p><ul><li>We can compare it to another pointer,</li><li>we can pass it to or return it from a function,</li><li>and we can assign it to another <code>void *</code> pointer.</li></ul><p>但是不可以：</p><ul><li>use a <code>void *</code> to operate on the object it addresses<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>vp <span class="token operator">=</span> p<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p points to "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vp points to "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>vp <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误</span></code></pre></li></ul><h1 id="对比Reference和Pointer"><a href="#对比Reference和Pointer" class="headerlink" title="对比Reference和Pointer"></a>对比Reference和Pointer</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul><li>Both pointers and references give indirect access to other objects.</li></ul><blockquote><p>💡 在Reference和Pointer中，&amp;和*出现的频率很高，但是在不同context中代表的含义不同，这一点尤其需要注意。</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// &amp;代表r refers to i</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// *代表p points to i, &amp;代表取i的地址</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// &amp;代表r2 refers to the object which p points to.</span></code></pre><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><table><thead><tr><th></th><th>Reference</th><th>Pointer</th></tr></thead><tbody><tr><td>内存地址</td><td>不是独立对象，也就没有独立的内存地址，而是附属在特定的对象上。</td><td>作为独立的对象，像基本类型的对象一样存在内存地址。</td></tr><tr><td>可变性</td><td>作为引用本身，无法改变成针对另一个对象的引用；但是可以改变引用对象本身的值。</td><td>可以改变指向对象的值，也可以改变指向的对象。</td></tr><tr><td>初始化</td><td>声明时，必须初始化。</td><td>声明时，不必初始化，但是如果不初始化，则会有一个undefined的值。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引用 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-13-01-Ray Tracing - Basics &amp; Methods</title>
      <link href="/2022/09/18/ji-suan-ji-tu-xing-xue/games/games101-13-01-ray-tracing-basics-methods/"/>
      <url>/2022/09/18/ji-suan-ji-tu-xing-xue/games/games101-13-01-ray-tracing-basics-methods/</url>
      
        <content type="html"><![CDATA[<p>光线追踪和光珊化是两个不同的成像方法。</p><h1 id="为什么用Ray-Tracing"><a href="#为什么用Ray-Tracing" class="headerlink" title="为什么用Ray Tracing"></a>为什么用Ray Tracing</h1><ul><li>在rasterization中一些事情不能很好的处理：<ol><li>不能很好地处理global effect<ul><li>如上一节中提到的shadow mapping, 只能实现hard shadow;</li><li>glossy reflection 光滑的反射；</li><li>indirect illumination 间接光照</li></ul> 特别是，当光经过多次反射才能到达人眼的场景下，光栅化的效果都不太好； <img src="/images/games101/13/bad_rasterization.png" alt="光珊化做不好的事情"></li><li>光栅化很快，但是质量相对较低；</li></ol></li><li>Ray tracing 很准确，但是非常慢  光栅化可以realtime，而ray tracing一般是offline。  一般下，在实际场景中渲染一帧需要10k CPU core hours. </li></ul><h1 id="基本Ray-Tracing算法"><a href="#基本Ray-Tracing算法" class="headerlink" title="基本Ray Tracing算法"></a>基本Ray Tracing算法</h1><h2 id="Light-Rays定义"><a href="#Light-Rays定义" class="headerlink" title="Light Rays定义"></a>Light Rays定义</h2><p>在图形学中一些假设：</p><ul><li>光线直线传播；</li><li>两个光线相遇时，不会发生碰撞；</li><li>reciprocity: 光线是可逆的, 实际是从光源经过各种反射到眼睛，但是我们可以认为是从眼睛发出回溯到光源；</li></ul><h2 id="首先——Ray-Casting-光线投射"><a href="#首先——Ray-Casting-光线投射" class="headerlink" title="首先——Ray Casting 光线投射"></a>首先——Ray Casting 光线投射</h2><p>光线投射从眼睛开始，望向物体，假设在眼睛面前存在一个屏幕，里边被分为各种像素点。</p><ol><li>将眼睛和物体连接起来的光线与屏幕相交的地方形成一个点，多个点形成一个image;</li><li>并将投射到物体上的光线回溯到光源，以确定光源能看见物体上的该点，从而验证有无投影；</li></ol><blockquote><p>💡 在光线追踪中，使用的是<a href="https://en.wikipedia.org/wiki/Pinhole_camera_model">Pinhole camera model</a>，即眼睛视为点光源。</p></blockquote><h3 id="第一步：generate-eye-rays"><a href="#第一步：generate-eye-rays" class="headerlink" title="第一步：generate eye rays"></a>第一步：generate eye rays</h3><p>从眼睛开始，望向物体，得到<strong>最近</strong>的物体上的点。一条eye ray可以与很多点相交，但是这一步只取最近的点，相当于做了<strong>深度测试</strong>。</p><p><img src="/images/games101/13/generate_ray.png" alt="生成光线"></p><h3 id="第二步：Shading-pixels"><a href="#第二步：Shading-pixels" class="headerlink" title="第二步：Shading pixels"></a>第二步：Shading pixels</h3><p>将获得的距离屏幕最近的点与光源相连，确定该点是否可见。然后对于该最近的点而言，其得到了两条线，从而可以确定法线，以便利用着色模型(Blinn Phong Model等)完成颜色的计算，然后写会到屏幕对应的像素上。</p><p><img src="/images/games101/13/basic_rt.png" alt="Shading pixels"></p><p>上述简单的光线追踪：</p><ul><li>基本可以达到光栅化一样的效果；</li><li>但是光线只能bounce一次；</li></ul><h1 id="Recursive-Whitted-Style-Ray-Tracing"><a href="#Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="Recursive(Whitted-Style) Ray Tracing"></a>Recursive(Whitted-Style) Ray Tracing</h1><p>为了解决上述模型中光线只能弹射一次的问题。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当eye ray射出来后，照到一个玻璃球上，会出现反射和折射，在一个点上可以无限地bounce。</p><p>在这种情况下，计算着色值的方式与上述模型不同。在上边只会计算一个最近点与光源相交后得到的着色值，现在需要计算所有的点与光源相连后的着色值，因此whitted-style下，需要将每个弹射点计算得到的着色只加到一起写到对应的像素上（除了阴影下的点）。</p><p>对每一个弹射点都需要首先确定是否能被光源看见，来确定是否包含其贡献的着色值。</p><p><img src="/images/games101/13/ws_rt.png" alt="Recursive(Whitted-Style) Ray Tracing"></p><p>几个定义：</p><ul><li>primary ray: 与第1个弹射点对应的ray</li><li>secondary ray: 除了第1个弹射点对应的其他ray</li><li>shadow ray: 与光源连接的ray;</li></ul><h2 id="Ray-Surface-Intersection"><a href="#Ray-Surface-Intersection" class="headerlink" title="Ray-Surface Intersection"></a><strong>Ray-Surface Intersection</strong></h2><h3 id="Ray-equation"><a href="#Ray-equation" class="headerlink" title="Ray equation"></a>Ray equation</h3><p>光线在数学上的定义如下，</p><p><strong>Ray is defined by its origin and a direction vector.</strong></p><ul><li>光线起点 $\mathbf{o}$；</li><li>沿着方向的单位向量；</li></ul><p>$$<br>\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}; \quad 0 \le t \le \infty<br>$$</p><ul><li>其中，$t$为时间；</li></ul><h3 id="Ray-Intersection-With-Sphere"><a href="#Ray-Intersection-With-Sphere" class="headerlink" title="Ray Intersection With Sphere"></a><strong>Ray Intersection With Sphere</strong></h3><p>对于球的表达：</p><ul><li>定义球心 $\mathbf{c}$;</li><li>球上任意一点 $\mathbf{p}$；</li></ul><p>则对于球面上的任意一点表示如下，</p><p>$$<br>(\mathbf{p} - \mathbf{c})^2 - R^2 = 0<br>$$</p><p>当求解光线与球体的交点时，需要满足：</p><p>$$<br>(\mathbf{o} + t\mathbf{d} - \mathbf{c})^2 - R^2 = 0<br>$$</p><p>求解t即可，二次函数求解，要保证t为正实数。根据解的数量的不同可以有3种情况：</p><ul><li>相离：无解；</li><li>相切：一个解</li><li>相交：两个解</li></ul><h3 id="Ray-Intersection-With-Implicit-Surface"><a href="#Ray-Intersection-With-Implicit-Surface" class="headerlink" title="Ray Intersection With Implicit Surface"></a><strong>Ray Intersection With Implicit Surface</strong></h3><p>将情况推广到任意的隐式平面，对于任意平面，根据之前的几何部分的知识，表示如下：</p><p>$$<br>f(\mathbf{p}) = 0<br>$$</p><p>因为为了求解交点，得到如下表示：</p><p>$$<br>f(\mathbf{o} + t\mathbf{d}) = 0<br>$$</p><p>下一步就是利用各种数值计算的方法和软件完成计算即可。</p><h3 id="Ray-Intersection-With-Triangle-Mesh（显式表示）"><a href="#Ray-Intersection-With-Triangle-Mesh（显式表示）" class="headerlink" title="Ray Intersection With Triangle Mesh（显式表示）"></a><strong>Ray Intersection With Triangle Mesh（显式表示）</strong></h3><p><strong><code>简单的方法</code></strong></p><ul><li>将光线与每个三角形分别计算，带来的问题必然很慢。</li><li>这里我们，我们只考虑光线和三角形有0或者1个交点的情况，不涉及平行的情况。</li></ul><p>对于一个mesh，我们首先考虑针对一个三角形的交点求解，然后迭代即可。</p><p>将光线与三角形求交分解为2部分：</p><ol><li>ray-plane intersection;</li><li>test if hit point is inside triangle;</li></ol><p>根据高数中平面方程，可以通过平面的法线和面上的一点来确定平面本身。</p><blockquote><p>Plane is defined by normal vector and a point on plane.</p></blockquote><p>对于平面上的任意一点 $\mathbf{p}$，给定法线 \mathbf{N}和给定一点 $\mathbf{p}^{\prime}$，得到以下表示：</p><p>$$<br>(\mathbf{p} - \mathbf{p}^{\prime}) \cdot \mathbf{N} = 0<br>$$</p><p>得到表示，就可以求解交点了，满足如下条件：</p><p>$$<br>(\mathbf{p} - \mathbf{p}^{\prime}) \cdot \mathbf{N} = (\mathbf{o} + t\mathbf{d} - \mathbf{p}^{\prime})\cdot \mathbf{N} = 0<br>$$</p><p>得到：</p><p>$$<br>t = \frac{(\mathbf{p}^{\prime} - \mathbf{o}) \cdot \mathbf{N} }{\mathbf{d} \cdot \mathbf{N}}<br>$$</p><p>最后别忘了一步，判断t对应的交点是不是在三角形内部。</p><p><strong><code>Möller Trumbore Algorithm</code></strong><br>上面的方法所有简单，容易理解，但是过于繁琐。</p><p>有一种快速的方法，可以一下得到答案。</p><blockquote><p>📌 一种思考方式：三角形内部一点可以使用重心坐标表示，因此判定光线与三角形相交，就可以将其表示为重心坐标的形式。</p></blockquote><p>$$<br>\mathbf{o} + t\mathbf{d} = (1- b_1-b_2) \mathbf{p}_0 + b_1\mathbf{p}_1 + b_2\mathbf{p}_2<br>$$</p><p>这个方程本质上是求解线性方程组，使用<a href="https://en.wikipedia.org/wiki/Cramer%27s_rule">Cramer’s rule</a>完成求解（还记得这是当初学线性代数时第一个主要内容）。</p><p>完成求解后需要验证：</p><ul><li>t为正实数</li><li>$b_1, b_2, 1-b_1 - b_2$ 为正实数，保证在三角形内部；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ray Tracing </tag>
            
            <tag> Recursive Ray Tracing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日本出了问题：《东京贫困女子》呈现的社会现象</title>
      <link href="/2022/07/15/du-shu-gan-wu/ri-ben-chu-liao-wen-ti-dong-jing-pin-kun-nu-zi-cheng-xian-de-she-hui-xian-xiang/"/>
      <url>/2022/07/15/du-shu-gan-wu/ri-ben-chu-liao-wen-ti-dong-jing-pin-kun-nu-zi-cheng-xian-de-she-hui-xian-xiang/</url>
      
        <content type="html"><![CDATA[<p>这本书我是去年开始读的，读这本书的契机是因为之前看过一个我个人觉得很有意思的日剧——《暗金丑岛君》。但是影视总有一些虚构的成分，所以想了解一些真实的事件，恰好发现这本书。去年刚开始读的时候，觉得有点压抑，一度读不下去，恰好又赶上毕业的事情，耽搁了，现在毕业了又重新拿起来继续读。</p><p><img src="/images/%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F/%E4%B8%9C%E4%BA%AC%E8%B4%AB%E5%9B%B0%E5%A5%B3%E5%AD%90/book.jpg" alt="东京贫困女子"></p><p>总的来说，这本书没有明显的叙事结构，基本是按照作者采访的真实事件整理而成。作为一本纪实文学，书中的文字很平和，没有过多的华丽的辞藻，但是从这些文字中，你能体会到阵阵寒意，尤其这些事情都是发生在公认为发达国家的日本。</p><p>如果你想了解当今和未来的中国，这本书你应该读一下，或为解答内心的疑虑，或者为艰难的未来做准备。如果你能够接受日剧，我同时也推荐一下《暗金丑岛君》这部日剧，两者之间有很多的共同点。</p><p>本书中共涉及了19个具体的女子贫困的案例，由3年的采访记录而来。书中以对话的形式叙述了每个人的悲惨遭遇，以及造成这些问题的可能原因，包括但不限于政府的制度、整个社会的氛围、家庭的环境、甚至历史的文化惯例等等。从阅读体验上来说，读者可以从任意感兴趣的章节阅读，因为每个人的经历都是独立的。</p><h1 id="日本出问题了"><a href="#日本出问题了" class="headerlink" title="日本出问题了"></a>日本出问题了</h1><p>作者作为一个自由撰稿人，一直在对成人影片女优和风俗业进行采访，因此本文的视角可能对外国的读者有点奇特。所有的缘起在于作者在采访中逐渐意识到：</p><blockquote><p>虽然没有意识到这是一项实地调研，但我在2006年到2007年间，渐渐产生了“日本社会是不是出问题了”这种模糊的不安感。</p></blockquote><p>我们虽然在新闻和报纸上经常看到“失去的30年”等说法，但是作者从自己的经历提出了“日本出问题”这个观点，具体包括两件事情：</p><ul><li>作者自己经历的风俗报道：涌入这个行业的女子日益增多，但是收益却大幅下降；</li><li>作者自己经营了看护机构，可以视为国内的“养老院”：发现这种福利机构中却包含这更为黑暗的一面；</li></ul><p>因此书中在探讨贫困问题时，对这两个方面多种侧重。而对于贫困的原因，作者首先提出了一个观点：</p><blockquote><p>日本社会针对贫困的当事人有一种很强的责任自负的认识。</p></blockquote><p>对于这种观点，国内相比也有同样认知的人群，他们穷是因为他们不努力，这样的认识与教育程度无关，可能只是他们靠自己的努力幸运地摆脱了贫困。我想，在本书中，作者并不否定个人的原因导致贫困，但是更多地是强调这不是唯一的原因，甚至不是最重要的原因。因为“日本出问题了”才是导致这一切的原因。</p><h1 id="日本的贫困女子们"><a href="#日本的贫困女子们" class="headerlink" title="日本的贫困女子们"></a>日本的贫困女子们</h1><blockquote><p>贫困，是在出身和成长经历、家庭环境、健康状态、就业、政策、制度、个人和配偶的性格及人格等多重因素的影响下发生的。</p></blockquote><p>作者在书中着重描述了两类群体作为贫困女子的代表：</p><ul><li>一个是女大学生；</li><li>一个是离异的单身母亲；</li></ul><p>我们直觉感受，这两类人确实是会贫困的人群，但是书中陈述的事实显然超出了我的想象。</p><h2 id="女大学生们怎么了"><a href="#女大学生们怎么了" class="headerlink" title="女大学生们怎么了"></a>女大学生们怎么了</h2><blockquote><p>大学生，是真的没钱。大学校园，就是贫困的巢窟。</p></blockquote><p>作者如此的看法是中国学生们不能理解的（起码我开始不能理解）。中国的大学多是公立大学，而且有一个跟国外大学迥异的特点——大学越好，学费越便宜。学校从国家拿到的财政补贴越多，因此你上了一个好大学，多半不用为学费和生活费发愁。但是国外的好大学多数是私立，而是为了保持“独立性”，很少从国家直接拿补贴，因此这部分负担就由学生承担，因此国外的学生相比于国内学生的经济压力更大，尤其是父母不能提供支持的前提下。</p><blockquote><p>大学生的贫穷乃至贫困的背后，是父母一代收入的下降和原则上应由受益者承担的学费的持续上浮。</p></blockquote><p>而经济压力的加重多半与国家的经济出现问题有关，对此女大学生们的解决方法没有太多选择：</p><ul><li>征集干爹：</li><li>领取日本学生支援机构助学金：</li></ul><p>征集干爹就是所谓的援交，这种美化的说法并不能掩盖其中的艰辛。</p><blockquote><p>留言板上的干爹征集，其实就是卖身吧。现在和我保持联络的有两个人。都是40多岁，详细情况我不知道。我也不喜欢这些人。我们只是偶尔一块儿吃饭，上床，然后拿钱。不过，我完全不习惯这样……和特定的人多见几次面就觉得害怕，而且我本身也不想见他们。</p></blockquote><p>作者提到这样的目的是维持基本生活，因为之前在超市打工的薪水并不能满足这些女大学生的生活所需，而家庭无法提供任何支撑，超市时薪920日元（45RMB）,一天最多工作4小时，也就是180RMB，而一年的学费是53.58万日元（26000RMB）。怎么算就无法覆盖学费，因此去风俗店打工是逼不得已的选择。</p><blockquote><p>简单来说就是，一个从地方上来，且得不到父母资助的单身大学生，如果不去陪酒或做风俗业，就没法维系求学生活。</p></blockquote><p>虽然国家对学生求学提供了助学金制度，但是这种制度有一种资本家剥削穷人的感觉，在作者看来。</p><blockquote><p>助学金制度的设立，表面上是为了让贫困家庭的孩子也有机会接受高等教育。然而，让身后没有退路的贫困家庭的孩子们背负足以让他们个人破产的债务，事实上不仅不能利用高等教育来防止贫困的连锁效应，更会使不少学生进一步陷入负债的深渊。</p></blockquote><p>申请助学金制度有几个问题要考虑：</p><ul><li>一个是投入的成本无法获得回报；<blockquote><p>靠借款升学就等同于一种商业投资，如果不能得到大于投资的回报，就会出现问题，过度地投资就会导致破产。</p></blockquote>  日本经济的不景气，导致大学生并不能很容易的找到工作。</li><li>进一步加重自己的债务负担  因为助学金中存在最高3%的利息，有些人读完大学累计需要还款1000万日元（48.65万RMB），这对于刚进入社会的人无疑是一种极大的负担。</li></ul><p>助学金的负担无疑又将这些女大学生推向风俗行业，两者形成一种负向的反馈。</p><h2 id="单身母亲的无奈"><a href="#单身母亲的无奈" class="headerlink" title="单身母亲的无奈"></a>单身母亲的无奈</h2><p>离异、单身的母亲在任何国家都是显而易见的弱势群体，但像日本社会这样一旦离婚就立即变为贫困的现象仍然让人震惊。</p><p>书中通过案例列举了单身母亲面临的挑战：</p><ul><li>前夫不付抚养费：对于这种行为只能从道德上谴责，但是法律上却无法追究，我不明白日本的法律为何无法处理这种情况；</li><li>非正式雇佣，也就是“临时工”：这是单身母亲能找到最多的工作方式，没有任何保障、可以随时被解雇。在我们的印象里，日本都是“年功序列制”，这种文化在当今也是坚持不下去的。<blockquote><p>非正式雇用是自1999年《劳动者派遣法》实施并在2004年该法修订之后开始激增进而普及的一种雇用形态。</p></blockquote>  而非正式雇佣加剧了阶级分化，这一点对于女性过于残酷。<blockquote><p>企业一般很少会特意将非正式聘用的劳动者转成正式聘用，所以社会底层的人几乎没法爬上来。如此一来，贫困的固化使得“贫富差距”发展为“不同阶级”。</p></blockquote>  因为不用负任何责任，便催化了权力欺压和性骚扰等针对女性的恶性行为。<blockquote><p>如果正式员工问你的问题你没能答上来，就可能会被甩一句“那你明天不用来上班了”，然后立刻被解雇。我们管这个叫“出禁”。毕竟不是直接雇用的关系，所以被如此冷酷地对待也很正常。我们唯一的选择就只有遵守社员的命令，没有借口和怨言，绝对服从。</p></blockquote></li><li>年龄限制：即便是非正式雇佣，当超过了45岁，这些女性也彻底的没有了机会。这让我想起了国内的35岁门槛，也有一种同病相怜的感受。</li></ul><blockquote><p>日本对曾做过专职主妇的女性还有单亲家庭，都太严苛了，连一个人的基本生活都保障不了，还不给我们机会。</p></blockquote><p>这是植草女士对当今日本社会的抱怨，也揭示了政府或者社会在关注弱势群体方面的冷漠。</p><blockquote><p>即使受过高等教育，一个女性只要做了家庭主妇，社会就不会再给予她发挥自己能力和价值的机会了吗？不仅是工作，一旦被丈夫要求离婚，其结果就是，她会失去工作同时失去家人。</p></blockquote><p>这些单身母亲们的贫困几乎是100%的会传递到下一代，因为无法在经济上支持孩子们，他们的孩子只能上不好的学校，靠自己进入风俗店赚钱缴纳学费，然后重复女大学生们的生活，然后这种生活造成她们成年后对于家庭的不信任，因此离婚成了无法避免的选择，甚至是不婚。</p><h1 id="我们怎么办"><a href="#我们怎么办" class="headerlink" title="我们怎么办"></a>我们怎么办</h1><p>本书的作者强调了政府和社会制度在导致女性贫困方面扮演的负面角色，对于作者避而不谈自我原因导致的贫困，我一开始是无法认同的。但是设身处地思考，对于一个缺失家庭支持的16岁女孩，去上大学则要面临每年的学费和生活费，不上学则无法摆脱贫困，直接进入风俗行业，我们这些局外人无法轻松地说出“多打工赚钱，少花钱”这样的风凉话。</p><p>这本书对于我们有怎样的启发，我觉得是值得思考的问题。</p><p>日本是一个发达国家，其社会保障体系比我们要全面，这一点毋庸讳言。即便是在这样的社会，仍然存在书中描写的贫困人口，显然单靠国家的保障制度，无法使我们安全度过这一生，我们需要自己计划，才不会陷入无助和混乱。</p><p>虽然很多的国家制度，我们无法左右，如作者所言：</p><blockquote><p>日本的制度设计就是让女性在最低生活保障水准线上工作和生活。我只是运气好逃离了泥沼，还有很多普通的女性过得还不如贫民窟的人。</p></blockquote><p>虽然很痛苦，但是还要活下去，这是作者留下的感叹。如果你感到焦虑或者痛苦，可能还是经历的不够多，当看见书中人物的真实经历时，或许我们面对的并不是那么糟糕。</p>]]></content>
      
      
      <categories>
          
          <category> 读书感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
            <tag> 社会 </tag>
            
            <tag> 贫困 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Notion API+Github Actions回顾阅读的文章</title>
      <link href="/2022/05/22/xiao-lu-sheng-huo/li-yong-notion-api-github-actions-hui-gu-yue-du-de-wen-zhang/"/>
      <url>/2022/05/22/xiao-lu-sheng-huo/li-yong-notion-api-github-actions-hui-gu-yue-du-de-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每天看着不断推送的手机消息，明知道其中有价值的并不多，但是又怕错过有价值的信息，这种心态在当今是一种很普遍的心态。因此，面对这种局面，<a href="https://www.tmtpost.com/5947407.html">如何摆脱海量信息的冲击和无价值信息的禁锢</a>，是面对的一个艰巨的挑战。之前看到一篇文章——<a href="https://catcoding.me/p/get-better-info/">优化自己的信息源</a>，建议主动获取信息。回想我的信息管理方法，差不多也是按照这个思路来的，一般是：</p><ul><li>收集：初步加上标签和分类；</li><li>预处理：检视阅读，找出其中要点；</li><li>深度阅读：阅读，加上摘要和思考内容；</li></ul><p>最后这些标注和内容都汇总到我的notion数据库中，但是逐渐发现缺乏回顾的环节，手动去获取这些积累的信息，也存在实际操作性不强的问题，<a href="https://sspai.com/post/71518">我是如何艰难地克服「效率成瘾」的？</a>建议我们要自动化一些操作来提升效率。</p><p>因此，我希望通过自动化的方法来回顾我看过和思考的内容。</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><ol><li>Notion API自动化获取信息；</li><li>Github Actions提供workflow；</li><li>微信接收——Notion打开；</li></ol><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>信息存储在Notion中，因此使用其提供的API实现自动化的获取；</li><li>具体的回顾方式：每天定时发送，因此需要事件触发机制——定时周期发送，这种实现方法有很多，本文采用Github Actions，因为免费且可用性很强；</li><li>接收方式：微信接收最方面，但是其SDK存在一些麻烦，因此一种间接的方式是通过发邮件到QQ邮箱，然后在微信中接收，然后利用默认浏览器打开Notion的链接；</li></ol><h1 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h1><h2 id="Notion-API"><a href="#Notion-API" class="headerlink" title="Notion API"></a>Notion API</h2><blockquote><p>本文不会介绍Notion。</p></blockquote><p>这里<a href="https://developers.notion.com/reference/post-database-query">使用Notion API来查询数据库</a>。其中注意使用的是filter和sort。其中需要考虑的问题是：</p><ul><li>查询API endpoints的方法；<ul><li><a href="https://ralphjsmit.com/api-endpoint-webhook-github-actions">在workflow中使用curl</a>：简单、直接，但是不能进行复杂逻辑的操作，比如生成随机数；</li><li>使用JavaScript查询：这个可以直接用原生js查询，也可以<a href="https://github.com/makenotion/notion-sdk-js">使用Notion提供的SDK</a>。</li></ul></li><li>API响应结果的解析<ul><li>这个需要进行测试，我感觉Notion给出的API文档说的不够清楚，需要自己去试，可能会出现很多问题；</li><li>这里我使用postman进行接口的测试；</li><li>还有一个要吐槽的是：Notion API中好像没有获取整篇文档的接口和选择，只能获取page的url；</li></ul></li></ul><h2 id="Github-Actions"><a href="#Github-Actions" class="headerlink" title="Github Actions"></a>Github Actions</h2><h3 id="1-触发事件"><a href="#1-触发事件" class="headerlink" title="1. 触发事件"></a>1. 触发事件</h3><ol><li>手动出发：便于调试；</li><li>定时触发：<a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule">schedule</a> 其中需要crontab表达式，不太了解的可以参考<a href="https://crontab.guru/">这里</a>。</li></ol><h3 id="2-设计actions"><a href="#2-设计actions" class="headerlink" title="2. 设计actions"></a>2. 设计actions</h3><p>本文设计了两个workflow，其实也不一定这样设计，主要我是为了多了解一下Github Actions的使用，如果你觉得麻烦可以放到一个workflow里，说到这里，想起之前看到的一篇文章——<a href="https://juejin.cn/post/6898953413250252814">新技术学习不完全指北：以 Rust 为例</a>。其中有一个观点，<strong>超纲训练是巩固知识的可靠方式，</strong>我这里也算超纲训练一下。</p><p>第一个workflow用来获取Notion中的信息，使用Notion提供的JavaScript SDK实现，具体包括：</p><ul><li>查询Notion database，并根据属性过滤和排序文章列表，以实现随机获取文章；</li><li>生成文章摘要模板，用于后续的邮件发送；</li></ul><p>第二个workflow主要是利用上一个workflow生成的信息并发送邮件，其中需要实现：</p><ul><li>编排不同的jobs；</li><li>获取jobs之间共享的信息，并发送出去：这里使用<a href="https://github.com/dawidd6/action-send-mail">已有的actions完成邮件的发送</a>；</li></ul><h1 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h1><h2 id="重用workflow"><a href="#重用workflow" class="headerlink" title="重用workflow"></a>重用workflow</h2><p>由于本文设计了两个workflows，从程序设计的角度看，其实是为了解耦以实现重用已有的workflow。类似于函数的设计，需要遵从一定的规范，比如：为了安全性，有些函数通过加限定符规定只能被同一个模块下的函数调用。Github Actions中也有类似的规定，与其说这些workflow像函数，不如说它们更像RPC。每个workflow都可以包含一个或者多个jobs，也就可以视为一个或者多个进程。</p><p>为了重用可共享的workflow，要求：</p><ul><li>需要复用的workflow支持 <code>workflow_call</code> 出发事件；<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> notion<span class="token punctuation">-</span>article<span class="token punctuation">-</span>query<span class="token comment" spellcheck="true"># Controls when the workflow will run</span><span class="token key atrule">on</span><span class="token punctuation">:</span>  <span class="token key atrule">workflow_call</span><span class="token punctuation">:</span></code></pre></li></ul><p>这样，此workflow才能在别的workflow中使用，该workflow只能在别的workflow的jobs中使用，而不是steps。并且<a href="https://docs.github.com/en/actions/using-workflows/reusing-workflows#access-to-reusable-workflows">需要满足一定的条件</a>，即如下其一：</p><ul><li>两个workflows需要在同一个目录下；</li><li>被重用的workflow需要存储在共有仓库并且组织允许你使用这些公有仓库；</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> notion<span class="token punctuation">-</span>article<span class="token punctuation">-</span>review<span class="token key atrule">on</span><span class="token punctuation">:</span>  <span class="token key atrule">schedule</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">cron</span><span class="token punctuation">:</span> <span class="token string">'0 4 * * *'</span>  <span class="token key atrule">workflow_dispatch</span><span class="token punctuation">:</span><span class="token key atrule">jobs</span><span class="token punctuation">:</span>  <span class="token key atrule">article-query</span><span class="token punctuation">:</span>    <span class="token key atrule">uses</span><span class="token punctuation">:</span> ./.github/workflows/notion<span class="token punctuation">-</span>article<span class="token punctuation">-</span>query.yml    <span class="token key atrule">secrets</span><span class="token punctuation">:</span> inherit  <span class="token key atrule">article-review</span><span class="token punctuation">:</span>        <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest</code></pre><p>更多复杂的功能可以参考<a href="https://docs.github.com/en/actions/using-workflows/reusing-workflows">Github Actions的文档</a>。</p><h2 id="jobs之间共享数据"><a href="#jobs之间共享数据" class="headerlink" title="jobs之间共享数据"></a>jobs之间共享数据</h2><p>首先从直觉上来看，不同的jobs可能在不同的虚拟机上，因此通过文件等方式是无法完成数据是共享的，这与RPC也是类似的。照着这个思路来想：</p><ul><li>引入第三方<ul><li>使用缓存服务器：如Redis，在Github Actions可以使用<a href="https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows">Cache</a>，官方提供了可以<a href="https://github.com/marketplace/actions/cache">直接使用的Cache Action</a>；</li><li>使用文件上传和下载：在Github Actions中<a href="https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts">使用Artifacts</a>实现；</li></ul>  两者的区别主要是：<blockquote><p><strong>Caching</strong> is used to re-use data/files between jobs or workflows while <strong>Artifacts</strong> are used to save files after workflow ended.</p></blockquote>  可以参考<a href="https://levelup.gitconnected.com/github-actions-how-to-share-data-between-jobs-fc1547defc3e">这里</a>。</li><li>workflow执行返回<ul><li>使用命令行：定义jobs的输出可以使用命令行的方式，<a href="https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs">官方直接给出例子</a>，其中的命令是Github Actions专有的命令，可以参考文档 <a href="https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions">Workflow commands for GitHub Actions</a>，告诉你怎么完成output的设置；<pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"::workflow-command parameter1={data},parameter2={data}::{command value}"</span></code></pre>  这一点本文没有使用。</li><li>使用JavaScript：这种适合复杂逻辑的场景，本文使用这种方式，通过引入<code>@actions/core</code> 完成输入和输出的设置，本文利用这个实现文章摘要的传递。<pre class=" language-bash"><code class="language-bash">const core <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"@actions/core"</span><span class="token punctuation">)</span><span class="token keyword">let</span> context <span class="token operator">=</span> `  <span class="token operator">&lt;</span>html<span class="token operator">></span>   <span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta http-equiv<span class="token operator">=</span><span class="token string">"Content-Type"</span> content<span class="token operator">=</span><span class="token string">"text/html; charset=utf-8"</span><span class="token operator">></span>   <span class="token operator">&lt;</span>/head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>      <span class="token operator">&lt;</span>p<span class="token operator">></span>题目：<span class="token variable">${title}</span><span class="token operator">&lt;</span>/p<span class="token operator">></span>      <span class="token operator">&lt;</span>p<span class="token operator">></span>标签：<span class="token variable">${tags}</span><span class="token operator">&lt;</span>/p<span class="token operator">></span>      <span class="token operator">&lt;</span>p<span class="token operator">></span>总结：<span class="token variable">${summary}</span><span class="token operator">&lt;</span>/p<span class="token operator">></span>      <span class="token operator">&lt;</span>p<span class="token operator">></span>链接：<span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"<span class="token variable">${url}</span>"</span><span class="token operator">></span>文章内容<span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>/body<span class="token operator">></span>  <span class="token operator">&lt;</span>/html<span class="token operator">></span>`<span class="token punctuation">;</span>core.setOutput<span class="token punctuation">(</span><span class="token string">'article-item'</span>, context<span class="token punctuation">)</span></code></pre>  注意，这是一个step中实现的输出，为了在重用的workflow中输出数据，需要将steps中的输出映射到jobs中，如下：<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">on</span><span class="token punctuation">:</span>  <span class="token key atrule">workflow_call</span><span class="token punctuation">:</span>    <span class="token key atrule">outputs</span><span class="token punctuation">:</span>      <span class="token key atrule">article-item</span><span class="token punctuation">:</span>        <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"article items"</span>        <span class="token key atrule">value</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> jobs.query<span class="token punctuation">-</span>article.outputs.output1 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">jobs</span><span class="token punctuation">:</span>  <span class="token key atrule">query-article</span><span class="token punctuation">:</span>    <span class="token key atrule">outputs</span><span class="token punctuation">:</span>      <span class="token key atrule">output1</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> steps.query<span class="token punctuation">-</span>step.outputs.article<span class="token punctuation">-</span>item <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token key atrule">steps</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Query Notion Articles        <span class="token key atrule">id</span><span class="token punctuation">:</span> query<span class="token punctuation">-</span>step                <span class="token comment" spellcheck="true"># 对应上述index.js的执行和输出</span>        <span class="token key atrule">run</span><span class="token punctuation">:</span> npm install &amp;&amp; npm run server</code></pre>  在其他的workflow中使用时，如下：<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">jobs</span><span class="token punctuation">:</span>  <span class="token key atrule">article-query</span><span class="token punctuation">:</span>    <span class="token key atrule">uses</span><span class="token punctuation">:</span> ./.github/workflows/notion<span class="token punctuation">-</span>article<span class="token punctuation">-</span>query.yml    <span class="token key atrule">secrets</span><span class="token punctuation">:</span> inherit  <span class="token key atrule">article-review</span><span class="token punctuation">:</span>    <span class="token key atrule">needs</span><span class="token punctuation">:</span> article<span class="token punctuation">-</span>query    <span class="token key atrule">steps</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> send mail        <span class="token key atrule">uses</span><span class="token punctuation">:</span> dawidd6/action<span class="token punctuation">-</span>send<span class="token punctuation">-</span>mail@master        <span class="token key atrule">with</span><span class="token punctuation">:</span>          <span class="token key atrule">html_body</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> needs.article<span class="token punctuation">-</span>query.outputs.article<span class="token punctuation">-</span>item <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>  其中<code>needs</code> 是用于编排不同的jobs的，后续会说明，直接引用这里使用的workflow并获取对应的输出的参数即可。</li></ul></li></ul><h2 id="编排jobs"><a href="#编排jobs" class="headerlink" title="编排jobs"></a>编排jobs</h2><p>如果没有加限制，不同的jobs之间是独立的，例如上述的两个workflow作为两个jobs使用时，如果不加限制，article-review可能无法获取article-query的article-item结果，因为它可能先执行结束，因此<a href="https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context">需要 <code>needs</code> 来保证不同的jobs的执行顺序</a>，从而构建一个dependency graph，使得不同的jobs之间可以串行、并行等。</p><p>本文需要保证 article-review 在article-query之后执行，因此需要<code>needs</code>来维护依赖关系。</p><h2 id="注意secrets"><a href="#注意secrets" class="headerlink" title="注意secrets"></a>注意secrets</h2><h3 id="存储secrets"><a href="#存储secrets" class="headerlink" title="存储secrets"></a>存储secrets</h3><p>敏感的信息保证不存在在代码中，Github提供一种不公开的方式，同时还定义了不同的粒度，<a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">可以参考具体文档</a>。</p><p><img src="/images/eff/not_git/secrets.png" alt="Untitled"></p><h3 id="使用secrets"><a href="#使用secrets" class="headerlink" title="使用secrets"></a>使用secrets</h3><p>这些secrets可以作为环境变量在workflow中使用，这里需要使用Github Actions提供的 <code>secrets</code> context实现，<a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets#using-encrypted-secrets-in-a-workflow">具体参考文档</a>，代码如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> Query Notion Articles    <span class="token key atrule">id</span><span class="token punctuation">:</span> query<span class="token punctuation">-</span>step    <span class="token key atrule">run</span><span class="token punctuation">:</span> npm install &amp;&amp; npm run server    <span class="token key atrule">env</span><span class="token punctuation">:</span>       <span class="token comment" spellcheck="true"># Required mail server address:</span>      <span class="token key atrule">NOTION_API_KEY</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> secrets.NOTION_API_KEY <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token comment" spellcheck="true"># Required mail server port:</span>      <span class="token key atrule">DATABASE_ID</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> secrets.ARTICLE_DATABASE_ID <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="不同workflow之间传递secrets"><a href="#不同workflow之间传递secrets" class="headerlink" title="不同workflow之间传递secrets"></a>不同workflow之间传递secrets</h3><p>这个问题可能很少有人提到，我在构建的时候遇到这个问题，在重用已有的workflow时，如果也存在secrets需要保密，需要在调用workflow中声明引用的workflow将集成本workflow下的所有secrets，操作如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">jobs</span><span class="token punctuation">:</span>  <span class="token key atrule">article-query</span><span class="token punctuation">:</span>    <span class="token key atrule">uses</span><span class="token punctuation">:</span> ./.github/workflows/notion<span class="token punctuation">-</span>article<span class="token punctuation">-</span>query.yml    <span class="token key atrule">secrets</span><span class="token punctuation">:</span> inherit   <span class="token key atrule">article-review</span><span class="token punctuation">:</span>        <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest</code></pre><p>具体细节可以<a href="https://docs.github.com/en/actions/using-workflows/reusing-workflows#passing-inputs-and-secrets-to-a-reusable-workflow">参考文档</a>。</p><h2 id="邮件模板"><a href="#邮件模板" class="headerlink" title="邮件模板"></a>邮件模板</h2><p>本文只是设计了一个简单文章摘要，包括：</p><ul><li>题目</li><li>标签</li><li>总结</li><li>文章内容的url；</li></ul><p>一种锦上添花的操作是使用HTML Email，<a href="http://www.ruanyifeng.com/blog/2013/06/html_email.html">阮一峰专门针对这个写了一篇文章</a>，可以参考。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个项目的代码在<a href="https://github.com/limeya/NotionReview">仓库</a>，最终的结果如下：</p><p><img src="/images/eff/not_git/result.png" alt="Untitled"></p><p>总的来看，这个过程：</p><ul><li>熟悉了Notion API和Github Actions的操作；</li><li>打开了Github Actions的有趣的世界，有很多的项目可以借鉴：<ul><li><a href="https://blog.owenyoung.com/zh/posts/actionsflow/">Actionsflow，也可以替代Github Actions实现workflow</a><strong><strong>。</strong></strong></li><li><a href="https://cloud.tencent.com/developer/article/1909652">自动同步博客文章到Github</a>，这个后边准备加入到我的仓库中；</li><li><a href="https://sspai.com/post/73188">整理Newsletter</a>；</li></ul></li><li>更大的收获，应该是让自己看过的和思考的内容不再堆在某个充满尘土的角落里，让知识和思想流动起来！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 效率生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notion </tag>
            
            <tag> Github Actions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101：Rasterization - Shadow Mapping</title>
      <link href="/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-rasterization-shadow-mapping/"/>
      <url>/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-rasterization-shadow-mapping/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>着色是局部的，这种方便但不对；</li><li>shading中无法解决阴影问题；</li></ul><p>那么：How to draw shadows using rasterization?</p><h1 id="方法：Shadow-Mapping"><a href="#方法：Shadow-Mapping" class="headerlink" title="方法：Shadow Mapping"></a>方法：Shadow Mapping</h1><h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><blockquote><p>the points NOT in shadow must be seen both <strong>by the light</strong> and <strong>by the camera</strong></p></blockquote><p>在该方法中，如果点不在“阴影”中，指的是其既能被光看见，也能被人眼看见。换句话说，当一个点在阴影中时，说明其或者不能被光看见，或者不能被人眼看见。</p><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>该方法是An Image-space Algorithm，如何理解？</p><blockquote><p>no knowledge of scene’s geometry during shadow computation</p></blockquote><p>在生成阴影的过程中不需要找到几何信息。</p><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p><img src="/images/games101/ext/1/sm_process.png" alt="Shadow Mapping具体过程"></p><p>该过程包含两个步骤：</p><ul><li>从光源看向具体的物体；</li><li>从人眼看向具体的物体；</li></ul><p>具体如上图所示：</p><ol><li>首先，从光源看向物体，可以得到光源能够看到的图，该图不进行着色，只记录看到的点的深度信息；<blockquote><p>Depth image from light source</p></blockquote></li><li>从人眼看向具体的物体，对于看到的物体上的点，将其投影回从光源角度看得到的平面，如第3部分，能够得到该点对应深度图上的哪个像素；<blockquote><p>Standard image (with depth) from eye</p></blockquote><blockquote><p>Project visible points in eye view back to light source</p></blockquote></li><li>比较投影到Depth image上的点的深度信息，与Depth image的深度信息，可以得到两个结果：<ul><li>(Reprojected) depths match for light and eye：说明该点能够被看见，不在阴影中；</li><li>depths from light and eye are not the same：该点不能被看见，在阴影中；</li></ul></li></ol><h2 id="实例操作过程"><a href="#实例操作过程" class="headerlink" title="实例操作过程"></a>实例操作过程</h2><ol><li><p>The <strong>depth buffer</strong> from the light’s point-of-view</p><p> <img src="/images/games101/ext/1/step1.png" alt="步骤1"></p></li><li><p>Comparing Dist(light, shading point) with shadow map</p><p> <img src="/images/games101/ext/1/step2.png" alt="步骤2"></p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/images/games101/ext/1/shadow_effect.png" alt="有无阴影效果"></p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><h3 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h3><blockquote><p>Involves equality comparison of floating point depth values means issues of scale, bias, tolerance.</p></blockquote><p>由于需要判断深度信息是否相等，当构建阴影时，会因为浮点数难以判断相等，导致阴影非常“脏”。如上图中的绿色图片所示。</p><p>一些方法：</p><ul><li>不判断相等，判断大小；</li><li>同时，加一个小的误差范围；</li></ul><p>但这些方法不能根本解决问题。</p><h3 id="Depth-image分辨率的影响"><a href="#Depth-image分辨率的影响" class="headerlink" title="Depth image分辨率的影响"></a>Depth image分辨率的影响</h3><blockquote><p>Quality depends on shadow map resolution (general problem with image-based techniques).</p></blockquote><p>当shadow map的分辨率很低时，其对应的深度信息可以覆盖多个重投影到该图上的点，因此会出现走样的问题，因此must deal with aliasing artifacts。增加分辨率能解决问题，但是开销增加。</p><h3 id="只能用于点光源"><a href="#只能用于点光源" class="headerlink" title="只能用于点光源"></a>只能用于点光源</h3><p>该方法只能处理点光源：因此其中的阴影，非0即1，即要么在阴影中，要么不在——硬阴影。</p><ul><li>硬阴影：完全看不到光，界限明显，光源是点光源；</li><li>软阴影：能看到部分光，界限圆滑，光源有一定大小；</li></ul><p><img src="/images/games101/ext/1/hard_vs_soft.png" alt="Hard shadows vs. Soft shadows"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>即便有很多问题，仍然是Well known rendering technique；</li><li>Basic shadowing technique for early animations and 3D video game；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光栅化 </tag>
            
            <tag> Rasterization </tag>
            
            <tag> Shadow Mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-12：Geometry - Mesh Operations</title>
      <link href="/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-12-geometry-mesh-operations/"/>
      <url>/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-12-geometry-mesh-operations/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>前面提到很多几何图形的Explicit Representations，包括：</p><ul><li>triangle meshes</li><li>Bezier curves &amp; surfaces</li><li>point clouds</li></ul><p>虽然之前详述了Bezier curves &amp; surfaces，但是在图形学中最常用的方式是Polygon Mesh，因为其有一些好的性质：</p><blockquote><p>Easier to do processing / simulation, adaptive sampling</p></blockquote><p>因此，Perhaps most common representation in graphics。</p><p>对于Mesh网络，其存在对应的几何操作：</p><ul><li>Mesh subdivision（upsampling）：细化三角形数量，实现了Increase resolution的效果；  <img src="/images/games101/12/subdivision.png" alt="Mesh subdivision"></li><li>Mesh simplification（downsampling）：正好与Mesh subdivision的效果相反；<blockquote><p>Decrease resolution; try to preserve shape/appearance.</p></blockquote>  <img src="/images/games101/12/simplify.png" alt="Mesh simplification"></li><li>Mesh regularization：使所有的三角形相同；<blockquote><p>Modify sample distribution to improve quality</p></blockquote>  这种方式有利于解决因三角形大小不同导致的渲染困难等问题，在改善三角形表示的同时，不能损失模型的表示效果。  <img src="/images/games101/12/regular.png" alt="Mesh regularization"></li></ul><p>这一节主要是对Mesh的几何操作（Geometry Processing）进行说明。</p><p><img src="/images/games101/12/gp.png" alt="Geometry Processing"></p><h1 id="Mesh-Subdivision"><a href="#Mesh-Subdivision" class="headerlink" title="Mesh Subdivision"></a>Mesh Subdivision</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>所谓的subdivision具体指两个操作：</p><ol><li>First, create more triangles (vertices)</li><li>Second, tune their positions：使得几何形状更平滑；</li></ol><p>这两步是 Common subdivision rule for triangle meshes。</p><h2 id="方法1：Loop-Subdivision"><a href="#方法1：Loop-Subdivision" class="headerlink" title="方法1：Loop Subdivision"></a>方法1：Loop Subdivision</h2><h3 id="划分三角形"><a href="#划分三角形" class="headerlink" title="划分三角形"></a>划分三角形</h3><p>该方法只针对三角形，将每条边的中点连接从而形成4个三角形。</p><blockquote><p>Split each triangle into four.</p></blockquote><p><img src="/images/games101/12/split_tri.png" alt="划分三角形"></p><h3 id="调整位置"><a href="#调整位置" class="headerlink" title="调整位置"></a>调整位置</h3><p>完成三角形划分后，需要调整三角形顶点的位置。</p><blockquote><p>Assign new vertex positions according to weights</p></blockquote><p>对于新的顶点和旧的顶点采用不同的方法进行调整。</p><blockquote><p>New / old vertices updated differently</p></blockquote><ul><li>对新顶点：对中心的新顶点，其新的位置取决于周围的旧节点；  <img src="/images/games101/12/loop_new_pos.png" alt="对新顶点调整位置"></li><li>对旧节点：其新的位置取决于自己原来的位置，和其周围节点的位置。  对于一个节点来说，当其度很大的时候，其自身的影响可以忽略不计；当度很小的时候，其需要更多的考虑自身之前的节点位置。  <img src="/images/games101/12/loop_old_pos.png" alt="对旧顶点调整位置"></li></ul><h3 id="方法效果"><a href="#方法效果" class="headerlink" title="方法效果"></a>方法效果</h3><p><img src="/images/games101/12/ls_effect.png" alt="Loop Subdivision的效果"></p><h2 id="方法2：Catmull-Clark-Subdivision"><a href="#方法2：Catmull-Clark-Subdivision" class="headerlink" title="方法2：Catmull-Clark Subdivision"></a>方法2：Catmull-Clark Subdivision</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Loop Subdivision只能针对网格中的三角形进行细分，无法作为通用的几何图形细分方法。</p><h3 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h3><ul><li>Non-quad face：不是四边形构成的面；</li><li>Extraordinary vertex：顶点的度不为4(degree != 4) ；</li></ul><p><img src="/images/games101/12/concept_def.png" alt="概念定义"></p><h3 id="增加三角形"><a href="#增加三角形" class="headerlink" title="增加三角形"></a>增加三角形</h3><p>为了增加三角形，具体步骤如下：</p><ul><li>Add vertex in each face</li><li>Add midpoint on each edge</li><li>Connect all new vertices</li></ul><p><img src="/images/games101/12/ccs_add_tri.png" alt="增加三角形"></p><p>在划分形状的过程中，经过一次划分后：</p><ul><li>extraordinary vertices数量：原始extraordinary vertices数量+原始non-quad faces数量</li><li>non-quad faces数量：无</li></ul><p>经过一次划分后，之后extraordinary vertices和non-quad faces数量不再变化。</p><h3 id="调整位置-1"><a href="#调整位置-1" class="headerlink" title="调整位置"></a>调整位置</h3><p>将顶点分为三种类型：</p><p><img src="/images/games101/12/tune_pos.png" alt="根据不同类型调整顶点位置"></p><h1 id="Mesh-simplification"><a href="#Mesh-simplification" class="headerlink" title="Mesh simplification"></a>Mesh simplification</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><blockquote><p>reduce number of mesh elements while maintaining the overall shape.</p></blockquote><p><img src="/images/games101/12/simple_goal.png" alt="Mesh simplification"></p><p>不同的场景下，选择的三角形的数量也不同，主要是考虑性能、存储空间，或者不需要考虑细节。</p><h2 id="一种方法：Collapsing-An-Edge"><a href="#一种方法：Collapsing-An-Edge" class="headerlink" title="一种方法：Collapsing An Edge"></a>一种方法：Collapsing An Edge</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><blockquote><p>simplify a mesh using <strong>edge collapsing</strong></p></blockquote><p>即将一条边转换为一个顶点。</p><h3 id="Collapse哪条边—Quadric-Error-Metrics"><a href="#Collapse哪条边—Quadric-Error-Metrics" class="headerlink" title="Collapse哪条边—Quadric Error Metrics"></a>Collapse哪条边—Quadric Error Metrics</h3><p>在确定通过坍缩一条边来简化图形后，一个问题是：应该坍缩哪条边，能够保持原来的几何形状？或许这个问题换种说法：坍缩后的边形成的节点应该在什么位置，使得能够保持几何形状？变为这个问题后，就不用判断哪条边重要，只要能够保持原有形状，确定新节点的位置即可。</p><p>如何确定新节点的位置呢？</p><ul><li>取相邻点的平均值；</li><li>取坍缩点的平均值；</li><li>……</li></ul><p>Quadric Error Metrics（⼆次误差度量）用一种度量的方法解决这个问题，该方法问一个问题：</p><blockquote><p>How much geometric error is introduced by simplification?</p></blockquote><p>其思想在于：</p><blockquote><p>Quadric error: new vertex should minimize its <strong>sum of square distance (L2 distance) to previously related triangle planes</strong>!</p></blockquote><p><img src="/images/games101/12/qem_compare.png" alt="Quadric Error Metrics与其他方法对比"></p><p>因为 Quadric Error Metrics 能够确定新的顶点位置，因此确定坍缩哪条边，可以转换为：坍缩 Quadric Error Metrics 最小的边，这样保证能够保持原有的形状，然后再一次坍缩第二小的，等等。</p><p>那么如何坍缩几何图形呢？一种方式是对整个几何图形的所有边都进行坍缩，然后计算每次坍缩操作对应的Quadric Error，然后排序，取最小误差对应的边进行坍缩。</p><p><strong>一个问题：当坍缩一条边后，其连接的边也发生了变化，之前对应该边的Quadric Error也就发生了变化。即Quadric Error随坍缩过程会发生动态变化。</strong></p><p><img src="/images/games101/12/dynamic.png" alt="一条边坍缩会引起其他边发生变化"></p><p>因此，上述的做法是行不通的。</p><p>实际的做法是：</p><ol><li>首先对整个几何物体的每条边进行坍缩，取最小Quadric Error对应的边；</li><li>将与该边连接的其他边对应的Quadric Error更新，再计算剩余最小Quadric Error对应的边；</li><li>对上述过程不断重复；</li></ol><p>该过程需要应用有优先队列或者堆来实现。</p><p><strong>一个问题：按照上述过程的顺序得到的所有边，对应的Quadric Error也是从最小到最大吗？显然不一定，其只是局部最小，因此是通过用局部最小代替全局最小</strong>——greedy algorithm。但是在实际中，这种方法的效果得到了认可。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/images/games101/12/collapse_effect.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geometry </tag>
            
            <tag> Mesh </tag>
            
            <tag> Mesh Operations </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-11-2：Geometry - Bézier Surfaces</title>
      <link href="/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-11-2-geometry-bezier-surfaces/"/>
      <url>/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-11-2-geometry-bezier-surfaces/</url>
      
        <content type="html"><![CDATA[<h1 id="Bezier-Surfaces"><a href="#Bezier-Surfaces" class="headerlink" title="Bézier Surfaces"></a>Bézier Surfaces</h1><blockquote><p>Extend Bézier curves to surfaces.</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="/images/games101/11/2/bs.png" alt="Bézier Surfaces例子"></p><h2 id="绘制Bezier-Surfaces"><a href="#绘制Bezier-Surfaces" class="headerlink" title="绘制Bézier Surfaces"></a>绘制Bézier Surfaces</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><blockquote><p>Bezier surface and 4 x 4 array of control points.</p></blockquote><p><img src="/images/games101/11/2/bs_patch.png" alt="Bicubic Bézier Surface Patch"></p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>以bi-cubic Bezier surface为例进行说明。</p><ul><li>输入：$4 \times 4$ control points；</li><li>输出：2D surface parameterized by $(u,v)$ in $[0,1]^2$；</li></ul><p>与Bézier curves同样的过程，只不过这里是在两个方向上进行双线性插值。</p><p><img src="/images/games101/11/2/step1.png" alt="步骤1"></p><p>该方法称之为——Separable 1D de Casteljau Algorithm。由于在贝塞尔曲线的生成中，需要利用一个时间 $t$ 来生成对应的曲线，泛化到三维空间中，则需要两个时间来生成曲面，这里定义为 $u, v$。 </p><p>具体过程如下：</p><ol><li>首先，在时间 $u$ 方向上生成对应的贝塞尔曲线，这里定义使用 $4 \times 4$ 的控制点构建曲面，因此这一步需要生成4条对应的贝塞尔曲线，得到的结果是任意时间 $u_i$ 下的最终的插值结果。</li><li>将第一步得到的4个插值点视为 $v$ 方向上的控制点，然后再进行同样的插值操作，然后形成曲面上的一个点；</li><li>按照上述过程，不断递归，从而形成最终所有的曲面上的点。</li></ol><p><img src="/images/games101/11/2/step2.png" alt="步骤2"></p><p>动画效果如下：</p><p><img src="/images/games101/11/2/animation_effect.gif" alt="动画效果"></p><h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><p>这里类似之前在曲线中讨论的问题，如：</p><ul><li>各个曲面如何拼接；</li><li>如果保证曲面拼接的“平滑”；</li></ul><p>在曲线中遇到的问题在这里均会遇到，对于进一步的学习可以参考之前在曲线中提到的参考资料。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geometry </tag>
            
            <tag> Bézier Surfaces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-11-1：Geometry - Curves</title>
      <link href="/2022/05/04/ji-suan-ji-tu-xing-xue/games/games101-11-1-geometry-curves/"/>
      <url>/2022/05/04/ji-suan-ji-tu-xing-xue/games/games101-11-1-geometry-curves/</url>
      
        <content type="html"><![CDATA[<h1 id="Explicit-Representations"><a href="#Explicit-Representations" class="headerlink" title="Explicit Representations"></a>Explicit Representations</h1><h2 id="Point-Cloud"><a href="#Point-Cloud" class="headerlink" title="Point Cloud"></a>Point Cloud</h2><ul><li>Easiest representation: list of points $(x,y,z)$<ul><li>不直接对几何表面进行表示，而是对构成图形的点的集合进行表示；</li></ul></li><li>Easily represent any kind of geometry<ul><li>只要点足够多和密集，就能够表示任意的几何物体；</li></ul></li><li>Useful for LARGE datasets (&gt;&gt;1 point/pixel)</li><li>Often converted into polygon mesh</li><li>Difficult to draw in undersampled regions<ul><li>当点不够密集时，则无法构成平面；</li></ul></li></ul><p><img src="/images/games101/11/1/cloud.png" alt="Point Cloud"></p><h2 id="Polygon-Mesh"><a href="#Polygon-Mesh" class="headerlink" title="Polygon Mesh"></a>Polygon Mesh</h2><ul><li>Perhaps most common representation in graphics<ul><li>最广泛的应用</li></ul></li><li>Store vertices &amp; polygons (often triangles or quads)</li><li>Easier to do processing / simulation, adaptive sampling</li><li>More complicated data structures</li></ul><p><img src="/images/games101/11/1/mesh.png" alt="Polygon Mesh"></p><h2 id="The-Wavefront-Object-File-obj-Format"><a href="#The-Wavefront-Object-File-obj-Format" class="headerlink" title="The Wavefront Object File (.obj) Format"></a>The Wavefront Object File (.obj) Format</h2><ul><li>该文件格式用于表示三角形面形成的物体</li><li>Just a text file that specifies vertices, normals, texture coordinates and their connectivities</li><li>其中：<ul><li>v：表示顶点向量；</li><li>vt：表示纹理坐标；</li><li>vn：表示顶点的法线向量；</li><li>f：表示三角形的各个面，以及它们之间的连接关系，其中三个序号依次为：顶点向量、纹理坐标、法线向量；<ul><li>例如：5/1/1    1/2/1    4/3/1 表示第5、1、4个顶点构成三角形，每个顶点对应的纹理坐标对应第1、2、3个，法线向量对应1、1、1个。</li></ul></li></ul></li></ul><p><img src="/images/games101/11/1/obj.png" alt="The Wavefront Object File"></p><h1 id="Bezier-Curves"><a href="#Bezier-Curves" class="headerlink" title="Bézier Curves"></a>Bézier Curves</h1><p>这是一种对于曲线显式表示的方法。</p><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><p>用一系列的控制点来表示曲线，以满足其特定的性质。</p><p>其中：</p><ul><li>控制点能唯一确定一条曲线；</li><li>但是不要求曲线能经过控制点，曲线只需要经过起点和终点；</li></ul><p><img src="/images/games101/11/1/bc.png" alt="Bézier Curves"></p><h2 id="绘制Bezier-Curves"><a href="#绘制Bezier-Curves" class="headerlink" title="绘制Bézier Curves"></a>绘制Bézier Curves</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果利用任意多个控制点，绘制一条Bézier Curves？</p><h3 id="解决方法：de-Casteljau-Algorithm"><a href="#解决方法：de-Casteljau-Algorithm" class="headerlink" title="解决方法：de Casteljau Algorithm"></a>解决方法：de Casteljau Algorithm</h3><p>该算法可以利用控制点生成曲线，其本质是在不同的线段上进行插值，然后将所有的插值点视为基础点，不断递归，直到最终的结果中只有一个插值点，该插值点即在生成的曲线上。</p><p>为了理解这个算法的过程，下边从：</p><ul><li>几何角度；</li><li>代数角度；</li></ul><p>两个方面理解这个算法。</p><h3 id="几何角度"><a href="#几何角度" class="headerlink" title="几何角度"></a>几何角度</h3><p>为了说明，考虑有三个控制点的情况（这种情况下生成的曲线称为quadratic Bezier）。</p><p>在如下3个控制点中，$\bf{b}_0$、$\bf{b}_2$ 分别为起点和终点，$\bf{b}_1$ 确定曲线的弯曲方向。那么如何控制曲线的生成呢？</p><p>一种方式是，为了从 $\bf{b}_0$ 到 $\bf{b}_2$ 绘制曲线，将从 $\bf{b}_0$ 开始的时间定为0，到 $\bf{b}_2$ 的时间定为1，那么曲线的绘制过程，其实就是找到在 $[0, 1]$ 时间范围内，曲线上的点的位置。因此，将绘制曲线的算法转换为定位一个点的位置的方法。</p><p>具体过程如下：</p><ol><li>Insert a point using linear interpolation 具体来说，即在$\bf{b}_0$、$\bf{b}_1$之间插值一个点 $\mathbf{b}_0^1$ ，使得： $$<br> \mathbf{b}_0^1 = (1 - t) \mathbf{b}_0 + t \bf{b}_1<br> $$</li><li>Insert on both edges 使用同样的方式在$\bf{b}_1$、$\bf{b}_2$之间插值一个点 $\mathbf{b}_1^1$ ，使得： $$<br> \mathbf{b}_1^1 = (1 - t) \mathbf{b}_1 + t \bf{b}_2<br> $$</li><li>Repeat recursively 按照上述方式进行递归计算，在$\mathbf{b}_0^1$ 和 $\mathbf{b}_1^1$两个插值点之间再进行插值得到新的插值点 $\mathbf{b}_0^2$ ，使得： $$<br> \mathbf{b}_0^2 = (1 - t) \mathbf{b}_0^1 + t \mathbf{b}_1^1<br> $$ 问题是：递归的结束条件是什么？当插值点只有一个时，即完成了递归过程。如利用3个控制点生成曲线的过程中：<ul><li>第1次插值：得到2个插值点 $\mathbf{b}_0^1$ 和 $\mathbf{b}_1^1$；</li><li>第2次插值：得到1个插值点 $\mathbf{b}_0^2$ ；</li></ul></li><li>Run the same algorithm for every t in $[0,1]$ 对于范围$[0,1]$ 中的每个 $t_i$，均进行上述过程，即完成了曲线的绘制。</li></ol><p><img src="/images/games101/11/1/casteljau.png" alt="de Casteljau Algorithm"></p><p>对于4个控制点生成曲线，过程如下：</p><p><img src="/images/games101/11/1/cubic_bc.png" alt="Cubic Bézier Curve"></p><p><strong>动画效果如下：</strong></p><blockquote><p>参考资料：Animation: Steven Wittens, Making Things with Maths, <a href="http://acko.net/">http://acko.net</a></p></blockquote><p><img src="/images/games101/11/1/bc_animation.gif" alt="贝塞尔曲线动画"></p><h3 id="代数角度"><a href="#代数角度" class="headerlink" title="代数角度"></a>代数角度</h3><p>在该算法中，通过对控制之间的线段不断进行插值，得以得到如下的金字塔形状。</p><p><img src="/images/games101/11/1/coef.png" alt="de Casteljau Algorithm系数计算"></p><ul><li>Every rightward arrow is multiplication by $t$ ;</li><li>Every leftward arrow by $(1–t)$ ;</li></ul><p>对于<strong>3个控制点</strong>形成的贝塞尔曲线，可以得到：</p><p>$$<br>\begin{array}{l}<br>\mathbf{b}_0^1 (t)= (1-t) \mathbf{b}_0+t \mathbf{b}_1 \\<br>\mathbf{b}_1^1 (t)= (1-t) \mathbf{b}_1+t \mathbf{b}_2<br>\end{array}<br>$$</p><p>$$<br>\begin{array}{l}<br>\mathbf{b}_0^2(t) = (1 - t) \mathbf{b}_0^1 + t \mathbf{b}_1^1<br>\\<br>\mathbf{b}_0^2(t)=(1-t)^2 \mathbf{b}_0+2 t(1-t) \mathbf{b}_1+t^2 \mathbf{b}_2<br>\end{array}<br>$$</p><h3 id="系数展开式"><a href="#系数展开式" class="headerlink" title="系数展开式"></a>系数展开式</h3><p>对于 $n+1$ 个控制点，可以进行 $n$ 次插值计算，其中生成的贝塞尔曲线上的任意一点均是控制点向量的线性组合，如下所示：</p><p>$$<br>\mathbf{b}^{n}(t)=\mathbf{b}_{0}^{n}(t)= \sum_{j=0}^n \mathbf{b}_j B_j^n (t)<br>$$</p><!-- $$\mathbf{b}^{n}(t)=\mathbf{b}_{0}^{n}(t)=\sum_{j=0}^{n} \mathbf{b}_{j} B_{j}^{n}(t)$$ --><p>其中：</p><ul><li>$\mathbf{b}^{n}(t)$ : Bézier curve order $n$ (vector polynomial of degree $n$);</li><li>$\mathbf{b}_{j}$ : Bézier control points (vector in $\mathbf{R}^N$);</li><li>$B_{j}^{n}(t)$ : Bernstein polynomial (scalar polynomial of degree $n$);</li></ul><p>该线性组合的系数 $B_{j}^{n}(t)$ 是一个与时间 $t$ 有关的多项式，称之为Bernstein polynomial，如下：</p><p>$$<br>B_{i}^{n}(t)=\left(\begin{array}{l}n \\ i\end{array}\right) t^{i}(1-t)^{n-i}<br>$$</p><p>整个Bernstein polynomial其实是一个二项分布，因此对于任意的n次展开式，其所有对应的系数之和为1。</p><p><img src="/images/games101/11/1/bp1.png" alt="Bernstein polynomial系数和为１"></p><p>其中，控制点不一定是2D的，也可以是3D空间中的，例如对于4个3D的控制点如下：</p><p>$$<br>\mathbf{b}_0=(0,2,3), \mathbf{b}_1=(2,3,5), \mathbf{b}_2=(6,7,9), \mathbf{b}_3=(3,4,5)<br>$$</p><p>可以得知任意时间 t 下，对应的曲线上的点为：</p><p>$$<br>\mathbf{b}^n (t)=\mathbf{b}_0 (1-t)^3 +\mathbf{b}_1 3 t(1-t)^2 +\mathbf{b}_2 3 t^2 (1-t)+\mathbf{b}_3 t^3<br>$$</p><h2 id="Bezier-Curves的性质"><a href="#Bezier-Curves的性质" class="headerlink" title="Bézier Curves的性质"></a>Bézier Curves的性质</h2><ol><li>Interpolates endpoints 对于4个控制点（cubic Bézier），则有： $$<br> \mathbf{b}(0)=\mathbf{b}_0 ; \quad \mathbf{b}(1)=\mathbf{b}_3<br> $$</li><li>Tangent to end segments 对于4个控制点（cubic Bézier），则有： $$<br> \mathbf{b}^{\prime}(0)=3\left(\mathbf{b}_1 -\mathbf{b}_0 \right) ; \quad \mathbf{b}^{\prime}(1)=3\left(\mathbf{b}_3 -\mathbf{b}_2 \right)<br> $$</li><li>Affine transformation property<blockquote><p>Transform curve by transforming control points.</p></blockquote> 对于贝塞尔曲线中的每个点进行仿射变换得到的贝塞尔曲线，与对贝塞尔曲线的控制点进行仿射变换然后再生成的贝塞尔曲线一致。因此，若要对贝塞尔曲线进行仿射变换，只需要对其控制点进行变换即可，然后再生成曲线。 这个性质只针对仿射变换，在投影等变换下不成立。</li><li>Convex hull property <a href="https://zh.wikipedia.org/zh-hans/%E5%87%B8%E5%8C%85">凸包</a>性质<blockquote><p>Curve is within convex hull of control points.</p></blockquote></li></ol><h1 id="Piecewise-Bezier-Curves"><a href="#Piecewise-Bezier-Curves" class="headerlink" title="Piecewise Bézier Curves"></a>Piecewise Bézier Curves</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>Higher-Order Bézier Curves会导致一些问题：</p><ul><li>当控制点很多时，很难针对特定控制点操作，以控制整体曲线的形状；</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><ul><li>不用控制点生成一条完整的曲线；</li><li>代替，使用少量的控制点生成一段曲线，然后将所有的曲线拼接起来；<blockquote><p>chain many low-order Bézier curve</p></blockquote></li></ul><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><blockquote><p>Piecewise cubic Bézier the most common technique</p></blockquote><p>即，实践中常用4个控制点生成一段曲线。</p><p><img src="/images/games101/11/1/pbc.png" alt="Piecewise Bézier Curves"></p><blockquote><p>参考资料：<a href="https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html">Bezier Curve Demos</a></p></blockquote><h3 id="问题：如何保证曲线光滑连接"><a href="#问题：如何保证曲线光滑连接" class="headerlink" title="问题：如何保证曲线光滑连接"></a>问题：如何保证曲线光滑连接</h3><p>保证上一条曲线终点的导数与下一条曲线起点的导数相同，包括方向和大小。</p><p>在这个问题上，可以有两种类型的连续（Continuity）：</p><ul><li>$C^0$ continuity：只要保证几何图形上连接即可；  $$<br>  \mathbf{a}_n = \mathbf{b}_0<br>  $$  <img src="/images/games101/11/1/c0.png" alt="$C^0$ continuity"></li><li>$C^1$ continuity：不仅几何上连接，导数也要相同；  $$<br>  \mathbf{a}_n = \mathbf{b}_0 = \frac{1}{2} (\mathbf{a}_{n-1} + \mathbf{b}_1)<br>  $$  <img src="/images/games101/11/1/c1.png" alt="$C^1$ continuity"></li></ul><p>在一些更严格的场合中，还有要求 $C^2$ continuity，即二阶导数相同。</p><h1 id="Splines"><a href="#Splines" class="headerlink" title="Splines"></a>Splines</h1><blockquote><p>a continuous curve constructed so as to pass through a given set of points and have a certain number of continuous derivatives.</p></blockquote><blockquote><p>In short, a curve under control.</p></blockquote><h2 id="B-splines"><a href="#B-splines" class="headerlink" title="B-splines"></a>B-splines</h2><ul><li>Short for basis splines</li><li>Require more information than Bezier curves</li><li>Satisfy all important properties that Bézier curves have (i.e. superset)</li></ul><p>本课中未详述样条内容，具体内容可以进一步参考以下资料。</p><p><a href="https://www.bilibili.com/video/av66548502?from=search&seid=65256805876131485">清华大学-计算机图形学基础（国家级精品课）_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geometry </tag>
            
            <tag> Curves </tag>
            
            <tag> Bézier Curves </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-10：Geometry - Implicit Representations</title>
      <link href="/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-10-geometry-implicit-representations/"/>
      <url>/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-10-geometry-implicit-representations/</url>
      
        <content type="html"><![CDATA[<h1 id="Ways-to-Represent-Geometry"><a href="#Ways-to-Represent-Geometry" class="headerlink" title="Ways to Represent Geometry"></a>Ways to Represent Geometry</h1><h2 id="Implicit-Representations"><a href="#Implicit-Representations" class="headerlink" title="Implicit Representations"></a>Implicit Representations</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>这种方法不会具体描述集几何物体上的每个点，而是描述所有的点满足的数学关系。</p><blockquote><p>Based on classifying points: Points satisfy some specified relationship.</p></blockquote><p>$$<br>f(x, y, z) = 0<br>$$</p><p>例如球体：</p><p>$$<br>f(x) = x^2 + y^2 + z^2 - 1<br>$$</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>Inside/Outside Tests Easy  <img src="/images/games101/10/im_io_easy.png" alt="容易判断内外"></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>Sampling Can Be Hard：可能很难看到该表示对应的具体几何形状是什么；  $$<br>  f(x, y, z)=\left(2-\sqrt{x^{2}+y^{2}}\right)^{2}+z^{2}-1<br>  $$  <img src="/images/games101/10/im_sample_hard.png" alt="难以判断几何形状"></li></ul><h2 id="Explicit-Representations"><a href="#Explicit-Representations" class="headerlink" title="Explicit Representations"></a>Explicit Representations</h2><blockquote><p>All points are <strong>given directly</strong> or via <strong>parameter mapping</strong></p></blockquote><p><img src="/images/games101/10/param_map.png" alt="Explicit: Parameter mapping"></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>Sampling Is Easy  <img src="/images/games101/10/ex_sample_easy.png" alt="容易采样"></li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>Inside/Outside Test Hard  <img src="/images/games101/10/ex_io_hard.png" alt="难以判断几何内外"></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>No “Best” Representation</li><li>Best Representation Depends on the Task!</li></ul><h1 id="不同类型的Implicit-Representations"><a href="#不同类型的Implicit-Representations" class="headerlink" title="不同类型的Implicit Representations"></a>不同类型的Implicit Representations</h1><h2 id="Algebraic-Surfaces"><a href="#Algebraic-Surfaces" class="headerlink" title="Algebraic Surfaces"></a>Algebraic Surfaces</h2><blockquote><p>Surface is zero set of a polynomial in $x, y, z$ .</p></blockquote><p>使用数学公式表示：</p><ul><li>不直观，无法判断具体形状；</li></ul><p><img src="/images/games101/10/alge.png" alt="Algebraic Surfaces"></p><h2 id="Constructive-Solid-Geometry-CSG"><a href="#Constructive-Solid-Geometry-CSG" class="headerlink" title="Constructive Solid Geometry (CSG)"></a>Constructive Solid Geometry (CSG)</h2><blockquote><p>Combine implicit geometry via <strong>Boolean operations</strong>.</p></blockquote><p><img src="/images/games101/10/csg.png" alt="Constructive Solid Geometry"></p><h2 id="Distance-Functions"><a href="#Distance-Functions" class="headerlink" title="Distance Functions"></a>Distance Functions</h2><blockquote><p>Instead of Booleans, gradually blend surfaces together using <strong>Distance function</strong>s.</p></blockquote><blockquote><p>Distance function giving <strong>minimum distance</strong> (could be signed distance) from anywhere to object.</p></blockquote><p>对任何几何物体，不直接描述其表面，而是描述空间上任意一点到这个集合物体表面的最小距离。</p><p>这个最小距离是有符号的：</p><ul><li>当空间上的点在物体内部，则到该物体表明的距离为负值；</li><li>当空间上的点在物体外部，则到该物体表明的距离为正值；</li></ul><p><img src="/images/games101/10/blending.png" alt="Blending"></p><p>对于每个几何物体都可以计算出其对应的距离函数，这种函数一般将任意一点当做参数，同时定义对应的几何物体表面（这个表面只是一种泛化的说法，其可以是球体的球心，圆的圆心），例如定义球的距离函数如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">float</span> <span class="token function">sdf_sphere</span> <span class="token punctuation">(</span>float3 p<span class="token punctuation">,</span> float3 c<span class="token punctuation">,</span> <span class="token keyword">float</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">distance</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token operator">-</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>参考资料：</p><ul><li><p><a href="https://www.alanzucconi.com/2016/07/01/signed-distance-functions/">Volumetric Rendering: Signed Distance Functions - Alan Zucconi</a></p></li><li><p><a href="https://iquilezles.org/articles/distfunctions2d/">Inigo Quilez - 2D distance functions</a></p></li></ul><h3 id="例子：Blending-a-moving-boundary"><a href="#例子：Blending-a-moving-boundary" class="headerlink" title="例子：Blending a moving boundary"></a>例子：Blending a moving boundary</h3><p><img src="/images/games101/10/example_blend.png" alt="Blending a moving boundary"></p><p>上图中，将A中阴影部分的右边界定义为物体表面，则得到其对应的距离函数在其下方所示。通过对A和B两个物体的距离函数进行融合，可以得到融合后的物体的拓扑结构。</p><p>对于任意两个几何物体的blending的操作示意图如下：</p><p><img src="/images/games101/10/blend_any.png" alt="利用距离函数对任意物体融合"></p><h2 id="Level-Set-Methods"><a href="#Level-Set-Methods" class="headerlink" title="Level Set Methods"></a>Level Set Methods</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>Closed-form equations are hard to describe complex shapes.</p></blockquote><p>这种方法针对的问题是：不是任何几何图形都有对应的数学解析形式，面对这种情况，可以通过grid的方式将距离函数表示出来。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><blockquote><p>store a grid of values approximating function.</p></blockquote><p><img src="/images/games101/10/level_set.png" alt="Level Set Methods"></p><blockquote><p>Surface is found where <strong>interpolated values</strong> equal zero.</p></blockquote><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><blockquote><p>Provides much more explicit control over shape (like a texture).</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>与texture结合：Level sets encode, e.g., constant tissue density. 将相同密度的部分连接起来形成平面结构；  <img src="/images/games101/10/medical_image.png" alt="医学图像"></li><li>Level set encodes distance to air-liquid boundary：将不同的水珠连接起来；  <img src="/images/games101/10/air.png" alt="水珠效果"></li></ul><h2 id="Fractals"><a href="#Fractals" class="headerlink" title="Fractals"></a>Fractals</h2><blockquote><p>Exhibit self-similarity, detail at all scales.</p></blockquote><p>类似编程中的递归过程，是同一图形在不同scale上的展示。</p><p><img src="/images/games101/10/fractals.png" alt="Fractals例子"></p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><blockquote><p>Hard to control shape.</p></blockquote><p>因为频率很高，因此很容易造成走样。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="Implicit-Representations的优点"><a href="#Implicit-Representations的优点" class="headerlink" title="Implicit Representations的优点"></a>Implicit Representations的优点</h3><ul><li>compact description (e.g., a function)</li><li>certain queries easy (inside object, distance to surface)</li><li>good for ray-to-surface intersection</li><li>for simple shapes, exact description / no sampling error</li><li>easy to handle changes in topology (e.g., fluid)</li></ul><h3 id="Implicit-Representations的缺点"><a href="#Implicit-Representations的缺点" class="headerlink" title="Implicit Representations的缺点"></a>Implicit Representations的缺点</h3><ul><li>difficult to model complex shapes</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geometry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-09-3：Shading - Texture Mapping - Applications of Textures</title>
      <link href="/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-3-shading-texture-mapping-applications-of-textures/"/>
      <url>/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-3-shading-texture-mapping-applications-of-textures/</url>
      
        <content type="html"><![CDATA[<h1 id="Texture的泛化理解"><a href="#Texture的泛化理解" class="headerlink" title="Texture的泛化理解"></a>Texture的泛化理解</h1><blockquote><p>泛化理解texture：<strong>In modern GPUs, texture = memory + range query (filtering)</strong></p></blockquote><p>即，纹理不仅仅用在图像上，可以是任意的内存数据和对应的范围查询方法。</p><p>基于这种理解，texture其实是：</p><blockquote><p><strong>General method to bring data to fragment calculations.</strong></p></blockquote><p>可以在很多的场景中使用：</p><ul><li>Environment lighting</li><li>Store microgeometry</li><li>Procedural textures</li><li>Solid modeling</li><li>Volume rendering</li></ul><h1 id="Environment-lighting"><a href="#Environment-lighting" class="headerlink" title="Environment lighting"></a>Environment lighting</h1><p>对于在着色模型中，将环境光视为常数，与其他两项相加共同完成着色过程。通过纹理可以记录环境光，然后应用到任意的渲染物体上，这种方法比之前应用点光源的效果要好很多。</p><h2 id="例子：Environment-Map"><a href="#例子：Environment-Map" class="headerlink" title="例子：Environment Map"></a>例子：Environment Map</h2><p><img src="/images/games101/09/3/environment_map.png" alt="Environment Map"></p><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>用纹理描述环境光时，假设所有光照均来自无限远处。这种假设使得光照均来自同一个方向，即光照方向的不同不会对环境光的记录产生影响。</p><h2 id="记录环境光"><a href="#记录环境光" class="headerlink" title="记录环境光"></a>记录环境光</h2><h3 id="Spherical-Environment-Map"><a href="#Spherical-Environment-Map" class="headerlink" title="Spherical Environment Map"></a><strong>Spherical Environment Map</strong></h3><p>将环境光照存储在球面上，然后将其展开，之后贴到不同的物体上。但是这种方法在靠近球的极点的位置上，会出现扭曲的现象。</p><p><img src="/images/games101/09/3/spherical_map.png" alt="Spherical Environment Map"></p><p><img src="/images/games101/09/3/distortion.png" alt="球面展开后的扭曲现象"></p><h3 id="解决方法：Cube-Map"><a href="#解决方法：Cube-Map" class="headerlink" title="解决方法：Cube Map"></a><strong>解决方法：Cube Map</strong></h3><p><img src="/images/games101/09/3/cube_map.png" alt="Cube Map"></p><blockquote><p>A vector maps to cube point along that direction.<br>The cube is textured with 6 square texture maps.</p></blockquote><p>简单来说，在球体外切一个立方体，然后将通过球体记录的信息映射到该立方体中。</p><p>这种方法：</p><ul><li>使得扭曲现象得到缓解；</li><li>但是需要增加计算：需要找到球面上的方向信息映射到立方体的哪个面上；</li></ul><p><img src="/images/games101/09/3/tt6.png" alt="Cube Map各个面上图片展开"></p><h1 id="Store-microgeometry"><a href="#Store-microgeometry" class="headerlink" title="Store microgeometry"></a>Store microgeometry</h1><p>纹理不仅可以存储颜色信息，还可以用于存储几何信息。</p><h2 id="Bump-Normal-mapping"><a href="#Bump-Normal-mapping" class="headerlink" title="Bump / Normal mapping"></a>Bump / Normal mapping</h2><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><p>用于定义shading surface中的shading point的相对高度，从而实现“凹凸不平”的效果，但是这种实现并没有改变原本的几何形状，而是<strong>Fake the detailed geometry</strong>。</p><p>这种方法的好处在于：</p><ul><li>没有改变几何物体形状，但是通过复杂的纹理可以实现相同的目标。<blockquote><p>Adding surface detail without adding more triangles</p></blockquote></li></ul><p>其核心idea在于：</p><ul><li>Perturb surface normal per pixel (for shading computations only)</li><li>“Height shift” per texel defined by a texture</li></ul><h3 id="如何计算新的法线"><a href="#如何计算新的法线" class="headerlink" title="如何计算新的法线"></a>如何计算新的法线</h3><p>基于这种想法，一个点的高度通过纹理信息被“修改”了，从而也修改了对应的法线信息。那么一个问题是：How to modify normal vector?</p><p><img src="/images/games101/09/3/normal_compute.png" alt="如何计算新的法线"></p><p>根据不同的应用场景，可以分为：</p><ul><li>in flatland (1D)<ul><li>假设原始着色平面的法线向量沿着y轴方向 $n(p) = (0, 1)$；</li><li>对于加入纹理信息后，一个点p的相对高度发生变化，其导数方向为：每移动1，则高度变化为 $dp = c \cdot [h(p+1) - h(p)]$，因此导数方向为 $(1, -\text{dp})$，其中 $c$ 是放缩因子。</li><li>根据旋转变换，对应该点的法线向量为 $n(p) = (-dp, 1).\text{normalized}()$；</li></ul>  <img src="/images/games101/09/3/flat_normal.png" alt="Normal Compute in Flatland"></li><li>in 3D  在真实的纹理中计算导数时，需要同时在纹理坐标的 $u,v$ 方向同时计算。  同样的过程：<ul><li>假设原始着色平面的法线向量 $n(p) = (0,0, 1)$；</li><li>p点在纹理上的导数方向：  $$<br>  \begin{array}{l}<br>  dp / du= c_1 \cdot [h(\mathbf{u}+1)-h(\mathbf{u})] \\<br>  dp / dv=c_2 \cdot [h(\mathbf{v}+1)-h(\mathbf{v})]\end{array}<br>  $$</li><li>最终新的法线方向为：$n = (-dp/du, -dp/dv, 1).\text{normalized}()$</li></ul></li></ul><p>在该过程中所有的向量计算均针对的是local coordinate，因此为了应用需要将该坐标变换到真实世界中的坐标中。</p><h2 id="Displacement-mapping"><a href="#Displacement-mapping" class="headerlink" title="Displacement mapping"></a>Displacement mapping</h2><h3 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea"></a>Idea</h3><ul><li>a more advanced approach</li><li>Uses the same texture as in bumping mapping</li><li>Actually moves the vertices：相比于bumping mapping不改变几何形状，这里的方法是将shading point进行移动，而不是虚拟操作。两种方法的效果对比如下：  <img src="/images/games101/09/3/map_compare.png" alt="Bump vs Displacement mapping"></li></ul><h3 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h3><ul><li>要求几何形状中的三角形足够密集、细致：这样对于不同的纹理图片中调整的高度，待渲染对象中的三角形不会因为过大出现走样问题；</li></ul><h3 id="一种优化方法"><a href="#一种优化方法" class="headerlink" title="一种优化方法"></a>一种优化方法</h3><ul><li>当三角形不够细致时，可以动态检测三角形是否应该更小和细致？在Direct X中可以动态调整三角形的细致程度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
            <tag> Texture Mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-09-2：Shading - Texture Mapping - Applying Textures</title>
      <link href="/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-2-shading-texture-mapping-applying-textures/"/>
      <url>/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-2-shading-texture-mapping-applying-textures/</url>
      
        <content type="html"><![CDATA[<h1 id="应用例子：Diffuse-Color"><a href="#应用例子：Diffuse-Color" class="headerlink" title="应用例子：Diffuse Color"></a>应用例子：Diffuse Color</h1><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token function">each_rasterized_screen_sample</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token operator">:</span>          <span class="token comment" spellcheck="true">// Usually a pixel’s center</span>    <span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">evaluate_texture_coordinate_at</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// Using barycentric coordinates</span>    texcolor <span class="token operator">=</span> texture<span class="token punctuation">.</span><span class="token function">sample</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_sample_color_to_texcolor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// Usually the diffuse albedo Kd</span></code></pre><p>简单来说，这个过程可以总结为：</p><ol><li>对于每个经过光栅化的像素，首先计算其重心坐标；</li><li>根据光栅化后的三角形中顶点与纹理坐标的映射关系（视为已知），利用三角形中任意一点的重心坐标，插值得到其对应的纹理坐标；</li><li>利用得到的纹理坐标得到纹理信息 texcolor；</li><li>将该纹理信息设置到光栅后的三角形内部，即实现将纹理“贴到”物体上，上例中是将纹理信息视为漫反射系数。</li></ol><p>这个过程比较简单，但是会产生问题。</p><h1 id="问题：Texture-Magnification-纹理太小"><a href="#问题：Texture-Magnification-纹理太小" class="headerlink" title="问题：Texture Magnification 纹理太小"></a>问题：Texture Magnification 纹理太小</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>纹理的分辨率很小，但是待渲染的物体分辨率很高，这会产生什么问题？在物体上的多个像素点可以对应纹理上的同一个texel（A pixel on a texture — a texel），例如通过对得到的纹理坐标四舍五入，取最临近的纹理坐标，因此可能会出现问题。</p><p><img src="/images/games101/09/2/problem.png" alt="问题描述"></p><h2 id="Nearest"><a href="#Nearest" class="headerlink" title="Nearest"></a>Nearest</h2><p>最直接的方法：直接四舍五入取最近的纹理坐标。</p><h2 id="Bilinear"><a href="#Bilinear" class="headerlink" title="Bilinear"></a>Bilinear</h2><p><img src="/images/games101/09/2/bilinear.png" alt="Bilinear插值过程"></p><p>考虑最终的效果和计算复杂度，bilinear得到了很好的平衡。</p><h2 id="Bicubic"><a href="#Bicubic" class="headerlink" title="Bicubic"></a>Bicubic</h2><p>使用周围的16个texel进行插值，效果更好，但是计算量更大。</p><h1 id="问题：Texture-Magnification-纹理太大"><a href="#问题：Texture-Magnification-纹理太大" class="headerlink" title="问题：Texture Magnification 纹理太大"></a>问题：Texture Magnification 纹理太大</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>在应用texture时，采用上例Diffuse Color中使用的方法，很简单，但是由于只是对纹理中的一个点进行采样。当纹理过大时会出现问题，如下图中在近处出现锯齿，在远处出现摩尔纹。</p><p><img src="/images/games101/09/2/tt_big_problem.png" alt="问题描述"></p><h2 id="原因剖析"><a href="#原因剖析" class="headerlink" title="原因剖析"></a>原因剖析</h2><p>如上图所示，从左到右对应上图中从近到远：</p><ul><li>在近处：一个像素对应纹理中的texel较少；</li><li>在远处时，一个像素对应纹理中的很多texel；</li></ul><p>基于这种情况：</p><ul><li>在近处，使用point sampling时，可以在纹理中直接采样对应的纹理信息，由于覆盖的纹理区域较小，因此直接采用对应的纹理信息，问题不大；</li><li>在远处时，由于覆盖的纹理区域较大，因此直接采用对应的一个点的纹理信息，会产生以偏概全的问题；</li></ul><p><img src="/images/games101/09/2/reason.png" alt="纹理太大造成问题的原因剖析"></p><h2 id="解决方案1：Supersampling-Do-Antialiasing"><a href="#解决方案1：Supersampling-Do-Antialiasing" class="headerlink" title="解决方案1：Supersampling Do Antialiasing"></a>解决方案1：Supersampling Do Antialiasing</h2><p>使用MSAA进行反走样可以解决问题。</p><p><img src="/images/games101/09/2/msaa_tt.png" alt="使用MSAA解决纹理过大的问题"></p><h3 id="为什么有效？"><a href="#为什么有效？" class="headerlink" title="为什么有效？"></a>为什么有效？</h3><p>对于远处区域来说，由于覆盖的纹理区域较大，可以视为用像素中的低频信号采样纹理中的高频信号，因为很小的一块像素区域对应很大的纹理区域。</p><p>基于这种情况，MSAA的策略是将像素点划分为更小的单元，从而提高了采样频率，以实现反走样，能够解决该问题。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然这种方法能够解决问题，但是存在代价太大的问题，尤其是当远处的像素和近处的像素覆盖纹理区域的范围很悬殊时，对于像素的进一步划分，在近处的效果很好，但是在远处可能提升有限。同时，当远处的像素区域很小时，若要提升效果，可能需要划分更多的单元，但是在近处则带来计算代价的上升。</p><h2 id="解决方案2：Range-Query-Mipmap"><a href="#解决方案2：Range-Query-Mipmap" class="headerlink" title="解决方案2：Range Query - Mipmap"></a>解决方案2：Range Query - Mipmap</h2><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><p>代替进行采样，直接获得像素覆盖的纹理区域的平均值，这相当于把之前的针对一个像素点的纹理信息的查询转换为特定区域内的范围查询，以便实现平滑的效果。</p><blockquote><p>get the average value within a range.</p></blockquote><h3 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h3><blockquote><p>Allowing (fast, approx., square) range queries.</p></blockquote><p>该方法只能进行近似的、正方形区域的快速范围查询。</p><p><img src="/images/games101/09/2/mipmap.png" alt="Mipmap"></p><p>对于一个纹理图片来说，所谓mipmap指的是不断缩小图片的分辨率从而得到对应区域的纹理信息，上图中虽然所有的图片都是相同尺寸，这是为了展示效果，实际中每次缩小，尺寸均变为原来的0.25。</p><p><img src="/images/games101/09/2/hierarchy.png" alt="Mip Hierarchy"></p><p>考虑到一个正方形的纹理图片 $n \times n$，当缩小分辨率时，其增加的存储空间有多少？估算一下：</p><p>$$<br>n \times n + \frac{1}{2}n \times \frac{1}{2}n + \frac{1}{2^2}n \times \frac{1}{2^2}n + \frac{1}{2^3}n \times \frac{1}{2^3}n + \cdots = \frac{1 \times (1 - \frac{1}{4^{\infty}})}{1 - \frac{1}{4}} n \times n = \frac{4}{3} n \times n<br>$$</p><p>即，存储空间仅增加了原来的33%。</p><h3 id="应用Mipmap"><a href="#应用Mipmap" class="headerlink" title="应用Mipmap"></a>应用Mipmap</h3><p>在应用Mipmop的过程中，需要两个步骤：</p><ol><li>首先要估算一个像素在纹理上的覆盖的区域大小；<blockquote><p>Estimate texture footprint using texture coordinates of neighboring screen samples.</p></blockquote> <img src="/images/games101/09/2/estimate_area.png" alt="估算像素在纹理上的覆盖面积"> $$<br> L=\max \left(\sqrt{\left(\frac{d u}{d x}\right)^{2}+\left(\frac{d v}{d x}\right)^{2}}, \sqrt{\left(\frac{d u}{d y}\right)^{2}+\left(\frac{d v}{d y}\right)^{2}}\right)<br> $$ 实际计算中，也可以利用别的方法进行估计，如：直接利用像素点边界上的4个顶点进行估算。</li><li>计算该纹理区域大小对应的纹理信息的平均值； 根据得到的覆盖范围 $L$，确定了正方形的大致范围。然后查询该覆盖范围对应的平均纹理信息： $$<br> D = \log_2 L<br> $$<blockquote><p>D rounded to nearest integer level.</p></blockquote> 其中 D对应的是mipmap中的不同层中经过分辨率缩小的纹理图片。</li></ol><h3 id="Mipmap分层带来的不连续问题"><a href="#Mipmap分层带来的不连续问题" class="headerlink" title="Mipmap分层带来的不连续问题"></a>Mipmap分层带来的不连续问题</h3><p>利用该方法发现，不同层之间是离散的，因此当“贴”到物体上时，会出现明显的界限，</p><p><img src="/images/games101/09/2/mipmap_discrete.png" alt="Mipmap分层带来的问题和改进"></p><p>为了平滑过度，需要将不同层的纹理图片之间建立连续的关系——插值。</p><p>复用之前的bilinear方法，相比于之前，这些还需要在不同层之间进行插值，因此称之为——Trilinear Interpolation。</p><p><img src="/images/games101/09/2/trilinear.png" alt="Trilinear Interpolation"></p><h3 id="Mipmap的缺陷"><a href="#Mipmap的缺陷" class="headerlink" title="Mipmap的缺陷"></a>Mipmap的缺陷</h3><p>Mipmap方法的效果如下：</p><p><img src="/images/games101/09/2/mipmap_effect.png" alt="Mipmap方法的效果"></p><p>发现Mipmap相比于Point sampling能够解决部分问题，但是相比于利用MSAA方法，在远处出现了overblur。主要的原因在于mipmop只能处理正方向区域的近似范围查询，但是在上图中显然在远处，会有一些矩形出现，因此用一个正方形覆盖矩形，难免会出现平滑过度的问题，因此远处连成一片了。</p><p><img src="/images/games101/09/2/mipmap_issue.png" alt="Mipmap的缺陷：无法应对不规则图形"></p><p>针对不规则区域映射的问题：</p><ul><li>mipmop只能解决正方形区域近似范围计算的问题；</li><li>Anisotropic Filtering则同时能够对矩形进行范围计算；</li><li>EWA filtering能进一步对不规则放置的四边形进行范围计算；</li></ul><h2 id="解决方案3：Range-Query-Anisotropic-Filtering"><a href="#解决方案3：Range-Query-Anisotropic-Filtering" class="headerlink" title="解决方案3：Range Query - Anisotropic Filtering"></a>解决方案3：Range Query - Anisotropic Filtering</h2><p><img src="/images/games101/09/2/anisotropic.png" alt="Anisotropic Filtering"></p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><blockquote><p>Can look up axis-aligned rectangular zones.</p></blockquote><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><blockquote><p>Diagonal footprints still a problem.</p></blockquote><p>该方法将存储空间提高了3倍：</p><p>$$<br>n \times n + 2 \times \left( \frac{1}{2}n \times n + \frac{1}{2^2}n \times n +  \frac{1}{2^3}n \times n + \cdots \right) = n \times n + 2 \times \frac{\frac{1}{2} \times (1 - \frac{1}{2^{\infty}})}{1 - \frac{1}{2}} n \times n  = 3 n \times n<br>$$</p><h2 id="解决方案4：Range-Query-EWA-filtering"><a href="#解决方案4：Range-Query-EWA-filtering" class="headerlink" title="解决方案4：Range Query - EWA filtering"></a>解决方案4：Range Query - EWA filtering</h2><p><img src="/images/games101/09/2/ewa.png" alt="EWA filtering"></p><h3 id="idea-1"><a href="#idea-1" class="headerlink" title="idea"></a>idea</h3><ul><li>Use multiple lookups：同时使用多个图形近似计算不规则区域；</li><li>Weighted average：对多个图形进行加权计算；</li><li>Mipmap hierarchy still helps</li></ul><h3 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>Can handle irregular footprints</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
            <tag> Texture Mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-09-1：Shading - Texture Mapping - Barycentric coordinates</title>
      <link href="/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-1-shading-texture-mapping-barycentric-coordinates/"/>
      <url>/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-1-shading-texture-mapping-barycentric-coordinates/</url>
      
        <content type="html"><![CDATA[<h1 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一个物体的不同区域使用了相同的着色模型，但是不同区域的漫反射系数 $k_d$ 不同，该系数的不同会导致出现不同的纹理 texture。</p><p>之前提到的着色模型未过多考虑shading point本身的性质，只提到了漫反射系数、镜面反射系数等，但是着色区域本身存在很多不同的性质，这些性质均会影响shading的效果。因此，本质上纹理是逐shading point改变其自身的性质，使得即便在相同的着色模型下，其着色的效果也会有差异。</p><p>那么如何定义着色区域的不同性质呢？引入纹理映射。</p><h2 id="定义shading-point的基本属性"><a href="#定义shading-point的基本属性" class="headerlink" title="定义shading point的基本属性"></a>定义shading point的基本属性</h2><h3 id="Idea-Surfaces-are-2D"><a href="#Idea-Surfaces-are-2D" class="headerlink" title="Idea: Surfaces are 2D"></a>Idea: Surfaces are 2D</h3><ul><li>Surface lives in 3D world space</li><li>Every 3D surface point also has a place where it goes in the 2D image (<strong>texture</strong>).</li></ul><p><img src="/images/games101/09/1/tt_map.png" alt="Texture Mapping"></p><h2 id="纹理如何应用：Texture-Applied-to-Surface"><a href="#纹理如何应用：Texture-Applied-to-Surface" class="headerlink" title="纹理如何应用：Texture Applied to Surface"></a>纹理如何应用：Texture Applied to Surface</h2><p>需要建立三维物体中的三角形与纹理中的三角形的映射关系，保证两者一一对应，同时尽可能少地出现拉伸等情况。</p><p>这种对应关系可以由艺术家完成创造，或者自动化实现。本课中，默认两者已经建立了映射关系，即物体上的每一点均在纹理上有对应的坐标，只需利用这个关系即可。</p><p><img src="/images/games101/09/1/tt_apply.png" alt="Texture Applied to Surface"></p><h2 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h2><p>Each triangle vertex is assigned a texture coordinate $(u,v)$，两个方向的坐标均在$(0,1)$内，以便处理，不考虑其真实像素是多少。</p><p><img src="/images/games101/09/1/tt_location.png" alt="纹理坐标"></p><h2 id="Textures-can-be-used-multiple-times"><a href="#Textures-can-be-used-multiple-times" class="headerlink" title="Textures can be used multiple times"></a>Textures can be used multiple times</h2><p>在纹理映射中，物体上的多个区域可能对应相同的纹理区域，即纹理可以使用多次，当多次使用时，会在相同纹理之间出现不必要的界限，因此如何在多次使用中使相同的纹理之间的过度比较平滑是一个问题。</p><h1 id="Interpolation-Across-Triangles"><a href="#Interpolation-Across-Triangles" class="headerlink" title="Interpolation Across Triangles"></a>Interpolation Across Triangles</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>到目前为止，有两个应用场景需要进行插值：</p><ul><li>Specify values at vertices  shading frequencies 中的 Gouraud shading和Phong shading分别需要对顶点和像素计算法线向量，然后在三角形内部计算相应的颜色等属性；</li><li>Obtain smoothly varying values across triangles  在三维物体与纹理映射中，三角形的顶点在纹理中有相应的纹理坐标，但是三角形内的区域需要通过插值计算相应的纹理坐标，以实现纹理覆盖到物体表面时，能够自然平滑的过度。</li></ul><h2 id="插值针对的对象"><a href="#插值针对的对象" class="headerlink" title="插值针对的对象"></a>插值针对的对象</h2><blockquote><p>Texture coordinates, colors, normal vectors, …</p></blockquote><p>实际上可以对任意属性进行插值。</p><h2 id="如何插值：Barycentric-coordinates"><a href="#如何插值：Barycentric-coordinates" class="headerlink" title="如何插值：Barycentric coordinates"></a>如何插值：Barycentric coordinates</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>首先明确的是，重心坐标是定义在三角形上的，意思是每个三角形都有一个重心坐标系，当三角形不同时，其重心坐标也不同；</li><li>三角形内的任意一点 $(x, y)$ 均可以表示成三角形顶点的线性组合；  $$<br>  (x, y) = \alpha A + \beta B + \gamma C<br>  $$</li><li>其中，称 $(\alpha, \beta, \gamma)$ 为 $(x,y)$ 的重心坐标，其中三者需要满足两个条件：<ul><li>三者相加为1：保证点 $(x,y)$ 在三角形所在的平面上；  $$<br>  \alpha + \beta + \gamma = 1<br>  $$</li><li>三者均为非负值：保证点 $(x,y)$ 在三角形内部；  $$<br>  \alpha \ge 0 \wedge  \beta \ge 0 \wedge \gamma \ge 0<br>  $$</li></ul></li></ul><h3 id="Geometric-viewpoint-—-proportional-areas"><a href="#Geometric-viewpoint-—-proportional-areas" class="headerlink" title="Geometric viewpoint — proportional areas"></a>Geometric viewpoint — proportional areas</h3><p>计算三角形内任意一点的重心坐标，可以从几何面积的角度考虑。</p><p><img src="/images/games101/09/1/area_compute.png" alt="计算任意一点重心坐标"></p><p>三角形的重心的重心坐标：</p><p><img src="/images/games101/09/1/centroid.png" alt="三角形的重心的重心坐标"></p><h3 id="一般化计算公式"><a href="#一般化计算公式" class="headerlink" title="一般化计算公式"></a>一般化计算公式</h3><p><img src="/images/games101/09/1/general_compute.png" alt="重心坐标的一般化计算公式"></p><h3 id="Using-Barycentric-Coordinates"><a href="#Using-Barycentric-Coordinates" class="headerlink" title="Using Barycentric Coordinates"></a>Using Barycentric Coordinates</h3><p>当针对三角形内任意一点计算得到对应的重心坐标后，可以利用该重心坐标对任意的属性进行插值，所谓的插值，在这里指的就是通过对三角形顶点属性的线性组合得到自身的属性。</p><p><img src="/images/games101/09/1/bc_compute.png" alt="重心坐标的应用"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>However, barycentric coordinates are not invariant under projection!</p></blockquote><p>在三角形完成投影后，三角形内任意一点的重心坐标可能发生变化。因此针对3D中的三角形进行插值时，需要利用3D坐标进行插值，而不是利用投影后的2D坐标进行插值，例如：在对3D物体的深度信息时进行插值时。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
            <tag> Texture Mapping </tag>
            
            <tag> Barycentric coordinates </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-08-2：Shading - Graphics Pipeline</title>
      <link href="/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-08-2-shading-graphics-pipeline/"/>
      <url>/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-08-2-shading-graphics-pipeline/</url>
      
        <content type="html"><![CDATA[<h1 id="Graphics-Pipeline"><a href="#Graphics-Pipeline" class="headerlink" title="Graphics Pipeline"></a>Graphics Pipeline</h1><p>从真实世界场景中的物体到最终的一张图的整个过程，其中涉及不同的操作。</p><p><img src="/images/games101/08/2/pipeline.png" alt="Graphics Pipeline"></p><ul><li>Vertex Processing：其实就是MVP变换对应的过程；</li><li>Triangle Processing：是将三维物体中的点全部完成投影后，根据存储的点之间的连接信息，形成三角形，这只是不同的处理方法而已，也可以在投影过程中直接连接。</li></ul><h1 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h1><p><img src="/images/games101/08/2/details.png" alt="Graphics Pipeline各个步骤"></p><p>所有这些过程均已经在GPU硬件上实现，其中对于具体的shading方法可以通过对硬件编程实现，这个编程是判断如何对三角形的顶点和像素进行着色，可以通过代码实现不同的着色结果，这部分代码称之为shader。</p><h1 id="Shader-Programs"><a href="#Shader-Programs" class="headerlink" title="Shader Programs"></a>Shader Programs</h1><ul><li>Program vertex and fragment processing stages</li><li>Describe operation on a single vertex (or fragment)  只需要针对一个顶点或者像素写shader即可；</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>openGL中实现漫反射shader。</p><pre class=" language-cpp"><code class="language-cpp">uniform sampler2D myTexture<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// program parameter</span>uniform vec3 lightDir<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// program parameter</span>varying vec2 uv<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// per fragment value (interp. by rasterizer)</span>varying vec3 norm<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// per fragment value (interp. by rasterizer)</span><span class="token keyword">void</span> <span class="token function">diffuseShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vec3 kd<span class="token punctuation">;</span>    kd <span class="token operator">=</span> <span class="token function">texture2d</span><span class="token punctuation">(</span>myTexture<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// material color from texture</span>    kd <span class="token operator">*</span><span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>–lightDir<span class="token punctuation">,</span> norm<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Lambertian shading model</span>    gl_FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>kd<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// output fragment color</span><span class="token punctuation">}</span></code></pre><ul><li>Shader function executes once per fragment.</li><li>Outputs color of surface at the current fragment’s screen sample position.</li><li>This shader performs a texture lookup to obtain the surface’s material color at this point, then performs a diffuse lighting calculation.</li></ul><h1 id="Graphics-Pipeline-Implementation-GPUs"><a href="#Graphics-Pipeline-Implementation-GPUs" class="headerlink" title="Graphics Pipeline Implementation: GPUs"></a>Graphics Pipeline Implementation: GPUs</h1><p>Specialized processors for executing graphics pipeline computations:</p><ul><li>Discrete GPU Card</li><li>Integrated GPU (Part of Intel CPU die)</li></ul><p><img src="/images/games101/08/2/gpu.png" alt="GPUs"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
            <tag> Graphics Pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-08-1：Shading - Shading Frequencies</title>
      <link href="/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-08-1-shading-shading-frequencies/"/>
      <url>/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-08-1-shading-shading-frequencies/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>前面的Blinn-Phong Model是针对单个shading point进行着色，下一步是针对具体的物体进行着色。</p><p>对于同样的几何物体，不同的着色频率会导致不同的结果，如下图：</p><p><img src="/images/games101/08/1/problem.png" alt="对真实物理对象着色时的问题"></p><ul><li>图1是针对一个面进行着色，即在一个面上只着色一次；</li><li>图2是针对三角形的顶点进行着色，然后三角形内部通过插值补全其他的着色区域；</li><li>图3是针对每个像素进行着色，通过计算三角形顶点的法线方向，然后对每个像素的法线方向进行插值，然后进行着色；</li></ul><p>这三种方法，效果是越来越好，但是计算量也是越来越大。</p><h1 id="Flat-shading-shade-each-triangle"><a href="#Flat-shading-shade-each-triangle" class="headerlink" title="Flat shading: shade each triangle"></a>Flat shading: shade each triangle</h1><ul><li>Triangle face is flat — one normal vector</li><li>Not good for smooth surfaces</li></ul><p><img src="/images/games101/08/1/flat.png" alt="Flat shading的效果"></p><h1 id="Gouraud-shading-shade-each-vertex"><a href="#Gouraud-shading-shade-each-vertex" class="headerlink" title="Gouraud shading: shade each vertex"></a>Gouraud shading: shade each vertex</h1><ul><li>Interpolate colors from vertices across triangle<ul><li>插值的内容在后续的课程中提供；</li></ul></li><li>Each vertex has a normal vector</li></ul><p><img src="/images/games101/08/1/gouraud.png" alt="Gouraud shading的效果"></p><h2 id="Defining-Per-Vertex-Normal-Vectors"><a href="#Defining-Per-Vertex-Normal-Vectors" class="headerlink" title="Defining Per-Vertex Normal Vectors"></a>Defining Per-Vertex Normal Vectors</h2><h3 id="From-the-underlying-geometry"><a href="#From-the-underlying-geometry" class="headerlink" title="From the underlying geometry"></a>From the underlying geometry</h3><p>Best to get vertex normals from the underlying geometry：过于理想；</p><ul><li>e.g. consider a sphere</li></ul><p><img src="/images/games101/08/1/geometry_normal.png" alt="利用平面所覆盖的图形计算法线向量"></p><h3 id="利用邻居进行平均"><a href="#利用邻居进行平均" class="headerlink" title="利用邻居进行平均"></a>利用邻居进行平均</h3><p>一般化的方法： infer vertex normals from triangle faces</p><ul><li>简单方法: average surrounding face normals；  其中 N_v是顶点的法线向量，$N_i$ 是该顶点相邻的三角形的法线向量。计算完成后，需要将得到的法线向量归一化，因为只关心方向。</li></ul><p>$$<br>N_v = \frac{\sum_{i}{}N_i}{\Vert \sum_{i}{}N_i \Vert}<br>$$</p><p><img src="/images/games101/08/1/vertex_normal.png" alt="计算Vertex的法线向量"></p><ul><li>加权平均：按照三角形面积进行法线向量的平均；</li></ul><h1 id="Phong-shading-shade-each-pixel"><a href="#Phong-shading-shade-each-pixel" class="headerlink" title="Phong shading: shade each pixel"></a>Phong shading: shade each pixel</h1><ul><li>Interpolate normal vectors across each triangle</li><li>Compute full shading model at each pixel</li><li>Not the Blinn-Phong Reflectance Model：与Phong shading均为同一个人提出的；</li></ul><p><img src="/images/games101/08/1/phong.png" alt="Phong shading的效果"></p><h2 id="Defining-Per-Pixel-Normal-Vectors"><a href="#Defining-Per-Pixel-Normal-Vectors" class="headerlink" title="Defining Per-Pixel Normal Vectors"></a>Defining Per-Pixel Normal Vectors</h2><p>根据之前得到了三角形顶点的法线向量，可以利用顶点的法线向量进一步得到每个像素的向量，这里需要利用 Barycentric interpolation of vertex normals 来完成，后续会介绍。</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>这三种方法不一定是哪种一定最好，如下图：当物体的顶点很多时，或者三角形很密集时，使用简单的Face shading效果也不错。</p><p><img src="/images/games101/08/1/compare.png" alt="三种着色频率效果的对比"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-07：Shading - Blinn-Phong Model</title>
      <link href="/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-07-shading-blinn-phong-model/"/>
      <url>/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-07-shading-blinn-phong-model/</url>
      
        <content type="html"><![CDATA[<h1 id="Shading含义"><a href="#Shading含义" class="headerlink" title="Shading含义"></a>Shading含义</h1><ul><li>Merriam-Webster Dictionary  The darkening or coloring of an illustration or diagram with parallel lines or a block of color</li><li>本课定义  The process of applying a material to an object.</li></ul><h1 id="Blinn-Phong-Reflectance-Model"><a href="#Blinn-Phong-Reflectance-Model" class="headerlink" title="Blinn-Phong Reflectance Model"></a>Blinn-Phong Reflectance Model</h1><h2 id="Perceptual-Observations"><a href="#Perceptual-Observations" class="headerlink" title="Perceptual Observations"></a>Perceptual Observations</h2><ul><li>Specular highlights 高光</li><li>Diffuse reflection: 漫反射</li><li>Ambient lighting：环境光照，未被光源照亮的地方应该是黑暗的，但是一些间接光照会使得该地方接收到部分光，在该模型中视为常量；</li></ul><p><img src="/images/games101/07/obser.png" alt="Blinn-Phong Model中的三种元素"></p><h2 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h2><h3 id="Shading-point"><a href="#Shading-point" class="headerlink" title="Shading point"></a>Shading point</h3><blockquote><p>Compute light reflected toward camera at a specific <strong>shading point</strong>.</p></blockquote><p>Inputs:</p><ul><li>Viewer direction, $v$</li><li>Surface normal, $n$</li><li>Light direction, $l$ (for each of many lights)</li><li>Surface parameters (color, shininess, …)：待着色物体的一些性质；</li></ul><p>所有的向量都是单位向量，因为只考虑方向，不考虑大小。</p><p><img src="/images/games101/07/shading_point.png" alt="Shading point"></p><h3 id="Shading-is-Local"><a href="#Shading-is-Local" class="headerlink" title="Shading is Local"></a>Shading is Local</h3><p>着色是局部，怎么理解？即着色是针对shading point来说的，不考虑其他因素，例如：遮挡、背影等，即不同的点的着色过程是彼此独立的，之间没有关系。不会因为一些物体遮挡另一些物体导致无法着色。</p><p><img src="/images/games101/07/local.png" alt="Shading不考虑阴影"></p><h1 id="Diffuse-Reflection"><a href="#Diffuse-Reflection" class="headerlink" title="Diffuse Reflection"></a>Diffuse Reflection</h1><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>Light is scattered uniformly in all directions</p><ul><li>Surface color is the same for all viewing directions</li></ul><p><img src="/images/games101/07/diffuse.png" alt="Diffuse Reflection"></p><h2 id="Lambertian-Shading"><a href="#Lambertian-Shading" class="headerlink" title="Lambertian Shading"></a><strong>Lambertian Shading</strong></h2><h3 id="Lambert’s-cosine-law"><a href="#Lambert’s-cosine-law" class="headerlink" title="Lambert’s cosine law"></a>Lambert’s cosine law</h3><p>在光的传播中，有多少光被shading point接收了？取决于shading point的法线角度和光的传输方向。</p><p><img src="/images/games101/07/lambert.png" alt="Lambert’s cosine law"></p><h3 id="光的能量传递"><a href="#光的能量传递" class="headerlink" title="光的能量传递"></a>光的能量传递</h3><blockquote><p>假设：光在真空中传递，没有能量损失，因此光的能量在不同的时间点，在不同的范围内是守恒的。</p></blockquote><p>设定距离光源长度为1的球面上，单位面积接收的光的能量为 $I$。在距离光源长度为 $r^2$ 的球面上单位面积上的光的能量是 $\frac{I}{r^2}$ 。</p><p><img src="/images/games101/07/intensity.png" alt="假设光的能量传递没有损失"></p><h3 id="漫发射的光"><a href="#漫发射的光" class="headerlink" title="漫发射的光"></a>漫发射的光</h3><p>考虑的因素：</p><ul><li>shading point距离光源的距离；</li><li>光源入射的角度：也就是光线方向与shading point法线的夹角，这里只考虑反射，不考虑折射；</li><li>shading point自身的特性：其可能吸收部分光，并不会将所有的光全部反射出去；</li><li>Shading independent of view direction：即观察者从任何方向看都会得到一致的结果；</li></ul><p><img src="/images/games101/07/diffuse_term.png" alt="Diffuse Term"></p><p>注意：</p><ul><li>该推导是一个经验公式，并不代表它在数学上是正确的（所有模型都是错的，但有一些有用）；</li><li>其中，$k_d$ 作为漫反射系数决定了亮度和颜色；  <img src="/images/games101/07/kd.png" alt="漫反射系数的影响"></li><li>$max(…)$ 决定了不考虑光从shading point底部射入的情况，即折射的情况；</li></ul><h1 id="Specular-Term"><a href="#Specular-Term" class="headerlink" title="Specular Term"></a>Specular Term</h1><h2 id="何时出现高光"><a href="#何时出现高光" class="headerlink" title="何时出现高光"></a>何时出现高光</h2><p>“高光”表示shading point所在的平面相对较光滑，因此可以近似为镜面反射。当观察方向与镜面反射的方向趋近时，可以看到高光，即：</p><ul><li>Intensity depends on view direction</li><li>Bright near mirror reflection direction</li></ul><p><img src="/images/games101/07/specular.png" alt="Specular highlights"></p><h2 id="如何对高光建模"><a href="#如何对高光建模" class="headerlink" title="如何对高光建模"></a>如何对高光建模</h2><p>想法转换：对于将<strong>观察方向与镜面反射的方向趋近，表示为入射和观察方向的半程向量与shading point的法线方向趋近。</strong>（因为之前的）</p><p><img src="/images/games101/07/specular_term.png" alt="Specular Term"></p><p>注意：</p><ul><li>衡量向量接近：使用dot product；</li><li>这里没有考虑有多少光被吸收，类似于漫反射中需要对 $l,n$ 进行dot product，做了简化；</li><li>$k_s$ 是surface的镜面反射系数，与漫反射中的 $k_d$ 含义相同；  <img src="/images/games101/07/ks_p.png" alt="镜面反射系数和p的影响"></li><li>指数 $p$ 的作用：increasing p narrows the reflection lobe 限制高光的范围，即高光只在特定的范围内出现，超过这个范围则看不到，该指数使得能够快速衰减高光的值。一般取100，200等。  <img src="/images/games101/07/p.png" alt="指数p能衰减高光"></li></ul><h1 id="Ambient-Term"><a href="#Ambient-Term" class="headerlink" title="Ambient Term"></a>Ambient Term</h1><p>Shading that does not depend on anything: </p><ul><li>Add constant color to account for disregarded<br>illumination and fill in black shadows</li><li>This is approximate / fake!</li></ul><p><img src="/images/games101/07/ambient_term.png" alt="Ambient Term"></p><p>注意，这里的环境光：</p><ul><li>与光的入射方向无关；</li><li>与观察方向也无关；</li><li>其根本作用是保证未被光照到的地方不会黑暗；</li></ul><h1 id="总结：Blinn-Phong-Reflection-Model"><a href="#总结：Blinn-Phong-Reflection-Model" class="headerlink" title="总结：Blinn-Phong Reflection Model"></a>总结：Blinn-Phong Reflection Model</h1><p>$$<br>\begin{aligned}L &amp;=L_{a}+L_{d}+L_{s} \\ &amp;=<br>k_{a} I_{a}+k_{d}\left( \frac{I}{r^{2}} \right) \max (0, \mathbf{n} \cdot \mathbf{l})+k_{s}\left(\frac{I}{r^2} \right) \max (0, \mathbf{n} \cdot \mathbf{h})^{p}\end{aligned}<br>$$</p><p><img src="/images/games101/07/summary.png" alt="Blinn-Phong Reflection Model中不同项对应的效果"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
            <tag> Blinn-Phong Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-06-2：Rasterization - Z-Buffering</title>
      <link href="/2022/04/30/ji-suan-ji-tu-xing-xue/games/games101-06-2-rasterization-z-buffering/"/>
      <url>/2022/04/30/ji-suan-ji-tu-xing-xue/games/games101-06-2-rasterization-z-buffering/</url>
      
        <content type="html"><![CDATA[<h1 id="问题：Visibility-occlusion"><a href="#问题：Visibility-occlusion" class="headerlink" title="问题：Visibility / occlusion"></a>问题：Visibility / occlusion</h1><p>很多不同的三角形彼此重叠，与相机之间也存在不同的距离，</p><h1 id="Painter’s-Algorithm"><a href="#Painter’s-Algorithm" class="headerlink" title="Painter’s Algorithm"></a>Painter’s Algorithm</h1><ul><li>Inspired by how painters paint</li><li>Paint from back to front, overwrite in the framebuffer</li></ul><h2 id="朴素想法"><a href="#朴素想法" class="headerlink" title="朴素想法"></a>朴素想法</h2><ul><li>Requires sorting in depth $(O(n \log n)$ for n triangles)</li></ul><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ul><li>Can have unresolvable depth order：有时无法得到深度排序；</li><li>因此实际中不会使用该算法；</li></ul><p><img src="/images/games101/06/2/un_do.png" alt="无法对深度进行排序"></p><h1 id="Z-Buffer"><a href="#Z-Buffer" class="headerlink" title="Z-Buffer"></a>Z-Buffer</h1><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><ul><li>Store <strong>current min. z-value for each sample</strong> (pixel)  所有操作都是针对像素来说的；</li><li>Needs an additional buffer for depth values<ul><li>frame buffer stores color values：对应最后的结果；</li><li>depth buffer (z-buffer) stores depth：对应深度缓存的图；</li></ul></li></ul><blockquote><p>备注：For simplicity we suppose $z$ is always positive (smaller $z$ -&gt; closer, larger $z$ -&gt; further)。</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="/images/games101/06/2/frame_depth_buffer.png" alt="Frame &amp; Depth Buffer"></p><p>深度值小，对应的是黑色。</p><h2 id="Z-Buffer-Algorithm"><a href="#Z-Buffer-Algorithm" class="headerlink" title="Z-Buffer Algorithm"></a>Z-Buffer Algorithm</h2><pre class=" language-cpp"><code class="language-cpp">Initialize depth buffer to <span class="token operator">+</span>infDuring rasterization<span class="token operator">:</span><span class="token keyword">for</span> <span class="token punctuation">(</span>each triangle T<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>each <span class="token function">sample</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span> in T<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">&lt;</span> zbuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// closest sample so far</span>            framebuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> rgb<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// update color</span>            zbuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> z<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// update depth</span>        <span class="token keyword">else</span>            <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// do nothing, this sample is occluded</span></code></pre><p><img src="/images/games101/06/2/zbuffer.png" alt="Z buffering"></p><h2 id="Z-Buffer-Complexity"><a href="#Z-Buffer-Complexity" class="headerlink" title="Z-Buffer Complexity"></a>Z-Buffer Complexity</h2><p>Complexity</p><ul><li>$O(n)$ for n triangles (assuming constant coverage)</li></ul><p>How is it possible to sort n triangles in linear time?</p><ul><li>这里并没有对深度信息进行排序；</li></ul><p>Drawing triangles in different orders?</p><ul><li>结果仍然相同，绘制三角形的顺序不影响最终的结果（不同三角形之间的深度值不存在重复）。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Most important visibility algorithm</li><li>Implemented in hardware for all GPUs</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光栅化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-06-1：Rasterization - Antialiasing</title>
      <link href="/2022/04/30/ji-suan-ji-tu-xing-xue/games/games101-06-1-rasterization-antialiasing/"/>
      <url>/2022/04/30/ji-suan-ji-tu-xing-xue/games/games101-06-1-rasterization-antialiasing/</url>
      
        <content type="html"><![CDATA[<h1 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h1><h2 id="常见的采样"><a href="#常见的采样" class="headerlink" title="常见的采样"></a>常见的采样</h2><ul><li>Rasterization = Sample 2D Positions</li><li>Photograph = Sample Image Sensor Plane</li><li>Video = Sample Time</li></ul><p><img src="/images/games101/06/1/sample_ex.png" alt="Sampling Examples"></p><h2 id="采样会产生问题——Aliasing"><a href="#采样会产生问题——Aliasing" class="headerlink" title="采样会产生问题——Aliasing"></a>采样会产生问题——Aliasing</h2><p>Sampling Artifacts (Errors / Mistakes / Inaccuracies) in Computer Graphics：</p><ul><li>Jaggies (Staircase Pattern)：This is also an example of “aliasing” – a sampling error；  <img src="/images/games101/06/1/jaggies.png" alt="Jaggies"></li><li>Moiré Patterns in Imaging：Skip odd rows and columns  <img src="/images/games101/06/1/mp.png" alt="Moiré Patterns"></li><li>Wagon Wheel Illusion (False Motion)：人眼对时间的采样无法跟上运动的速度。  <img src="/images/games101/06/1/wwi.png" alt="Wagon Wheel Illusion"></li></ul><p>Behind the Aliasing Artifacts: Signals are changing too fast (high frequency), but sampled too slowly.</p><h2 id="如何Antialiasing"><a href="#如何Antialiasing" class="headerlink" title="如何Antialiasing"></a>如何Antialiasing</h2><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><p>Blurring (Pre-Filtering) Before Sampling. 采样之前进行模糊（滤波）。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在Rasterization的过程中，反走样方法的效果：</p><ul><li>只采样：Note jaggies in rasterized triangle where pixel values are pure red or white;</li><li>模糊再采样：Note antialiased edges in rasterized triangle where pixel values take intermediate values;</li></ul><p><img src="/images/games101/06/1/only_sample.png" alt="只采样"></p><p><img src="/images/games101/06/1/blur.png" alt="模糊再采样"></p><h3 id="Blurred-Aliasing-先采样再模糊行吗？"><a href="#Blurred-Aliasing-先采样再模糊行吗？" class="headerlink" title="Blurred Aliasing: 先采样再模糊行吗？"></a>Blurred Aliasing: 先采样再模糊行吗？</h3><p>不可以，下图中左上是原始图形，右上和右下均为先模糊再采样，左下则为先采样再模糊，发现仍然有走样现象。</p><p><img src="/images/games101/06/1/blur_sample.png" alt="先模糊再采样"></p><p><img src="/images/games101/06/1/sample_blur.png" alt="先采样再模糊"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>Why undersampling introduces aliasing?</li><li>Why pre-filtering then sampling can do antialiasing?</li></ol><h1 id="Fourier-Transform"><a href="#Fourier-Transform" class="headerlink" title="Fourier Transform"></a>Fourier Transform</h1><h2 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h2><p><img src="/images/games101/06/1/freq.png" alt="频率定义"></p><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><blockquote><p>Represent a function as a weighted sum of sines and cosines.</p></blockquote><p>注意：这里的函数不一定是传统的周期函数，也可以是非周期函数，只是将非周期函数的周期视为无穷大而已。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>Fourier Transform Decomposes A Signal Into Frequencies.</p></blockquote><p><img src="/images/games101/06/1/ft.png" alt="Fourier Transform"></p><h2 id="解释Aliasing"><a href="#解释Aliasing" class="headerlink" title="解释Aliasing"></a>解释Aliasing</h2><h3 id="Higher-Frequencies-Need-Faster-Sampling"><a href="#Higher-Frequencies-Need-Faster-Sampling" class="headerlink" title="Higher Frequencies Need Faster Sampling"></a>Higher Frequencies Need Faster Sampling</h3><ul><li>对低频信号的采样，采样率与信号频率相差不多，也能够大致重建原始信号；</li><li>对高频信号的采样，当采样率过低时，重建原始信号时会出现错误；</li></ul><p><img src="/images/games101/06/1/sample_freq.png" alt="对不同频率信号采样和重建"></p><h3 id="Undersampling-Creates-Frequency-Aliases"><a href="#Undersampling-Creates-Frequency-Aliases" class="headerlink" title="Undersampling Creates Frequency Aliases"></a>Undersampling Creates Frequency Aliases</h3><p>使用同样的采样率对两个不同频率的函数采样，发现得到的结果相同，也就是说，利用该采样得到的结果重建信号时，无法区分原始信号是哪个。</p><p><img src="/images/games101/06/1/undersampling.png" alt="用相同采样率采样不同信号"></p><ul><li>High-frequency signal is insufficiently sampled: samples erroneously appear to be from a low-frequency signal</li><li>Two frequencies that are indistinguishable at a given sampling rate are called “aliases”</li></ul><h1 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>Filtering = Getting rid of certain frequency contents.</p></blockquote><p><img src="/images/games101/06/1/freq_cont.png" alt="傅里叶变换后的频域信息"></p><p>傅里叶变换的频域信息如何理解？</p><ul><li>中心是最低频，周围是高频内容；</li><li>频域的信息通过通过右图中的亮度表示，信息越多，则越亮；<ul><li>图中每一点的灰度值描述的是正弦或者余弦函数的振幅；</li></ul></li><li>中间有两个交叉的亮十字如何理解？<ul><li>因为将分析的信号视为周期重复性信号，但是对于不重复的信号，例如图片，则将其视为水平方向重复很多，竖直方向也重复很多；</li></ul></li></ul><p><img src="/images/games101/06/1/repeat.png" alt="二维图像重复"></p><h3 id="Filtering可得到特定频域信息"><a href="#Filtering可得到特定频域信息" class="headerlink" title="Filtering可得到特定频域信息"></a>Filtering可得到特定频域信息</h3><ul><li>High-pass filter</li><li>Low-pass filter</li><li>Filter Out Low and High Frequencies</li></ul><h2 id="Filtering-Convolution-Averaging"><a href="#Filtering-Convolution-Averaging" class="headerlink" title="Filtering = Convolution (= Averaging)"></a>Filtering = Convolution (= Averaging)</h2><h3 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h3><blockquote><p>Point-wise local averaging in a “sliding window”.</p></blockquote><p>这里的操作与数学上的定义不同，如果严格按照数学定义需要旋转卷积核。</p><p><img src="/images/games101/06/1/conv.png" alt="卷积操作"></p><h3 id="Convolution-Theorem"><a href="#Convolution-Theorem" class="headerlink" title="Convolution Theorem"></a>Convolution Theorem</h3><blockquote><p>Convolution in the spatial domain is equal to multiplication in the frequency domain, and vice versa.</p></blockquote><p>根据卷积定理，以下两种操作是等价的：</p><ul><li>Option 1<ul><li>Filter by convolution in the spatial domain</li></ul></li><li>Option 2<ul><li>Transform to frequency domain (Fourier transform)</li><li>Multiply by Fourier transform of convolution kernel</li><li>Transform back to spatial domain (inverse Fourier)</li></ul></li></ul><p><img src="/images/games101/06/1/conv_theorem.png" alt="卷积定理"></p><h3 id="Box-Filter"><a href="#Box-Filter" class="headerlink" title="Box Filter"></a>Box Filter</h3><p>$$<br>\frac{1}{9}<br>\left(<br>\begin{array}{lll}<br>1 &amp; 1 &amp; 1 \\<br>1 &amp; 1 &amp; 1 \\<br>1 &amp; 1 &amp; 1<br>\end{array}<br>\right)<br>$$</p><p>归一化操作是为了不会影响亮度的剧烈变化。</p><ul><li>Box Function = “Low Pass” Filter  左侧是时域信息，右侧是频域信息。  <img src="/images/games101/06/1/box_f.png" alt="Box Function"></li><li>Wider Filter Kernel = Lower Frequencies  <img src="/images/games101/06/1/wfk.png" alt="Wider Filter Kernel">  理解方式：当卷积核变大，说明移动的窗口覆盖的范围变大，因为有更多的区域被“平滑”了，因此高频信息都消失了。从极端的角度理解，当卷积核与图像相同时，整个图像都被“平滑”了，对应到频域信息中的区域会更小。当卷积核的大小与一个像素相同时，说明图像没有被“平滑”，因此频域信息不变。</li></ul><h1 id="回顾Sampling"><a href="#回顾Sampling" class="headerlink" title="回顾Sampling"></a>回顾Sampling</h1><h2 id="Sampling-Repeating-Frequency-Contents"><a href="#Sampling-Repeating-Frequency-Contents" class="headerlink" title="Sampling=Repeating Frequency Contents"></a>Sampling=Repeating Frequency Contents</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p><img src="/images/games101/06/1/repeat_freq.png" alt="Repeating Frequency Contents"></p><h2 id="解释Aliasing-1"><a href="#解释Aliasing-1" class="headerlink" title="解释Aliasing"></a>解释Aliasing</h2><blockquote><p>Aliasing = Mixed Frequency Contents</p></blockquote><p><img src="/images/games101/06/1/mfc.png" alt="Mixed Frequency Contents"></p><h1 id="Antialiasing"><a href="#Antialiasing" class="headerlink" title="Antialiasing"></a>Antialiasing</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>How Can We Reduce Aliasing Error?</p><ul><li>Increase sampling rate：适用不同设备，成本太高；<ul><li>Essentially increasing the distance between replicas in the Fourier domain</li><li>Higher resolution displays, sensors, framebuffers…</li><li>But: costly &amp; may need very high resolution</li></ul></li><li><strong>Antialiasing：可以应用在同一设备上，主要策略</strong>；<ul><li>Making Fourier contents “narrower” before repeating</li><li>i.e. Filtering out high frequencies before sampling</li></ul></li></ul><h2 id="idea-limiting-then-repeating"><a href="#idea-limiting-then-repeating" class="headerlink" title="idea: limiting, then repeating"></a>idea: limiting, then repeating</h2><p><img src="/images/games101/06/1/ltr.png" alt="Limiting, then repeating"></p><p>既然通过先模糊再采样的方法可以有效反走样，采样的方法已知，<strong>需要解决的是如何进行模糊的问题？</strong></p><h2 id="A-Practical-Pre-Filter"><a href="#A-Practical-Pre-Filter" class="headerlink" title="A Practical Pre-Filter"></a>A Practical Pre-Filter</h2><blockquote><p>Antialiasing By Averaging Values in Pixel Area.</p></blockquote><p>A 1 pixel-width box filter (low pass, blurring)</p><p><img src="/images/games101/06/1/pre_filter.png" alt="Practical Pre-Filter"></p><p>具体操作过程：</p><ol><li>Convolve $f(x,y)$ by a 1-pixel box-blur</li><li>Then sample at every pixel’s center</li></ol><p>In rasterizing one triangle, the average value inside a pixel area of $f(x,y) = \text{inside}(\text{triangle},x,y)$ is equal to the area of the pixel covered by the triangle.</p><p><img src="/images/games101/06/1/pre_filtering.png" alt="Pre-Filtering"></p><h2 id="如何实现1-pixel-width-box-filter"><a href="#如何实现1-pixel-width-box-filter" class="headerlink" title="如何实现1 pixel-width box filter"></a>如何实现1 pixel-width box filter</h2><blockquote><p>对反走样解决方案的近似，不能严格解决反走样的问题。</p></blockquote><h3 id="Supersampling-MSAA"><a href="#Supersampling-MSAA" class="headerlink" title="Supersampling (MSAA)"></a>Supersampling (MSAA)</h3><p>Approximate the effect of the 1-pixel box filter by sampling multiple locations within a pixel and averaging their values.</p><p>将一个像素分成若干个小像素，然后再执行具体的操作。之前的方法，只需要针对一个像素本身判断是否在三角形内，现在需要针对一个像素中划分的更小的单元判断是否在三角形内，然后对整个像素进行平均。</p><p><img src="/images/games101/06/1/msaa.png" alt="MSAA"></p><h3 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h3><p>MSAA增加了计算量，依赖将一个像素分割的方法。例如：如果是$4 \times 4$ ，则计算量增加了16倍，每个更小的像素中的点均要判断是否在三角形内。</p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p>MSAA中将一个像素进行了均匀的划分，但是在实际中更多的是采用不太规则的划分，这样一个更小的单元可以被多个像素点进行共享，使得在判断该单元在三角形内的操作并不是严格是之前的16倍（在$4 \times 4$ 的划分下），因此效率会有提升。</p><h3 id="工业界广泛使用的方法"><a href="#工业界广泛使用的方法" class="headerlink" title="工业界广泛使用的方法"></a>工业界广泛使用的方法</h3><ul><li>FXAA (Fast Approximate AA)：与采样无关的方法，在图像操作上的抗锯齿，基本思路是先模糊，然后将模糊后的图像中的锯齿去掉；</li><li>TAA (Temporal AA)：复用上一帧的结果；</li></ul><h2 id="区别概念-Super-resolution"><a href="#区别概念-Super-resolution" class="headerlink" title="区别概念 Super resolution"></a>区别概念 Super resolution</h2><ul><li>From low resolution to high resolution</li><li>Essentially still “not enough samples” problem</li><li>DLSS (Deep Learning Super Sampling): 使用深度学习来“猜测”图像放大后缺失的信息，这些缺失后的信息如果没有补全则会出现“锯齿”问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光栅化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-05：Rasterization - Triangles</title>
      <link href="/2022/04/29/ji-suan-ji-tu-xing-xue/games/games101-05-rasterization-triangles/"/>
      <url>/2022/04/29/ji-suan-ji-tu-xing-xue/games/games101-05-rasterization-triangles/</url>
      
        <content type="html"><![CDATA[<h1 id="Viewing之后"><a href="#Viewing之后" class="headerlink" title="Viewing之后"></a>Viewing之后</h1><ul><li>Model transformation (placing objects)</li><li>View transformation (placing camera)</li><li>Projection transformation<ul><li>Orthographic projection (cuboid to “canonical” cube $[-1, 1]^3$)</li><li>Perspective projection (frustum to “canonical” cube)</li></ul></li><li>Canonical cube to?</li></ul><p>继续：将之前得到的立方体绘制到屏幕上。</p><h1 id="Canonical-Cube-to-Screen"><a href="#Canonical-Cube-to-Screen" class="headerlink" title="Canonical Cube to Screen"></a>Canonical Cube to Screen</h1><h2 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h2><ul><li>What is a screen<ul><li>An array of pixels</li><li>Size of the array: resolution 表示像素的多少。</li><li>A typical kind of raster display</li></ul></li><li>Raster == screen in German<ul><li>Rasterize == drawing onto the screen</li></ul></li><li>Pixel (FYI, short for “picture element”)<ul><li>For now: A pixel is a little square with uniform color  简化表示</li><li>Color is a mixture of (red, green, blue)</li></ul></li></ul><h2 id="Screen-space"><a href="#Screen-space" class="headerlink" title="Screen space"></a>Screen space</h2><p><img src="/images/games101/05/screen_space.png" alt="Screen space"></p><p>规则：</p><ul><li>Pixels’ indices are in the form of $(x, y)$, where both x and y are integers.</li><li>Pixels’ indices are from $(0, 0)$ to (width - 1, height - 1).</li><li>Pixel $(x, y)$ is centered at $(x + 0.5, y + 0.5)$ . 坐标实际中心</li><li>The screen covers range $(0, 0)$ to (width, height).</li></ul><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p><img src="/images/games101/05/vp_trans.png" alt="Viewport transform"></p><ul><li>Irrelevant to z</li><li>Transform in xy plane: $[-1, 1]^2$ to [0, width] x [0, height]</li><li>Viewport transform matrix: 视口变换</li></ul><p>$$<br>M_{\text {viewport}}=\left(\begin{array}{cccc}\frac{w i d t h}{2} &amp; 0 &amp; 0 &amp; \frac{\text { width }}{2} \\<br>0 &amp; \frac{\text { height }}{2} &amp; 0 &amp; \frac{\text { height }}{2} \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>$$</p><p>到此为止得到了2D上的图片。</p><h1 id="Rasterizing-Triangles-into-Pixels"><a href="#Rasterizing-Triangles-into-Pixels" class="headerlink" title="Rasterizing Triangles into Pixels"></a>Rasterizing Triangles into Pixels</h1><p>接下来，将图片分解为像素，也就是光栅化的过程。</p><h2 id="Drawing-Machines"><a href="#Drawing-Machines" class="headerlink" title="Drawing Machines"></a>Drawing Machines</h2><ul><li>CNC Sharpie Drawing Machine</li><li>Laser Cutters</li></ul><h2 id="Different-Raster-Displays"><a href="#Different-Raster-Displays" class="headerlink" title="Different Raster Displays"></a>Different Raster Displays</h2><ul><li>Oscilloscope 示波器</li><li>Cathode Ray Tube 阴极射线管<ul><li>Television - Raster Display CRT</li></ul></li><li>Frame Buffer: Memory for a Raster Display</li><li>Flat Panel Displays<ul><li>LCD (Liquid Crystal Display)</li><li>LED Array Display</li></ul></li><li>Electrophoretic (Electronic Ink) Display</li></ul><h1 id="Rasterization-Drawing-to-Raster-Displays"><a href="#Rasterization-Drawing-to-Raster-Displays" class="headerlink" title="Rasterization: Drawing to Raster Displays"></a>Rasterization: Drawing to Raster Displays</h1><h2 id="Triangles-Fundamental-Shape-Primitives"><a href="#Triangles-Fundamental-Shape-Primitives" class="headerlink" title="Triangles - Fundamental Shape Primitives"></a>Triangles - Fundamental Shape Primitives</h2><h3 id="Why-triangles"><a href="#Why-triangles" class="headerlink" title="Why triangles?"></a>Why triangles?</h3><ul><li>Most basic polygon<ul><li>Break up other polygons</li></ul></li><li>Unique properties<ul><li>Guaranteed to be planar  三角形一定是平面图形</li><li>Well-defined interior 内外容易区分</li><li>Well-defined method for interpolating values at vertices over triangle (barycentric interpolation) 根据顶点的信息可以对其中其中任意一点进行插值。</li></ul></li></ul><h2 id="问题：What-Pixel-Values-Approximate-a-Triangle"><a href="#问题：What-Pixel-Values-Approximate-a-Triangle" class="headerlink" title="问题：What Pixel Values Approximate a Triangle?"></a>问题：What Pixel Values Approximate a Triangle?</h2><p><img src="/images/games101/05/pv_appro.png" alt="Pixel Values Approximate"></p><h2 id="解决方法：Sampling"><a href="#解决方法：Sampling" class="headerlink" title="解决方法：Sampling"></a>解决方法：Sampling</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li>Evaluating a function at a point is sampling.</li><li>We can discretize a function by sampling.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> xmax<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span>    output<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li>Sampling is a core idea in graphics.<ul><li>We sample time (1D), area (2D), direction (2D), volume (3D)</li></ul></li></ul><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><ul><li>Sample If Each Pixel Center Is Inside Triangle</li><li>Define Binary Function: $\text{inside}(t, x, y)$<ul><li>x, y: not necessarily integers</li></ul></li></ul><!-- $$f=\left\\{\begin{array}{l}1\\\\0\end{array}\right.$$ --><p>  $$<br>  \text{inside}(t, x, y)=<br>  \left\{<br>  \begin{array}{ll}<br>  1 &amp; \begin{array}{l} \text{Point (x, y) in triangle } t\end{array} \\<br>  0 &amp; \text {otherwise}<br>  \end{array}<br>  \right.<br>  $$</p><p>整体过程表示如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> xmax<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> ymax<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span>        image<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">inside</span><span class="token punctuation">(</span>tri<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述过程中要解决的一个问题是：如何判断点 $(x,y)$ 在三角形内。使用之前cross product中提到的方法。</p><p>最后的结果：</p><p><img src="/images/games101/05/tri_compare.png" alt="光栅化前后三角形的对比"></p><p>存在锯齿问题！</p><h3 id="Edge-Cases"><a href="#Edge-Cases" class="headerlink" title="Edge Cases"></a>Edge Cases</h3><p>Is this sample point covered by triangle 1, triangle 2, or both? 自己决定，不作要求。</p><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><ul><li>普遍策略：Checking All Pixels on the Screen?  Use a Bounding Box!</li></ul><p><img src="/images/games101/05/box.png" alt="基本优化策略 - Use a Bounding Box"></p><ul><li>进一步优化：Incremental Triangle Traversal，每一行都找边界，suitable for thin and rotated triangles，但是实践起来不太容易。  <img src="/images/games101/05/itt.png" alt="Incremental Triangle Traversal"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光栅化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-04：Viewing Transformation</title>
      <link href="/2022/04/28/ji-suan-ji-tu-xing-xue/games/games101-04-viewing-transformation/"/>
      <url>/2022/04/28/ji-suan-ji-tu-xing-xue/games/games101-04-viewing-transformation/</url>
      
        <content type="html"><![CDATA[<p>Viewing Transformation指的是将3D中的物体映射到2D中的图像的过程。</p><h1 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h1><p>Think about how to take a photo？</p><ul><li>Find a good place and arrange people (<strong>model transformation</strong>)</li><li>Find a good “angle” to put the camera (<strong>view transformation</strong>)</li><li>Cheese! (<strong>projection transformation</strong>)</li></ul><h1 id="View-Camera-Transformation"><a href="#View-Camera-Transformation" class="headerlink" title="View / Camera Transformation"></a>View / Camera Transformation</h1><h2 id="确定相机位置"><a href="#确定相机位置" class="headerlink" title="确定相机位置"></a>确定相机位置</h2><p>Define the camera first</p><ul><li>Position: $\vec{e}$</li><li>Look-at / gaze direction $\hat{g}$</li><li>Up direction (assuming perp. to look-at): $\hat{t}$</li></ul><p><img src="/images/games101/04/camera.png" alt="确定相机位置"></p><h2 id="永久固定相机位置"><a href="#永久固定相机位置" class="headerlink" title="永久固定相机位置"></a>永久固定相机位置</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>If the camera and all objects move together, the “photo” will be the same.</p><p><img src="/images/games101/04/fixed.png" alt="同时变换相机和物体"></p><h3 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h3><p>How about that we always transform the camera to</p><ul><li>The origin, up at $Y$, look at $-Z$</li><li>And transform the objects along with the camera</li></ul><p><img src="/images/games101/04/fixed_camera.png" alt="永久固定相机位置"></p><h3 id="具体变换"><a href="#具体变换" class="headerlink" title="具体变换"></a>具体变换</h3><p>Transform the camera by $M_{view}$.</p><ul><li>So it’s located at the origin, up at Y, look at -Z</li></ul><p>$M_{view}$ in math? </p><p>$$<br>\mathbf{M_{view}} = \mathbf{R_{view}} \mathbf{T_{view}}<br>$$</p><ul><li>Translates $\vec{e}$ to origin.  $$<br>  \mathbf{T}_{view} =<br>  \left(\begin{array}{lll}<br>  1 &amp; 0 &amp; 0 &amp; -x_e \\<br>  0 &amp; 1 &amp; 0 &amp; -y_e \\<br>  0 &amp; 0 &amp; 1 &amp; -z_e \\<br>  0 &amp; 0 &amp; 0 &amp; 1<br>  \end{array}\right)<br>  $$</li><li>Rotates $g$ to $-Z$, Rotates $t$ to $Y$, Rotates $(g \times t)$ To $X$.<ul><li>Consider its inverse rotation: $X$ to $(g \times t)$, $Y$ to $t$, $Z$ to $-g$</li></ul>  $$<br>  \mathbf{R_{view}}^{-1}=<br>  \left(\begin{array}{cccc}x_{\hat{g} \times \hat{t}} &amp; x_{t} &amp; x_{-g} &amp; 0 \\<br>  y_{\hat{g} \times \hat{t}} &amp; y_{t} &amp; y_{-g} &amp; 0 \\<br>  z_{\hat{g} \times \hat{t}} &amp; z_{t} &amp; z_{-g} &amp; 0 \\<br>  0 &amp; 0 &amp; 0 &amp; 1<br>  \end{array}\right)<br>  \\<br>  \mathbf{R_{view}}=<br>  \left(\begin{array}{cccc}x_{\hat{g} \times \hat{t}} &amp; y_{\hat{g} \times \hat{t}} &amp; z_{\hat{g} \times \hat{t}} &amp; 0 \\<br>  x_{t} &amp; y_{t} &amp; z_{t} &amp; 0 \\<br>  x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \\<br>  0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)<br>  $$  利用了旋转矩阵为正交矩阵的性质。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>上述整个过程也可以称为ModelView Transformation，因为相机和物体可以同时变化。</li><li>该过程为投影变换奠定基础。</li></ul><h1 id="Projection-transformation"><a href="#Projection-transformation" class="headerlink" title="Projection transformation"></a>Projection transformation</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Projection in Computer Graphics</p><ul><li>Orthographic projection：相机无限远，平行线仍平行</li><li>Perspective projection：相机有限远，近大远小，平行线会相交，更符合现实；</li></ul><p><img src="/images/games101/04/project1.png" alt="两种类型的投影变换1"></p><p><img src="/images/games101/04/project2.png" alt="两种类型的投影变换2"></p><p><a href="https://stackoverflow.com/questions/36573283/from-perspective-picture-to-orthographic-picture">From perspective picture to orthographic picture</a></p><h2 id="Orthographic-Projection"><a href="#Orthographic-Projection" class="headerlink" title="Orthographic Projection"></a>Orthographic Projection</h2><h3 id="例子理解"><a href="#例子理解" class="headerlink" title="例子理解"></a>例子理解</h3><ul><li>Camera located at origin, looking at $-Z$, up at $Y$ .</li><li>Drop $Z$ coordinate. 将$z$坐标去掉。</li><li>Translate and scale the resulting rectangle to $[-1, 1]^2$.</li></ul><p><img src="/images/games101/04/project_example.png" alt="投影例子理解"></p><p>问题：如何区分前后，在去掉$z$坐标后？</p><h3 id="真实操作"><a href="#真实操作" class="headerlink" title="真实操作"></a>真实操作</h3><p>We want to map a cuboid $[l, r]\times [b, t]\times [f, n]$ to the “canonical (正则、规范、标准)” cube $[-1, 1]^3$.</p><ul><li>Center cuboid by translating.</li><li>Scale into “canonical” cube.</li></ul><p>Translate (center to origin) first, then scale (length/width/height to 2).</p><p>$$<br>M_{\text {ortho }}=<br>\left(\begin{array}{cccc}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>\left(\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\<br>0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\<br>0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2} \\<br>0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)<br>$$</p><p><img src="/images/games101/04/orth.png" alt="正交投影具体操作"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>Looking at / along $-Z$ is making near and far not intuitive ($n &gt; f$)<ul><li>That’s why OpenGL (a Graphics API) uses left hand coords.</li></ul></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>不考虑旋转？</li><li>变换到立方体中会造成拉伸？之后会有视口变换解决这个问题。</li></ul><h2 id="Perspective-Projection"><a href="#Perspective-Projection" class="headerlink" title="Perspective Projection"></a>Perspective Projection</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>Most common in Computer Graphics, art, visual system</li><li>Further objects are smaller</li><li>Parallel lines not parallel; converge to single point</li></ul><p><img src="/images/games101/04/pers_overview.png" alt="透视投影"></p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul><li>$(x, y, z, 1)$, $(kx, ky, kz, k \ne 0)$, $(xz, yz, z^2, z \ne 0)$ all represent<br>the same point $(x, y, z)$ in 3D</li><li>e.g. $(1, 0, 0, 1)$ and $(2, 0, 0, 2)$ both represent $(1, 0, 0)$</li></ul><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul><li>First “squish” the <strong>frustum</strong> into a <strong>cuboid</strong>: $n \rightarrow n, f \rightarrow f$, ($M_{persp \rightarrow ortho}$).</li><li>Do orthographic projection:  $M_{ortho}$ already known</li></ul><p>在“挤压“的过程中，有几个原则需要遵守：</p><ul><li>近平面 $n$ 上点的坐标不变；</li><li>远平面 $f$ 上的z坐标不变；</li><li>远平面 $f$ 上的中心点仍然是中心点；</li></ul><p><img src="/images/games101/04/pers_idea.png" alt="透视投影方法"></p><h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><p>Find the relationship between transformed points $(x^{\prime}, y^{\prime}, z^{\prime})$ and the original points $(x, y, z)$.</p><p><img src="/images/games101/04/pers_operation.png" alt="透视投影过程"></p><p>在图中，Z/Y交点为相机位置，即原点。$n$为近平面的z坐标，$z$为远平面对应z轴的坐标。</p><p>对应则有经过变换后，</p><p>$$<br>y^{\prime} = \frac{n}{z}y<br>$$</p><p>$$<br>x^{\prime} = \frac{n}{z}x<br>$$</p><p>对应到齐次坐标下：</p><p>$$<br>\left(\begin{array}{l}x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)<br>\Rightarrow<br>\left(\begin{array}{c} nx/z \\<br>ny/z \\<br>\text{unknown} \\<br>1<br>\end{array}\right)<br>\overset{\times z}{==}<br>\left(<br>\begin{array}{c} nx \\<br>ny \\<br>\text{ still unknown } \\<br>z<br>\end{array}<br>\right)<br>$$</p><p>到此为止可以得到部分变换矩阵中的值：</p><p>$$<br>M_{persp \rightarrow ortho}^{4 \times 4}<br>\left(\begin{array}{l}x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)<br>=<br>\left(<br>\begin{array}{c} nx \\<br>ny \\<br>\text{ still unknown } \\<br>z<br>\end{array}<br>\right)<br>$$</p><p>$$<br>M_{persp \rightarrow ortho}^{4 \times 4}<br>=<br>\mathbf{T}_{view} =<br>\left(\begin{array}{lll}<br>n &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; n &amp; 0 &amp; 0 \\<br>? &amp; ? &amp; ? &amp; ? \\<br>0 &amp; 0 &amp; 1 &amp; 0<br>\end{array}\right)<br>$$</p><p>How to figure out the third row of $M_{persp \rightarrow ortho}$? The third row is responsible for $z^{\prime}$: </p><ul><li>Any point on the near plane will not change.</li></ul><p>$$<br>\mathbf{M_{persp \rightarrow ortho}}^{4 \times 4}<br>\left(<br>\begin{array}{l} x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)<br>=<br>\left(<br>\begin{array}{c} nx \\<br>ny \\<br>\text{unknown} \\<br>z<br>\end{array}<br>\right)<br>\overset{\text{replace z with n}}{\longrightarrow}<br>\left(\begin{array}{l}x \\<br>y \\<br>n \\<br>1<br>\end{array}\right)<br>\Rightarrow<br>\left(\begin{array}{l}x \\<br>y \\<br>n \\<br>1<br>\end{array}\right)==<br>\left(\begin{array}{l} nx \\<br>ny \\<br>n^{2} \\<br>n<br>\end{array}\right)<br>$$</p><p>所以得到：the third row must be of the form $(0 \ 0 \ A \ B)$, $n^2$ has nothing to do with $x$ and $y$.</p><p>$$<br> \left(\begin{array}{lll}0 &amp; 0 &amp; A\end{array}\right.  B)\left(\begin{array}{l}x \ y \ n \ 1\end{array}\right)=n^{2} <br>$$</p><p>$$<br>An + B = n^2<br>$$</p><ul><li>Any point’s z on the far plane will not change：这里取远平面的中心点。</li></ul><p>$$<br>\left(\begin{array}{l}0 \\<br>0 \\<br>f \\<br>1<br>\end{array}\right)<br>\Rightarrow<br>\left(\begin{array}{l}0 \\<br>0 \\<br>f \\<br>1<br>\end{array}\right)<br>==<br>\left(\begin{array}{c}0 \\<br>0 \\<br>f^{2} \\<br>f\end{array}\right)<br>$$</p><p>$$<br>Af + B = f^2<br>$$</p><p>综合上述两者，</p><p>$$<br>\begin{array}{ll}<br>An+B=n^{2} \\<br>Af+B=f^{2}<br>\end{array}<br>\Rightarrow<br>\begin{array}{ll}<br>A=n+f \\<br>B=-nf<br>\end{array}<br>$$</p><p>之后做orthographic projection即可：</p><p>$$<br>M_{persp} = M_{ortho} M_{persp \rightarrow ortho}<br>$$</p><h3 id="透视投影中Frustum的另一种表示"><a href="#透视投影中Frustum的另一种表示" class="headerlink" title="透视投影中Frustum的另一种表示"></a>透视投影中Frustum的另一种表示</h3><p>当得到<strong>近平面的坐标信息</strong>后，有时人们用另外一种方式表示Frustum视锥。</p><p>People prefer: vertical field-of-view (fovY) and aspect ratio (assume symmetry $l = -r, b = -t$).</p><p>该表示方法可以与cuboid中的 $l,r,b,t,n,f$ 相转化。</p><p><img src="/images/games101/04/fov_aspect.png" alt="用FoV和Aspect表示Frustum"></p><p>注意：上述平面只是frustum的近平面。</p><p><img src="/images/games101/04/fov_aspect_compute.png" alt="FoV和Aspect与之前表示的转换"></p><h1 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h1><p>对于任意一个frustum内部的点，经过透视投影映射到cuboid， 其 $z$ 坐标相对于之前有什么变化？</p><p>$$<br>\mathbf{M}_{persp \rightarrow ortho} =<br>\left(\begin{array}{lll}<br>n &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; n &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; n+f &amp; -nf \\<br>0 &amp; 0 &amp; 1 &amp; 0<br>\end{array}\right)<br>$$</p><p>对于任意一点经过该变换可得：</p><p>$$<br>\mathbf{M}_{persp \rightarrow ortho}<br>\left(<br>\begin{array}{l}x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)<br>=<br>\left(<br>\begin{array}{c} nx \\<br>ny \\<br>(n+f)z - nf \\<br>z<br>\end{array}<br>\right)<br>\Rightarrow<br>\left(<br>\begin{array}{c} nx/z \\<br>ny/z \\<br>(n+f) - nf/z \\<br>1<br>\end{array}<br>\right)<br>$$</p><p>为了判断 $z$ 坐标的变化，定义函数 $f(z)$:</p><p>$$<br>\begin{aligned}<br>f(z) &amp;= \frac{(n+f)z - nf}{z} - z \\<br> &amp; \overset{\times z}{=} -z^2 + (n+f)z -nf \\<br>&amp;= (z-n)(f-z)<br>\end{aligned}<br>$$</p><p>由于：$f \le z \le n$，因此$f(z) \ge 0$，因此得到在乘以 $z$ 坐标之前的 $f(z) \le 0$，因为看向的是-z方向，因此 $z$ 坐标均为负数。由此得到，当完成“挤压”后，frustum内部的点均向远平面方向移动，即离相机更远了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视图变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-03-02：3D Transformation</title>
      <link href="/2022/04/28/ji-suan-ji-tu-xing-xue/games/games101-03-02-3d-transformation/"/>
      <url>/2022/04/28/ji-suan-ji-tu-xing-xue/games/games101-03-02-3d-transformation/</url>
      
        <content type="html"><![CDATA[<h1 id="Homogeneous-coordinates"><a href="#Homogeneous-coordinates" class="headerlink" title="Homogeneous coordinates"></a>Homogeneous coordinates</h1><ul><li>3D point = $(x, y, z, 1)^T$</li><li>3D vector = $(x, y, z, 0)^T$</li></ul><p>对应的，坐标 $(x,y,z,w)(w \ne 0)$ 表示三维空间中的点$(x/w, y/w, z/w)$。</p><h1 id="Affine-Transform仿射变换"><a href="#Affine-Transform仿射变换" class="headerlink" title="Affine Transform仿射变换"></a>Affine Transform仿射变换</h1><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime} \\<br>z^{\prime} \\<br>1<br>\end{array}\right)=<br>\left(\begin{array}{lll}<br>a &amp; b &amp; c &amp; t_x \\<br>d &amp; e &amp; f &amp; t_y \\<br>g &amp; h &amp; i &amp; t_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right) \cdot<br>\left(\begin{array}{l}<br>x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)<br>$$</p><p>What’s the order? Linear Transform first or Translation first.</p><p>在操作变换时，首先进行线性变换，之后才进行平移变换。</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)<br>=<br>\left(\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right)<br>\left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right)<br>+<br>\left(\begin{array}{l}<br>t_x \\<br>t_y<br>\end{array}\right)<br>$$</p><h1 id="3D-transformations统一表示"><a href="#3D-transformations统一表示" class="headerlink" title="3D transformations统一表示"></a>3D transformations统一表示</h1><h2 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h2><p>$$<br>\mathbf{S}(s_x, s_y, s_z) =<br>\left(\begin{array}{ll}<br>s_x &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; s_y &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; s_z &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>$$</p><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>$$<br>\mathbf{T}(t_x, t_y) =<br>\left(\begin{array}{lll}<br>1 &amp; 0 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; 0 &amp; t_y \\<br>0 &amp; 0 &amp; 1 &amp; t_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>$$</p><h2 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h2><p>Rotation around x-, y-, or z-axis.</p><p>$$<br>\begin{array}{l}<br>\mathbf{R_x}(\alpha)=<br>\left(\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; \cos \alpha &amp; -\sin \alpha &amp; 0 \\<br>0 &amp; \sin \alpha &amp; \cos \alpha &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>\\<br>\mathbf{R_y}(\alpha)=<br>\left(\begin{array}{cccc}\cos \alpha &amp; 0 &amp; \sin \alpha &amp; 0 \\<br>0 &amp; 1 &amp; 0 &amp; 0 \\<br>-\sin \alpha &amp; 0 &amp; \cos \alpha &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)<br>\\<br>\mathbf{R_z}(\alpha)=\left(\begin{array}{cccc}\cos \alpha &amp; -\sin \alpha &amp; 0 &amp; 0 \\<br>\sin \alpha &amp; \cos \alpha &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>\end{array}<br>$$</p><p>其中$\mathbf{R}_{y}(\alpha)$会有一些奇怪，因为根据右手螺旋定则，$z$ 与 $x$ 叉乘得到 $y$，$x$ 与 $z$ 叉乘得到 $-y$，这是其在$\sin \alpha$上符号与其他两个相反的原因。（使用左手螺旋也会存在特殊的轴）</p><h2 id="3D-Rotations"><a href="#3D-Rotations" class="headerlink" title="3D Rotations"></a>3D Rotations</h2><p>Compose any 3D rotation from $R_x, R_y, R_z$?</p><p>$$<br>\mathbf{R_{xyz}}(\alpha, \beta, \gamma) = \mathbf{R_x}(\alpha)\mathbf{R_y}(\beta)\mathbf{R_z}(\gamma)<br>$$</p><p>其中，三个角度$\alpha, \beta, \gamma$ 称为Euler angles。</p><p>一个典型的应用场景：Often used in flight simulators: roll, pitch, yaw。</p><p><img src="/images/games101/03/2/3d-rot.png" alt="3D Rotations"></p><h2 id="Rodrigues’-Rotation-Formula"><a href="#Rodrigues’-Rotation-Formula" class="headerlink" title="Rodrigues’ Rotation Formula"></a>Rodrigues’ Rotation Formula</h2><p>Rotation by angle $\alpha$ around axis $\mathbf{n}$.</p><p>$$<br>\mathbf{R}(\mathbf{n}, \alpha)=<br>\cos (\alpha) \mathbf{I}+(1-\cos (\alpha)) \mathbf{n} \mathbf{n}^{T}+\sin (\alpha) \underbrace{\left(\begin{array}{ccc}0 &amp; -n_{z} &amp; n_{y} \\<br>n_{z} &amp; 0 &amp; -n_{x} \\<br>-n_{y} &amp; n_{x} &amp; 0<br>\end{array}\right)}_{\mathbf{N}}<br>$$</p><ul><li>其中axis默认是过原点的；</li><li>当轴不过原点可以利用之前的方法：将所有的东西移动到原点，再旋转，然后再移回去；</li><li>其中$\mathbf{N}$是向量的叉乘，只是表示成矩阵形式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-03-01：2D Transformation</title>
      <link href="/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-03-01-2d-transformation/"/>
      <url>/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-03-01-2d-transformation/</url>
      
        <content type="html"><![CDATA[<h1 id="Linear-Transforms-Matrices"><a href="#Linear-Transforms-Matrices" class="headerlink" title="Linear Transforms = Matrices"></a>Linear Transforms = Matrices</h1><h2 id="Scale-Transform"><a href="#Scale-Transform" class="headerlink" title="Scale Transform"></a>Scale Transform</h2><p>变换操作为：</p><p>$$<br>\text{scale}(s_x, s_y) = \left(\begin{array}{ll}s_x &amp; 0 \\ 0 &amp; s_y \end{array}\right)<br>$$</p><p>在点$(x, y)$经过变换后变为$(x^{\prime}, y^{\prime})$，如下：</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>s_x &amp; 0 \\<br>0 &amp; s_y<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>s_xx \\<br>s_yy<br>\end{array}\right)<br>$$</p><h2 id="Reflection-Transform"><a href="#Reflection-Transform" class="headerlink" title="Reflection Transform"></a>Reflection Transform</h2><p>在水平方向上，其实是沿y轴翻转。</p><p>$$<br>x^{\prime} = -x \\<br>y^{\prime} = y<br>$$</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>-1 &amp; 0 \\<br>0 &amp; 1<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>-x \\<br>y<br>\end{array}\right)<br>$$</p><p>在竖直方向上，其实是沿x轴翻转。</p><p>$$<br>x^{\prime} = x \\<br>y^{\prime} = -y<br>$$</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>1 &amp; 0 \\<br>0 &amp; -1<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>x \\<br>-y<br>\end{array}\right)<br>$$</p><h2 id="Shear-Transform"><a href="#Shear-Transform" class="headerlink" title="Shear Transform"></a>Shear Transform</h2><p><img src="/images/games101/03/shear.png" alt="Shear Transform"></p><p>在水平方向上，纵坐标不变化。</p><p>$$<br>x^{\prime} = x + ay \\<br>y^{\prime} = y<br>$$</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>1 &amp; a \\<br>0 &amp; 1<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>x + ay \\<br>y<br>\end{array}\right)<br>$$</p><p>在竖直方向上，横坐标不变化。</p><p>$$<br>x^{\prime} = x \\<br>y^{\prime} = y + ax<br>$$</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=<br>\left(\begin{array}{ll}<br>1 &amp; 0 \\<br>a &amp; 1<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>x \\<br>y + ax<br>\end{array}\right)<br>$$</p><h2 id="Rotate-Transform"><a href="#Rotate-Transform" class="headerlink" title="Rotate Transform"></a>Rotate Transform</h2><h3 id="默认规则"><a href="#默认规则" class="headerlink" title="默认规则"></a>默认规则</h3><ul><li>about the origin (0, 0)：围绕原点旋转；</li><li>CCW by default：默认是逆时针旋转；</li></ul><p><img src="/images/games101/03/rotate.png" alt="Rotate Transform"></p><p>取图中两个特殊点计算旋转矩阵，得到：</p><p>$$<br>\mathbf{R}_{\theta} = \left(\begin{array}{ll}<br>\cos\theta &amp; -\sin\theta \\<br>\sin\theta &amp; \cos\theta<br>\end{array}\right)<br>$$</p><h3 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h3><p>$$<br>\mathbf{R_{-\theta}} =<br>\left(\begin{array}{cc}<br>\cos \theta &amp; \sin \theta \\<br>-\sin \theta &amp; \cos \theta<br>\end{array}\right) = \mathbf{R_{\theta}^{\top}}<br>$$</p><p>根据定义：</p><p>$$<br>\mathbf{R_{-\theta}}=\mathbf{R_{\theta}^{-1}}<br>$$</p><p>因此得到：</p><p>$$<br>\mathbf{R_{\theta}^{\top}}=\mathbf{R_{\theta}^{-1}}<br>$$</p><p>这一性质表明旋转矩阵是正交矩阵。</p><h2 id="Linear-Transform总结"><a href="#Linear-Transform总结" class="headerlink" title="Linear Transform总结"></a>Linear Transform总结</h2><p>其中对应矩阵的维度与点的维度保持一致。</p><p>$$<br>x^{\prime} = ax + by \\<br>y^{\prime} = cx + dy<br>$$</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>ax + by \\<br>cx + dy<br>\end{array}\right)<br>$$</p><p>$$<br>x^{\prime} = Mx<br>$$</p><h1 id="Homogeneous-coordinates"><a href="#Homogeneous-coordinates" class="headerlink" title="Homogeneous coordinates"></a>Homogeneous coordinates</h1><h2 id="为啥要用齐次坐标？"><a href="#为啥要用齐次坐标？" class="headerlink" title="为啥要用齐次坐标？"></a>为啥要用齐次坐标？</h2><p>要解决平移变换的问题，将之与之前的变换统一表示，因为不能将平移变换写成矩阵乘法的形式。</p><h2 id="Translation-Transform"><a href="#Translation-Transform" class="headerlink" title="Translation Transform"></a>Translation Transform</h2><p><img src="/images/games101/03/translation.png" alt="Translation Transform"></p><p>$$<br>x^{\prime} = x + t_x \\<br>y^{\prime} = y + t_y<br>$$</p><p>Translation cannot be represented in matrix form. 不是线性变换。</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=<br>\left(\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right)<br>\left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right)<br>+<br>\left(\begin{array}{l}<br>t_x \\<br>t_y<br>\end{array}\right)<br>$$</p><p>由于不想将该变换特殊处理，为了统一表示，因此需要齐次坐标。</p><h2 id="Solution-Homogenous-Coordinates"><a href="#Solution-Homogenous-Coordinates" class="headerlink" title="Solution: Homogenous Coordinates"></a>Solution: Homogenous Coordinates</h2><p>Add a third coordinate (w-coordinate)</p><ul><li>2D point = $(x, y, 1)^T$</li><li>2D vector = $(x, y, 0)^T$</li></ul><blockquote><p>为啥点和向量在增加的坐标上的表示分别为1和0，而不是相同呢？因为向量具有平移不变性，而点经过平移则会发生变化。</p></blockquote><p>Valid operation if w-coordinate of result is 1 or 0：</p><ul><li>vector + vector = vector</li><li>point – point = vector</li><li>point + vector = point</li><li>point + point = ??</li></ul><p>In homogeneous coordinates,</p><p>$$<br>\left(\begin{array}{l}<br>x \\<br>y \\<br>w<br>\end{array}\right)<br>$$<br>is the 2D point<br>$$<br>\left(\begin{array}{l}<br>x/w \\<br>y/w \\<br>1<br>\end{array}\right)<br>$$</p><p>$$w \ne 0. $$</p><p>在该扩充定义下，齐次坐标中，两点之间的加和结果是两个点的中点，还是一个点。</p><blockquote><p>齐次坐标的代价：引入了多余的数字，理论上会增加存储，但是实际中可以不管。</p></blockquote><h2 id="Translation在齐次坐标下的表示"><a href="#Translation在齐次坐标下的表示" class="headerlink" title="Translation在齐次坐标下的表示"></a>Translation在齐次坐标下的表示</h2><p>使用该方法表示Translation得到：</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime} \\<br>w^{\prime}<br>\end{array}\right)=<br>\left(\begin{array}{lll}<br>1 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y \\<br>1<br>\end{array}\right)<br>= \left(\begin{array}{l}<br>x + t_x \\<br>y + t_y \\<br>1<br>\end{array}\right)<br>$$</p><p>从而实现转化为矩阵乘法的形式。</p><h2 id="Affine-Transform仿射变换"><a href="#Affine-Transform仿射变换" class="headerlink" title="Affine Transform仿射变换"></a>Affine Transform仿射变换</h2><p>Affine map = linear map + translation</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)<br>=<br>\left(\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right)<br>\left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right)<br>+<br>\left(\begin{array}{l}<br>t_x \\<br>t_y<br>\end{array}\right)<br>$$</p><p>在齐次坐标下表示如下：</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime} \\<br>1<br>\end{array}\right)<br>=<br>\left(\begin{array}{lll}<br>a &amp; b &amp; t_x \\<br>c &amp; d &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right) \cdot<br>\left(\begin{array}{l}<br>x \\<br>y \\<br>1<br>\end{array}\right)<br>$$</p><h2 id="齐次坐标下统一表示"><a href="#齐次坐标下统一表示" class="headerlink" title="齐次坐标下统一表示"></a>齐次坐标下统一表示</h2><h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><p>$$<br>\mathbf{S}(s_x, s_y) =<br>\left(\begin{array}{ll}<br>s_x &amp; 0 &amp; 0 \\<br>0 &amp; s_y &amp; 0 \\<br>0&amp;0&amp; 1<br>\end{array}\right)<br>$$</p><h3 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h3><p>$$<br>\mathbf{R}(\theta) = \left(\begin{array}{ll}<br>\cos\theta &amp; -\sin\theta &amp; 0 \\<br>\sin\theta &amp; \cos\theta &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right)<br>$$</p><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>$$<br>\mathbf{T}(t_x, t_y) =<br>\left(\begin{array}{lll}<br>1 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right)<br>$$</p><h1 id="Inverse-Transform"><a href="#Inverse-Transform" class="headerlink" title="Inverse Transform"></a>Inverse Transform</h1><p>逆变换 $M$ 在数学上等价于乘上逆矩阵。$M^{-1}$ is the inverse of transform in both a matrix and geometric sense。</p><p><img src="/images/games101/03/inverse.png" alt="Inverse Transform"></p><h1 id="Composite-Transform"><a href="#Composite-Transform" class="headerlink" title="Composite Transform"></a>Composite Transform</h1><h2 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h2><p>在组合不同的变换时，注意：Transform Ordering Matters。</p><p><img src="/images/games101/03/compose_ex.png" alt="Composite Example"></p><p>如何理解？</p><p>Matrix multiplication is not commutative.</p><p>$$<br>R_{45} \cdot T_{(1,0)} \ne T_{(1,0)} \cdot  R_{45}<br>$$</p><p>Note that matrices are applied right to left:</p><p>$$<br>T_{(1,0)} \cdot R_{45}<br>\left(\begin{array}{l}x \\ y<br>\\<br>1<br>\end{array}<br>\right)<br>=<br>\left(\begin{array}{lll}1 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{array}<br>\right)<br>\left(<br>\begin{array}{ccc}\cos 45^{\circ} &amp; -\sin 45^{\circ} &amp; 0<br>\\<br>\sin 45^{\circ} &amp; \cos 45^{\circ} &amp; 0 \\<br>0 &amp; 0 &amp; 1\end{array}<br>\right)<br>\left(\begin{array}{l}x \\ y \\ 1<br>\end{array}\right)<br>$$</p><p>对于矩阵乘法来说，当考虑到变换时，是<strong>从右到左</strong>依次起作用的。</p><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>Sequence of affine transforms $A_1, A_2, A_3,$ </p><p>Compose by matrix multiplication将所有的变换结合起来形成一个变换矩阵然后再统一与原始点相乘。</p><p><img src="/images/games101/03/compose.png" alt="Compose Transform"></p><p>这一技巧对于性能计算很重要，Very important for performance。</p><h1 id="Decomposing-Complex-Transforms"><a href="#Decomposing-Complex-Transforms" class="headerlink" title="Decomposing Complex Transforms"></a>Decomposing Complex Transforms</h1><h2 id="例子：沿着特定点旋转"><a href="#例子：沿着特定点旋转" class="headerlink" title="例子：沿着特定点旋转"></a>例子：沿着特定点旋转</h2><p>How to rotate around a given point c?</p><ol><li>Translate center to origin</li><li>Rotate</li><li>Translate back</li></ol><p><img src="/images/games101/03/decompose.png" alt="Decompose Transforms"></p><p>矩阵形式如下：（从右到左依次写）</p><p>$$<br>\mathbf{T}(c) \cdot \mathbf{R}(\alpha) \cdot \mathbf{T}(-c)<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-02：Review of Linear Algebra</title>
      <link href="/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-02-review-of-linear-algebra/"/>
      <url>/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-02-review-of-linear-algebra/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学的预备知识"><a href="#计算机图形学的预备知识" class="headerlink" title="计算机图形学的预备知识"></a>计算机图形学的预备知识</h1><p>本节主要是复习了计算机图形学中可能用到的线性代数知识，其实CG中也会用到其他一些知识，包括但不限于：</p><h2 id="Basic-mathematics"><a href="#Basic-mathematics" class="headerlink" title="Basic mathematics"></a>Basic mathematics</h2><ul><li>Linear algebra</li><li>Calculus</li><li>Statistics</li></ul><h2 id="Basic-physics"><a href="#Basic-physics" class="headerlink" title="Basic physics"></a>Basic physics</h2><ul><li>Optics</li><li>Mechanics</li></ul><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><ul><li>Signal processing</li><li>Numerical analysis</li></ul><h2 id="And-a-bit-of-aesthetics"><a href="#And-a-bit-of-aesthetics" class="headerlink" title="And a bit of aesthetics"></a>And a bit of aesthetics</h2><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Usually written as $\vec{a}$ or in bold $\textbf{a}$</li><li>Or using start and end points</li><li>Direction and length</li><li>No absolute starting position</li></ul><h2 id="Vector-Normalization"><a href="#Vector-Normalization" class="headerlink" title="Vector Normalization"></a>Vector Normalization</h2><ul><li>Magnitude (length) of a vector written as $|\vec{a}|$</li><li>Unit vector<ul><li>A vector with magnitude of 1</li><li>Finding the unit vector of a vector (normalization): $\hat{a}=\vec{a} /|\vec{a}|$</li><li>Used to represent directions</li></ul></li></ul><h2 id="Vector-Addition"><a href="#Vector-Addition" class="headerlink" title="Vector Addition"></a>Vector Addition</h2><ul><li>Geometrically: Parallelogram law &amp; Triangle law</li><li>Algebraically: Simply add coordinates</li></ul><h2 id="Cartesian-Coordinates"><a href="#Cartesian-Coordinates" class="headerlink" title="Cartesian Coordinates"></a>Cartesian Coordinates</h2><ul><li>X and Y can be any (usually orthogonal unit) vectors  $$<br>  \mathbf{A}=\left(\begin{array}{l}x \\ y \end{array}\right) \quad \mathbf{A}^{T}=(x, y) \quad|\mathbf{A}|=\sqrt{x^{2}+y^{2}}<br>  $$  默认向量是列向量。  <img src="/images/games101/02/cc.png" alt="Cartesian Coordinates"></li></ul><h2 id="Vector-Multiplication"><a href="#Vector-Multiplication" class="headerlink" title="Vector Multiplication"></a>Vector Multiplication</h2><h3 id="Dot-scalar-Product"><a href="#Dot-scalar-Product" class="headerlink" title="Dot (scalar) Product"></a>Dot (scalar) Product</h3><p><img src="/images/games101/02/dp.png" alt="Dot Product"></p><ul><li>定义  $$<br>  \vec{a} \cdot \vec{b}=|\vec{a}||\vec{b}| \cos \theta<br>  $$  $$<br>  \cos \theta=\frac{\vec{a} \cdot \vec{b}}{|\vec{a}||\vec{b}|}<br>  $$</li><li>运算法则：  $$<br>  \begin{array}{l} \vec{a} \cdot \vec{b} = \vec{b} \cdot \vec{a} \\<br>  \vec{a} \cdot(\vec{b}+\vec{c})=\vec{a} \cdot \vec{b}+\vec{a} \cdot \vec{c} \\  (k \vec{a}) \cdot \vec{b}=\vec{a} \cdot(k \vec{b})=k(\vec{a} \cdot \vec{b})\end{array}<br>  $$</li><li>Dot Product in Cartesian Coordinates  Component-wise multiplication, then adding up<ul><li>In 2D  $$<br>  \vec{a} \cdot \vec{b}=\left(\begin{array}{l}x_{a} \\ y_{a}\end{array}\right) \cdot\left(\begin{array}{l}x_{b} \\ y_{b}\end{array}\right)=x_{a} x_{b}+y_{a} y_{b}<br>  $$</li><li>In 3D  $$<br>  \vec{a} \cdot \vec{b}=\left(\begin{array}{c}x_{a} \\ y_{a} \\ z_{a}\end{array}\right) \cdot\left(\begin{array}{c}x_{b} \\ y_{b} \\ z_{b}\end{array}\right)=x_{a} x_{b}+y_{a} y_{b}+z_{a} z_{b}<br>  $$</li></ul></li></ul><h3 id="Dot-Product-in-Graphics"><a href="#Dot-Product-in-Graphics" class="headerlink" title="Dot Product in Graphics"></a>Dot Product in Graphics</h3><ul><li>Find angle between two vectors, (e.g. cosine of angle between light source and surface)</li><li>Finding projection of one vector on another  <img src="/images/games101/02/project.png" alt="投影">  $\vec{b}_{\perp}$:  projection of  $\vec{b}$  onto  $\vec{a}$<ul><li>$\vec{b}_{\perp}$ must be along $\vec{a}$ (or along $\hat{a}$ )</li><li>$\vec{b}_{\perp}=k \hat{a}$</li><li>What’s its magnitude $k$?</li><li>$k=|\vec{b}_{\perp}|=|\vec{b}| \cos \theta$</li></ul></li><li>投影可以用来：<ul><li>Measure how close two directions are</li><li>Decompose a vector</li><li>Determine forward / backward：明确两个向量的方向性，同向、反向、垂直；  <img src="/images/games101/02/fb.png" alt="判断forward/backward"></li></ul></li></ul><h3 id="Cross-vector-Product"><a href="#Cross-vector-Product" class="headerlink" title="Cross (vector) Product"></a>Cross (vector) Product</h3><p><img src="/images/games101/02/cp.png" alt="Cross Product"></p><ul><li>Cross product is orthogonal to two initial vectors：结果为向量，不是数字；</li><li>Direction determined by right-hand rule</li><li>Useful in constructing coordinate systems：构建的称为右手坐标系；</li></ul><p>$$<br>\begin{array}{l}\vec{x} \times \vec{y}=+\vec{z} \\<br>\vec{y} \times \vec{x}=-\vec{z} \\<br>\vec{y} \times \vec{z}=+\vec{x} \\<br>\vec{z} \times \vec{y}=-\vec{x} \\<br>\vec{z} \times \vec{x}=+\vec{y} \\<br>\vec{x} \times \vec{z}=-\vec{y}\end{array}<br>$$</p><ul><li>运算性质  $$<br>  \begin{array}{c}\vec{a} \times \vec{b}=-\vec{b} \times \vec{a} \\<br>  \vec{a} \times \vec{a}=\overrightarrow{0} \\<br>  \vec{a} \times(\vec{b}+\vec{c})=\vec{a} \times \vec{b}+\vec{a} \times \vec{c} \\<br>  \vec{a} \times(k \vec{b})=k(\vec{a} \times \vec{b})\end{array}<br>  $$</li><li>Cross Product: Cartesian Formula  $$<br>  \vec{a} \times \vec{b}=\left(\begin{array}{l}y_{a} z_{b}-y_{b} z_{a} \\<br>  z_{a} x_{b}-x_{a} z_{b} \\<br>  x_{a} y_{b}-y_{a} x_{b}\end{array}\right)<br>  $$</li></ul><h3 id="Cross-Product-in-Graphics"><a href="#Cross-Product-in-Graphics" class="headerlink" title="Cross Product in Graphics"></a>Cross Product in Graphics</h3><ul><li>Determine left / right：$\vec{a} \times \vec{b} &gt; 0$，说明 $\vec{b}$ 在 $\vec{a}$ 的左边；反之在右边；  <img src="/images/games101/02/lr.png" alt="判断左/右"></li><li>Determine inside / outside：当$p$点，与三角形各个顶点的连线，$\overrightarrow{AP}$、$\overrightarrow{BP}$、$\overrightarrow{CP}$分别与$\overrightarrow{AB}$、$\overrightarrow{BC}$、$\overrightarrow{CA}$计算Cross Product，如果p点均在三个向量的左侧或者右侧，则该点在三角形内部，若落在边界上可自由处理。  <img src="/images/games101/02/io.png" alt="判断内/外"></li></ul><h3 id="Orthonormal-bases-and-coordinate-frames"><a href="#Orthonormal-bases-and-coordinate-frames" class="headerlink" title="Orthonormal bases and coordinate frames"></a>Orthonormal bases and coordinate frames</h3><ul><li>Important for representing points, positions, locations</li><li>Often, many sets of coordinate systems<ul><li>Global, local, world, model, parts of model (head, hands, …)</li></ul></li><li>Critical issue is transforming between these systems/bases</li></ul><p>有助于将向量进行分解，例如对于右手坐标系：</p><p>Any set of 3 vectors (in 3D) that</p><p>$$<br>\begin{array}{l}|\vec{u}|=|\vec{v}|=|\vec{w}|=1 \\<br>\vec{u} \cdot \vec{v}=\vec{v} \cdot \vec{w}=\vec{u} \cdot \vec{w}=0 \\<br>\vec{w}=\vec{u} \times \vec{v} \quad \text { (right-handed) } \\<br>\vec{p}=(\vec{p} \cdot \vec{u}) \vec{u}+(\vec{p} \cdot \vec{v}) \vec{v}+(\vec{p} \cdot \vec{w}) \vec{w} \\<br>\text { (projection) }\end{array}<br>$$</p><h1 id="Matrices"><a href="#Matrices" class="headerlink" title="Matrices"></a>Matrices</h1><ul><li>In Graphics, pervasively used to represent transformations</li><li>Array of numbers (m × n = m rows, n columns)  $$<br>  \left(\begin{array}{ll}1 &amp; 3 \\ 5 &amp; 2 \\ 0 &amp; 4 \end{array}\right)<br>  $$</li><li>Addition and multiplication by a scalar are trivial: element by element</li></ul><h2 id="Matrix-Matrix-Multiplication"><a href="#Matrix-Matrix-Multiplication" class="headerlink" title="Matrix-Matrix Multiplication"></a>Matrix-Matrix Multiplication</h2><ul><li>(number of) columns in A must = # rows in B</li><li>(M x N) (N x P) = (M x P)  $$<br>  \left(\begin{array}{ll}1 &amp; 3 \\ 5 &amp; 2 \\ 0 &amp; 4\end{array}\right)\left(\begin{array}{llll}3 &amp; 6 &amp; 9 &amp; 4 \\ 2 &amp; 7 &amp; 8 &amp; 3\end{array}\right)<br>  $$</li><li>Element (i, j) in the product is the dot product of row i from A and column j from B</li><li>运算规则<ul><li>Non-commutative: (AB and BA are different in general)</li><li>Associative and distributive<ul><li>(AB)C=A(BC)</li><li>A(B+C) = AB + AC</li><li>(A+B)C = AC + BC</li></ul></li></ul></li></ul><h2 id="Matrix-Vector-Multiplication"><a href="#Matrix-Vector-Multiplication" class="headerlink" title="Matrix-Vector Multiplication"></a>Matrix-Vector Multiplication</h2><p>Treat vector as a column matrix (m×1)</p><p>$$<br>\left(\begin{array}{cc}-1 &amp; 0 \\ 0 &amp; 1\end{array}\right)\left(\begin{array}{l}x \\ y \end{array}\right)=\left(\begin{array}{c}-x \\ y \end{array}\right)<br>$$</p><h2 id="Transpose-of-a-Matrix"><a href="#Transpose-of-a-Matrix" class="headerlink" title="Transpose of a Matrix"></a>Transpose of a Matrix</h2><p>Switch rows and columns (ij -&gt; ji)</p><p>$$<br>\left(\begin{array}{ll}1 &amp; 2 \\ 3 &amp; 4 \\ 5 &amp; 6\end{array}\right)^{T}=\left(\begin{array}{lll}1 &amp; 3 &amp; 5 \\ 2 &amp; 4 &amp; 6\end{array}\right)<br>$$</p><p>运算性质：</p><p>$$<br>(A B)^{T}=B^{T} A^{T}<br>$$</p><h2 id="Identity-Matrix-and-Inverses"><a href="#Identity-Matrix-and-Inverses" class="headerlink" title="Identity Matrix and Inverses"></a>Identity Matrix and Inverses</h2><p>$$<br>I_{3 \times 3}=\left(\begin{array}{ccc}1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{array}\right)<br>$$</p><p>$$<br>\begin{array}{l}A A^{-1}=A^{-1} A=I \\ (A B)^{-1}=B^{-1} A^{-1}\end{array}<br>$$</p><h2 id="Vector-multiplication-in-Matrix-form"><a href="#Vector-multiplication-in-Matrix-form" class="headerlink" title="Vector multiplication in Matrix form"></a>Vector multiplication in Matrix form</h2><h3 id="Dot-product"><a href="#Dot-product" class="headerlink" title="Dot product"></a>Dot product</h3><p>$$<br>\begin{aligned}\vec{a} \cdot \vec{b} \\ =&amp;\vec{a}^{T} \vec{b} \\ =&amp;\left(\begin{array}{lll}x_{a} &amp; y_{a} &amp; z_{a}\end{array}\right)\left(\begin{array}{c}x_{b} \\ y_{b} \\ z_{b}\end{array}\right)=\left(x_{a} x_{b}+y_{a} y_{b}+z_{a} z_{b}\right)\end{aligned}<br>$$</p><h3 id="Cross-product"><a href="#Cross-product" class="headerlink" title="Cross product"></a>Cross product</h3><p>$$<br>\vec{a} \times \vec{b}=A^{*} b=\left(\begin{array}{ccc}0 &amp; -z_{a} &amp; y_{a} \\ z_{a} &amp; 0 &amp; -x_{a} \\ -y_{a} &amp; x_{a} &amp; 0\end{array}\right)\left(\begin{array}{l}x_{b} \\ y_{b} \\ z_{b}\end{array}\right)<br>$$</p><p>A: dual matrix of vector a</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-01：Overview of Computer Graphics</title>
      <link href="/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-01-overview-of-computer-graphics/"/>
      <url>/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-01-overview-of-computer-graphics/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Computer-Graphics"><a href="#What-is-Computer-Graphics" class="headerlink" title="What is Computer Graphics"></a>What is Computer Graphics</h2><blockquote><p>The use of computers to <strong>synthesize</strong> and <strong>manipulate</strong> visual information.</p></blockquote><p>计算机图形学不等于openGL，openGL只是实现计算机图形学操作的API。</p><h2 id="与Computer-Vision的区别"><a href="#与Computer-Vision的区别" class="headerlink" title="与Computer Vision的区别"></a>与Computer Vision的区别</h2><p>一切涉及需要<strong>猜测</strong>的研究都属于计算机视觉的范畴，需要分析和理解。</p><p><img src="/images/games101/01/diff.png" alt="计算机图形学与计算机视觉的区别"></p><p>参考资料：</p><ul><li><a href="https://www.tutorialspoint.com/dip/computer_vision_and_graphics.htm">Computer Vision and Computer Graphics</a></li><li><a href="https://www.quora.com/What-is-the-difference-between-the-fields-of-Computer-Graphics-and-Computer-Vision">What is the difference between the fields of Computer Graphics and Computer Vision?</a></li></ul><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><h3 id="Video-Games"><a href="#Video-Games" class="headerlink" title="Video Games"></a>Video Games</h3><ul><li>从技术角度来说，什么是好画面？<ul><li>画面是否足够亮——全局光照；</li></ul></li></ul><h3 id="Movies"><a href="#Movies" class="headerlink" title="Movies"></a>Movies</h3><ul><li>特效：special effects</li><li>特效是最简单的图形学应用，因为少见，或者缺乏直接的体验；</li><li>最难的是模拟真实的东西；</li></ul><h3 id="Animations"><a href="#Animations" class="headerlink" title="Animations"></a>Animations</h3><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><ul><li>CAD: Computer-aided Design，宜家家居设计；</li></ul><h3 id="Visualization"><a href="#Visualization" class="headerlink" title="Visualization"></a>Visualization</h3><h3 id="Virtual-Reality"><a href="#Virtual-Reality" class="headerlink" title="Virtual Reality"></a>Virtual Reality</h3><p>经常与增强现实 Augmented Reality共同出现。</p><ul><li>两者的区别<ul><li>VR：看不到现实；</li><li>AR：看到现实东西，但是还有一些新东西加入；</li></ul></li></ul><h3 id="Digital-illustration"><a href="#Digital-illustration" class="headerlink" title="Digital illustration"></a>Digital illustration</h3><h3 id="Simulation"><a href="#Simulation" class="headerlink" title="Simulation"></a>Simulation</h3><h3 id="Graphical-User-Interfaces"><a href="#Graphical-User-Interfaces" class="headerlink" title="Graphical User Interfaces"></a>Graphical User Interfaces</h3><h3 id="Typography"><a href="#Typography" class="headerlink" title="Typography"></a>Typography</h3><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><h3 id="Fundamental-intellectual-challenges"><a href="#Fundamental-intellectual-challenges" class="headerlink" title="Fundamental intellectual challenges"></a>Fundamental intellectual challenges</h3><ol><li>Creates and interacts with realistic virtual world;</li><li>Requires understanding of all aspects of physical world;</li><li>New computing methods, displays, technologies;</li></ol><h3 id="Technical-challenges"><a href="#Technical-challenges" class="headerlink" title="Technical challenges"></a>Technical challenges</h3><ol><li>Math of (perspective) projections, curves, surfaces;</li><li>Physics of lighting and shading;</li><li>Representing / operating shapes in 3D;</li><li>Animation / simulation;</li><li>3D graphics software programming and hardware;</li></ol><h2 id="主要研究内容"><a href="#主要研究内容" class="headerlink" title="主要研究内容"></a>主要研究内容</h2><h3 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h3><ul><li>Project geometry primitives (3D triangles / polygons) onto the screen;</li><li>Break projected primitives into fragments (pixels);</li><li>Gold standard in Video Games (Real-time Applications)  将3D形体显示在屏幕上，是所有游戏，即<strong>实时（每秒 30帧图片，30fps，否则叫离线）计算机图形学</strong>的主要应用。</li></ul><h3 id="Curves-and-Meshes"><a href="#Curves-and-Meshes" class="headerlink" title="Curves and Meshes"></a>Curves and Meshes</h3><p>How to represent geometry in Computer Graphics.</p><h3 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h3><ul><li>Shoot rays from the camera though each pixel<ul><li>Calculate intersection and shading;</li><li>Continue to bounce the rays till they hit light sources;</li></ul></li><li>Gold standard in Animations / Movies (Offline Applications)</li></ul><h3 id="Animation-Simulation"><a href="#Animation-Simulation" class="headerlink" title="Animation / Simulation"></a>Animation / Simulation</h3><ul><li>Key frame Animation</li><li>Mass-spring System</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 光栅化 </tag>
            
            <tag> 光线追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何入门计算机图形学：一份checklist</title>
      <link href="/2022/04/24/ji-suan-ji-tu-xing-xue/ru-he-ru-men-ji-suan-ji-tu-xing-xue-yi-fen-checklist/"/>
      <url>/2022/04/24/ji-suan-ji-tu-xing-xue/ru-he-ru-men-ji-suan-ji-tu-xing-xue-yi-fen-checklist/</url>
      
        <content type="html"><![CDATA[<h1 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h1><h2 id="不要"><a href="#不要" class="headerlink" title="不要"></a>不要</h2><ul><li>不要关注图形API：OpenGL、DirectX、Vulkan等只是API，而原理相同；</li><li>不要关注GPU还是CPU：它们只是效率不同；</li><li>不要关注游戏编程类：比如UE引擎等，这些只是上层的应用；</li><li>不要关注没有代码的论文：CG偏应用，单纯入门没必要；</li></ul><h2 id="要"><a href="#要" class="headerlink" title="要"></a>要</h2><ul><li>上课以建立理论脉络：CG一般包含Rendering/Geometry/Simulation</li><li>多写代码：CG偏应用，代码蕴含细节；</li><li>要边理论边实践编程；</li></ul><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>从头造轮子：便于了解细节；</li><li>拆解小项目：明白工业级项目，学习其他人的经验；</li></ul><h1 id="技能要求"><a href="#技能要求" class="headerlink" title="技能要求"></a>技能要求</h1><h2 id="编程技能"><a href="#编程技能" class="headerlink" title="编程技能"></a>编程技能</h2><ul><li>C/C++：参考C++ Primer这本书，没有plus；</li></ul><h2 id="理论技能"><a href="#理论技能" class="headerlink" title="理论技能"></a>理论技能</h2><ul><li>微积分</li><li>线性代数<ul><li><a href="https://math.mit.edu/~gs/linearalgebra/">Introduction to Linear Algebra, 5th Edition</a></li><li><a href="http://immersivemath.com/ila/index.html">Immersive Math</a></li></ul></li></ul><h1 id="领域内容"><a href="#领域内容" class="headerlink" title="领域内容"></a>领域内容</h1><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>主要是建立对CG的整体认识，不要求多么深入，要求结构清晰，方便快速入门。</p><ul><li>书籍<ul><li>Fundamentals of Computer Graphics, Fourth Edition</li></ul></li><li>课程<ul><li><a href="http://games-cn.org/intro-graphics/">GAMES101:现代计算机图形学入门</a></li></ul></li></ul><h2 id="实时渲染"><a href="#实时渲染" class="headerlink" title="实时渲染"></a>实时渲染</h2><ul><li>书籍：Real-Time Rendering, Fourth Edition</li><li>课程<ul><li><a href="http://games-cn.org/games202/">Games202:高质量实时渲染 - 计算机图形学与混合现实研讨会</a></li></ul></li></ul><h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><ul><li><a href="https://www.bilibili.com/video/BV1B54y1B7Uc">数字几何处理-中国科学技术大学-傅孝明_哔哩哔哩_bilibili</a></li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul><li><a href="https://www.bilibili.com/video/BV1ZK411H7Hc?from=search&seid=5195290021208890151">GAMES201：高级物理引擎实战指南2020_哔哩哔哩_bilibili</a></li></ul><h1 id="拆解项目"><a href="#拆解项目" class="headerlink" title="拆解项目"></a>拆解项目</h1><p>这些项目可用于拆解练习。</p><ul><li><a href="https://github.com/ssloy/tinyrenderer">软件光栅化渲染器——tinyrenderer</a></li><li><a href="https://github.com/skywind3000/mini3d">软件光栅化渲染器——mini3d</a></li><li><a href="https://github.com/topics/box2d-lite">物理引擎——box2d-lite</a></li><li><a href="https://github.com/mitsuba-renderer/mitsuba2">渲染系统——mitsuba2渲染器</a></li></ul><h1 id="其他技术资源"><a href="#其他技术资源" class="headerlink" title="其他技术资源"></a>其他技术资源</h1><h2 id="光栅技术"><a href="#光栅技术" class="headerlink" title="光栅技术"></a>光栅技术</h2><p>Peter Shirley（Fundamentals of Computer Graphics作者）的一系列关于光线追踪的文章<a href="https://raytracing.github.io/">Ray Tracing in One Weekend Series</a>。</p><ul><li><strong>Ray Tracing in One Weekend</strong></li><li><strong>Ray Tracing: The Next Week</strong></li><li><strong>Ray Tracing: The Rest of Your Life</strong></li></ul><h2 id="参考百科全书——PBR"><a href="#参考百科全书——PBR" class="headerlink" title="参考百科全书——PBR"></a>参考百科全书——PBR</h2><p><a href="https://www.pbrt.org/">Physically Based Rendering: From Theory to Implementation</a></p><p>该参考书还配有开源的<a href="https://github.com/mmp/pbrt-v3">工业级渲染器</a>以供使用和学习。</p><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><ol><li>学习GAMES-101，并学习C++实践+做作业；</li><li>利用Fundamentals of Computer Graphic作为补充内容；</li><li>在对应章节中，通过拆解项目和资源来深度理解知识；<ol><li>光追技术；</li><li>光栅化渲染；</li></ol></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/41468803">零基础如何学习计算机图形学？</a></p><p><a href="https://www.scratchapixel.com/">Scratchapixel</a></p><p><a href="https://www.zhihu.com/column/game-programming">浅墨的游戏编程</a></p><p><a href="https://developer.nvidia.com/gpugems/gpugems/contributors">Contributors</a></p><p><a href="https://learnopengl.com/Introduction">Introduction</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年开年返校被隔离了</title>
      <link href="/2022/02/09/si-kao-nei-sheng/2022-nian-kai-nian-fan-xiao-bei-ge-chi-liao/"/>
      <url>/2022/02/09/si-kao-nei-sheng/2022-nian-kai-nian-fan-xiao-bei-ge-chi-liao/</url>
      
        <content type="html"><![CDATA[<p>昨天返校了，本来有一个论文意见需要回复一下，今天一上午在回复论文的意见，准备今天完成意见回复后，就继续自己的毕业论文撰写，但是，天有不测风云，生活总是会跟你开一个玩笑。总是怕你太无聊，给你加入一些调味品，让你的生活充满丰富的色彩。</p><h1 id="诧异"><a href="#诧异" class="headerlink" title="诧异"></a>诧异</h1><p>中午收到一个短信，说我的杭州健康码变成了黄色，当时我一度有点懵，觉得是不是出现错误了，但是又是确实的信息，</p><p><img src="/images/%E9%9A%94%E7%A6%BB/message.png" alt="收到短信。。。"></p><p>虽然看到这个信息，但是仍然觉得不相信，此时想到的后果是：</p><ul><li>完了，可能要隔离；</li><li>信息要求报告，因此想能不能不报告，但是好像不行，会带来风险；</li></ul><p>总之，此时，就是上述两种心理的博弈，但是理性占据了上风，必须地报告，不然后果可能很大，不出事则已，一出事就是大事。</p><h1 id="懊悔"><a href="#懊悔" class="headerlink" title="懊悔"></a>懊悔</h1><p>想到上述的结果，第一时间就跟学校的负责人联系了，但是没有得到立即的反馈，可能他们也需要确定一下信息，于是我就等着。</p><p>但是，怎么想自己也不会是黄码，虽然从北京丰台区回来，但是不是中高风险的街道，想来也不会有问题，因此我还申诉了一下，结果还成功了，下午的时候，绿码回来了，但是行程码仍然有北京的痕迹，我后来想了一下，可能是因为在北京等车的时间超过了4个小时，有了痕迹，所以才被打上了黄码标签，真是充满了偶然性。</p><p>本来，我以为健康码变成了绿码，应该不会隔离了吧，但是下午得到的回复是去隔离，而且是14天，我天。。。，突然有一种自己没法按时毕业了的感觉，学院的老师的催促可能，在我看来就是让我延期毕业，那种对抗的心理很强烈，但是我忍住了，想用一个拖字诀。慢慢地，我觉得这样可能不对，因为无法解决问题，而且是躲避问题。要么立即隔离，要么承担后果，可能是无法活动，甚至学院可能有相应的惩罚措施等等，不管躲多久，迟早要面对这两个结果。</p><p>但是，我仍然不明白的是，国家已经公布了中低风险区，已经具体到街道，我觉得国家做的很好了，为什么地方仍要以严格管控为理由，扩大中高险地区范围呢？</p><p>同时也有一种懊悔的心情，如果自己不马上告诉老师，自己的健康码情况，等到健康码变绿，可能就不用报告和隔离了。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>今天面对的问题是个决策问题，其实是要找出一个最优的决策。</p><p>决策的目标是什么？通俗的说，早回来是为了抓紧时间赶论文毕业，这是我的目标。</p><p>本来一切顺利的话，就按照预定计划执行即可，但是突然有了意外情况——健康码变黄了，这个时候如何调整计划以适应预定的目标，有两个解决方案：</p><ul><li>瞒报<ul><li>最优的结果是谁都不知道，按照预定计划执行；</li><li>最坏的结果是，自己出现问题，被发现，然后被追溯信息，按原计划毕业时不可能了，甚至还会有额外的麻烦，甚至会影响为了的职业发展和规划。</li></ul></li><li>主动报告<ul><li>马上报告<ul><li>最坏的结果是集中隔离14天，在隔离场所写论文；</li><li>最好的结果，不用隔离，按照原计划执行；</li></ul></li><li>延迟报告<ul><li>最坏的结果，集中隔离14天，在隔离场所写论文；</li><li>最好的结果，不用隔离，按照原计划执行；</li></ul></li></ul></li></ul><p>从上述的分析中，发现瞒报肯定是不行的，最坏的结果是我无法承受的（在没有足够信息支撑的情况下做出这种决策）。</p><p>在主动报告中，马上和延迟报告的最好结果和最坏结果都是一样的，既然如此，但是延迟报告中，其发现最好结果的权重肯定要比马上报告大一些，因此这种情况下，目前信息的支撑下，延迟报告可能要好一些，因为得到的结果都是相同的。</p><p>总结来看，<strong>从决策角度来看，延迟报告更好一些，因为事态是在不断变化的，但是这种变化，并没有改变结果，只是改变了结果的分布。</strong></p><p>因此，应了那句话，</p><ul><li><strong>好事晚说不如早说</strong></li><li><strong>坏事早说不如晚说</strong></li></ul><h1 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h1><p>面对这种情况，可能有各种“如果”：</p><ul><li>如果，我当初没有从北京南回来。。。</li><li>如果，我当初没有停留超过4个小时。。。</li><li>如果，学校不是一刀切。。。</li><li>如果，我延迟报告。。。</li></ul><p><strong>没有那么多如果，事情已经发生了，原地懊悔3秒钟，就要想怎么应对的问题了，过去的事情永远无法改变。</strong></p><p><strong>你无法预测未来，就像你也无法预测股市一样，只能去应对。</strong>面对这种情况，可能需要：</p><ul><li>提前准备工作所需材料，做好准备；</li><li>合理安排自己的工作时间；</li><li>提前进行心理按摩，要在隔离点待14天；</li><li>保持身体健康，毕竟只在一个屋行动；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 思考内省 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年度总结：黎明前夜</title>
      <link href="/2022/02/01/si-kao-nei-sheng/2021-nian-du-zong-jie-li-ming-qian-ye/"/>
      <url>/2022/02/01/si-kao-nei-sheng/2021-nian-du-zong-jie-li-ming-qian-ye/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这些文字写在2021-2022年的除夕夜，2021年转眼间过去了。这一年感觉过得好快，疫情仍然影响着整个中国，甚至整个世界。所以，我将2021年的总结概括为：黎明前夜，不仅是对于我们生活的这个世界，也包括我们自己面对的情况，黎明前夜是怎样的状况？</p><ul><li>本质还是“夜”；</li><li>但是存在希望；</li><li>对于到达黎明的过程不会太长，但是这个过程中是最冷的；</li></ul><p>或许以后回看这些当时写下的文字时，也会体会到现在的心情吧。</p><h1 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h1><p>今年读了不少的闲书，不管是为了消遣时间还是提升认知，或者只是休息一下。虽然读了之后，发现好多东西都忘了，但是相比于没读，还是有意义的，不过今年学到了一个词“严肃学习”，其实用在读书上还是挺有用的，有些书可以在床上躺着读，有些只能在电脑边，边读边做笔记。这一点是我今年在读书时体会到的，还有一些听书的方式，我尝试了一下，发现并不适合我。</p><p>今年读的书好像有点杂，包括：</p><ul><li><p>《大空头》</p><p>  2020年投资市场的行情，实在是过于恐慌了，疫情的影响被极度放大了。之前看了《大空头》的电影，总有点觉得不过瘾，书确实能留出思考的时间，这本书对于08年那场风暴解释的很清楚，回头看，确是一个好的机会，如果子弹够的话。其中有很多专业术语，为了“专业”而专业，被包装成复杂的东西，显得“高大上”，其实全都是唬人的东西。回望今年，疫情引起的恐慌还在蔓延，但是仍然有一些机会，甚至有一些泡沫。</p></li><li><p>《我在美军航母上的8年》</p><p>  一个华裔士兵的美军服役记录，我觉得很真实，与其每天“厉害了，我的国”，不如老实了解一下，其他人都在干什么，整本书看完后，抛去华裔在海外的那些熟悉的经历，更多的是对于美军的专业性的认识。要像了解自己一样了解竞争者，不要走两个极端。</p></li><li><p>《周期》</p><p>  霍华德·马克斯对于周期的研究，投资中低买高卖是基本原则，但是实践起来是很困难的，如何识别当前位置的高低是一门艰深的学问，这本书尝试从不同角度回答这一问题，人类走极端的行为永远不会停止，而这些极端行为导致的结果总会回归正常，因此需要警惕“这次不一样的论调”，但是历史不会简单重复，但却遵从着类似的模式。这本书值得二刷。</p></li><li><p>《剧变：人类社会与国家危机的转折点》</p><p>  《枪炮、细菌与钢铁》同一作者——贾雷德·戴蒙德， 我挺喜欢这本书的，从国家历史的角度，分析个人的危机和国家危机的相似性，以及相应的处理策略，危机中永远蕴含着机会，像丘吉尔说的“永远不要浪费每一次危机”。总感觉作者和其他的人不太一样，看不出来他偏重哪个角度阐述，有融合了心理学、历史学、政治学还有自然科学等，不像枯燥的社科教材。</p></li><li><p>《创新者：一群技术狂人和鬼才程序员如何改变世界》</p><p>  这是写《乔布斯传》的作者写的，我觉得可以作为一个计算机专业学生的入门书籍，是极力推荐的，其中好多内容可以和大学学到的东西对应起来，当初学到的东西，全都是孤立的东西，现在这本书将所有内容都连起来了，从这一点上来看也是值得一读的。其中书中，没有如小标题所说那样，一定是技术推动，但无疑它扮演了主要的角色，还包括：家世、认知、文化、制度等。其中还充满着勾心斗角、官僚文化等等，总之，创新不是简单地完全由技术推动。</p></li><li><p>还有一本没有读完的《东京贫困女子》</p><p>  这本书看起来实在是太难受了，职场歧视、家庭破裂、性别歧视、性骚扰等等，困扰着女性们，但是这归根结底可能是多重因素导致的，一个发达国家中的高学历女性竟然沦落风尘，而且还不少，咋看咋觉得这个社会出现问题了，并不能全部如中国史家那样，只有有问题就归罪于女人。整本书，就不断将社会的黑暗面展现给你看，将负面情绪推到极点。后续，这本书会继续读下去。</p></li></ul><h1 id="财务规划"><a href="#财务规划" class="headerlink" title="财务规划"></a>财务规划</h1><p>今年也对自己的整个投资计划做了一个总结，因为也有帮老妈管理的部分。因为各种情况吧，今年的情况还算可以，但也是充满了魔幻，不管怎样这是第一次总结自己的投资成败，结果图表所示：</p><table><thead><tr><th>投资计划</th><th>收益率</th></tr></thead><tbody><tr><td>我的计划</td><td>14.87%</td></tr><tr><td>老妈的计划</td><td>5.75%</td></tr><tr><td>沪深300</td><td>-5.20%</td></tr><tr><td>中证500</td><td>15.58%</td></tr><tr><td>恒生指数</td><td>-14.08%</td></tr><tr><td>偏股混合基金</td><td>7.68%</td></tr></tbody></table><p>总的来说，结果还不错，其中第一次帮老妈管钱，之前也跟她明确了投资风格以稳健为主，因此投资了大量的债券和货币，所以基本没有回撤。虽然老妈说放心我，不在意投资啥，但是考虑到年纪和心理，还是以稳健为主，回家和老妈复盘了一下今年的成绩，得到认可，2022年可能需要加入一个增强的因素，来稍微提升一点收益率。</p><p>对于我自己，今年也在逐步建立自己的投资体系，目前已经有一个设计了，正在逐步实现，希望能够不断完善这个体系。而今年的成绩，有一些运气在里边，年初银行保险不太行，买了一些，所以收益还不错。在实践的过程中，逐步认识到投资是门技术+艺术的领域，很难完全从技术角度去理解，或者完全主观去看待，需要不断从实践中认识。</p><h1 id="自省和体会"><a href="#自省和体会" class="headerlink" title="自省和体会"></a>自省和体会</h1><p>今年的心情低落到极点，那种无力感，可能无法形容，我想极力挑出这种极端负面的情绪下，但是屡遭失败，这是自我调节的能力出现了问题，我想这种能力相比于技术能力、解决问题的问题更重要，因为学校里有些人，就是无法承受这种无力感，而选择了极端的行为，这是要避免的，现在我还不清楚如何锻炼这种能力，但是我意识到了这方面的缺乏，后续可能需要看一些书，或者相关材料学习，但是可能最好的还是自己从中体会并实践。</p><p>自我否定和怀疑，这几年来深深地陷入了自我否定的怪圈，觉得自己一文不值，什么都不会，什么都不行。后来反思，这与所在的环境密不可分，但是也有自己的原因，期望过高，并且没有对要做的事情进行量化，导致无法明确任务的结果，也就无法产生正反馈。但是今年通过参加了一些活动，觉得自己不是那么不堪，不管是从自己表现的结果来看，或者是他人的间接的评价来看。一个重要的原因，可能是做事的方法出现了问题，虽然做事有规划，但是没有明确的可量化的目标，或者阶段性的可以总结的成果，这是需要以后改正的。</p><p>今年的一个体会是，人们倾向于将一些表现突出的人神化为圣人，私以为这种倾向是有问题的，不管是专业领域还是日常生活，对于个人来说，这会让人迷信权威，没有独立思考的能力，对于被神化的人也没有好处，当人们把你捧得愈高，你会越焦虑，因为不敢丝毫出错误，只要有问题，你的所有之前的努力全都会被忽视，所有人都会背叛你，不管是娱乐明星还是专业人士。对于整个社会也存在隐患，人们不敢质疑，专业人士出一点问题就一棒子打死，那些当初最追捧你的，之后也是拆你墙最快的人。总之，对于我们自身来说，不要神化任何人，之前看到一个访问，一个诺贝尔经济学奖得主的投资成果，一塌糊涂，按理说没人比他更懂经济，但是结果就在那里。</p><h1 id="2022年目标"><a href="#2022年目标" class="headerlink" title="2022年目标"></a>2022年目标</h1><ul><li>很朴素和直接的一件事情——顺利毕业，拿到学位，这是今年的主要目标。</li><li>今年回家突然发现一件事情，老妈真的年纪大了，之前有意识到，但是没有几年这么明显，今年毕业回家后，要带老妈去至少两个地方游玩，并拍一些照片。</li><li>学习计算机图形学：完成闫令琪博士的<a href="http://games-cn.org/intro-graphics/">GAMES101:现代计算机图形学入门</a>课程和作业。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 思考内省 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RotatE - 建模复杂关系的利器</title>
      <link href="/2021/11/20/shu-ju-ke-xue/rotate-jian-mo-fu-za-guan-xi-de-li-qi/"/>
      <url>/2021/11/20/shu-ju-ke-xue/rotate-jian-mo-fu-za-guan-xi-de-li-qi/</url>
      
        <content type="html"><![CDATA[<p>文章来源: <a href="https://arxiv.org/abs/1902.10197v1">RotatE: Knowledge Graph Embedding by Relational Rotation in Complex Space</a></p><h1 id="之前研究中的问题"><a href="#之前研究中的问题" class="headerlink" title="之前研究中的问题"></a>之前研究中的问题</h1><p>不能对三种关系同时进行建模和推理。</p><blockquote><p>None of existing models is capable of modeling and inferring all the above patterns: symmetry/antisymmetry, inversion, and composition。</p></blockquote><h3 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h3><ul><li>symmetry：婚姻，双向关系；</li><li>antisymmetry：孝顺，单向关系；</li><li>inversion：上位词和下位词，正向和反向关系；</li><li>composition：我母亲的丈夫是我父亲，关系组合计算；</li></ul><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><blockquote><p>Motivation is from Euler’s identity: a unitary complex number can be regarded as a rotation in the complex plane.</p></blockquote><p>$$<br>e^{i\theta} = \text{cos}\theta + i\text{sin}\theta<br>$$</p><p>即，任何一个复数都可以看作复平面上的一个旋转向量。</p><p><strong>RotatE model maps the entities and relations to the complex vector space and deﬁnes each relation as a rotation from the source entity to the target entity.</strong></p><p>形式化表达：</p><p>Given a triplet $(h, r, t)$ , we expect that $t = h \circ r$ , where $h, r, t \in \mathbb{C}^k $ are the embeddings, the modulus $| r_i | = 1$ and $\circ$ denotes the <code>Hadamard (element-wise) product</code>. Speciﬁcally, for each dimension in the complex space, we expect that:</p><p>$$<br>t_i = h_i r_i , \text{where} \ h_i , r_i , t_i \in \mathbb{C}^k \text{and} \ | r_i | = 1.<br>$$</p><p>说明：</p><ul><li><p><code>symmetric</code></p><p>  a relation $r$ is symmetric if and only if each element of its embedding $r_i$ , satisﬁes $r_i= e^{0/i\pi}= \pm1$ ;</p></li><li><p><code>inverse</code></p><p>  Two relations $r_1$ and $r_2$ are inverse if and only if their embeddings are <code>conjugates</code>: $r_2= \overline{r}_1$ ;</p></li><li><p><code>composition</code></p><p>  a relation $r_3= e^{i\theta_3} $  is a combination of other two relations $r_1= e^{i\theta_1}$ and $r_2= e^{i\theta_2}$ if and only if $r_3 = r_1 \circ r_2$ (i.e. $\theta_3 = \theta_1 + \theta_2$ ).</p></li></ul><h1 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h1><h2 id="Relations-Formal-deﬁnition"><a href="#Relations-Formal-deﬁnition" class="headerlink" title="Relations Formal deﬁnition"></a>Relations Formal deﬁnition</h2><p><strong>Deﬁnition 1</strong>. A relation $r$ is <code>symmetric</code> (<code>antisymmetric</code>) if $\forall x, y$ </p><p>$$ r(x, y) ⇒ r(y, x) \ ( r(x, y) ⇒ ¬r(y, x) ) $$</p><p>A clause with such form is a <code>symmetry</code> (<code>antisymmetry</code>) pattern.</p><p><strong>Deﬁnition 2</strong>. Relation $r_1$ is <code>inverse</code> to relation $r_2$ if $\forall x, y$ </p><p>$$r_2 (x, y) ⇒ r_1(y, x)$$ </p><p>A clause with such form is a <code>inversion</code> pattern.</p><p><strong>Deﬁnition 3</strong>. Relation $r_1$ is <code>composed</code> of relation $r_2$ and relation $r_3$ . if $\forall x, y, z$</p><p>$$r_2 (x, y) ∧ r_3 (y, z) ⇒ r_1 (x, z)$$ </p><p>A clause with such form is a <code>composition</code> pattern.</p><h2 id="建模思考过程"><a href="#建模思考过程" class="headerlink" title="建模思考过程"></a>建模思考过程</h2><p>我们希望达成以下目标：</p><ul><li>(非)对称关系<br>$$ r(x, y) ⇒ r(y, x) \ ( r(x, y) ⇒ ¬r(y, x))$$</li><li>逆向关系<br>$$r_2 (x, y) ⇒ r_1(y, x)$$</li><li>组合关系<br>$$r_2 (x, y) ∧ r_3 (y, z) ⇒ r_1 (x, z)$$</li></ul><p>那就要找到一个函数能够实现这三种关系的表示。</p><p>TransE能够对这三种关系同时建模吗？稍稍分析一下：</p><ul><li><p>对于<code>symmetric</code></p><p>  需要找到满足条件的关系的embeddings</p><p>  $$ r(x, y) ⇒ r(y, x)$$</p><p>  $$x + r_i = y$$</p><p>  $$y + r_j = x$$</p><p>  $$r_i = r_j$$</p><p>  则，只能 $r_i = r_j = 0$ ，所以不能表示 <code>symmetric</code>。</p></li></ul><ul><li><p>对于<code>antisymmetry</code></p><p>  $$ r(x, y) ⇒ ¬r(y, x) $$</p><p>  要求：</p><p>  $$x + r_i = y$$</p><p>  $$y + r_j = x$$</p><p>  $$r_i \ne r_j$$</p><p>  模型是能够满足要求的，只要保证：</p><p>  $$r_i + r_j = 0$$</p><p>  $$r_i \ne r_j$$</p><p>  至于建模的效果好不好，那是另外一回事。</p></li><li><p>对于<code>inversion</code></p><p>  需要满足：</p><p>  $$r_2 (x, y) ⇒ r_1(y, x)$$ </p><p>  从上述<strong>反对称</strong>的角度进一步看，在满足<strong>反对称</strong>的同时，它也就满足了<code>inversion</code>关系的表达。</p><p>  $$x + r_2 = y$$</p><p>  $$y + r_1 = x$$</p><p>  $$r_i \ne r_j$$</p><p>  只要满足以下条件就行：<br>  $$r_1 = - r_2$$</p></li><li><p>对于<code>composition</code></p><p>  需要满足：</p><p>  $$r_2 (x, y) ∧ r_3 (y, z) ⇒ r_1 (x, z)$$</p><p>  对于使用TransE来表示如下：</p><p>  $$x + r_2 = y$$</p><p>  $$y + r_3 = z$$</p><p>  $$x + r_1 = z$$</p><p>  对<code>TransE</code>的表示进行变形：</p><p>  $$x + r_2 + r_3 = x + r_1$$</p><p>  自然得到：</p><p>  $$r_2 + r_3 = r_1$$</p></li></ul><p>总结来看，<code>TransE</code>除了<strong>对称关系</strong>无法表达，其余关系均能表达，<strong>现在的问题是如何在TransE的基础上对对称关系建模，使得关系的embedding不全为0.</strong></p><p>那么要明白的是<code>TransE</code>为啥不能建模对称关系？因为在使用<strong>平移</strong>建模关系时，对应的是<strong>加法运算</strong>。那么换一种想法，加法不行，那么乘法是不是可以？</p><p>为了满足对称关系的要求，有如下的关系：</p><p>$$hr_i = t$$</p><p>$$tr_j = h$$</p><p>$$r_i = r_j$$</p><p>能够推导出以下关系：</p><p>$$tr_jr_i = t$$</p><p>$$r_jr_i = 1$$</p><p>$$r_ir_i = 1 = r_jr_j$$</p><p>上述可以看成是一个维度上的情况，当换到所有embedding上的维度时，这就自然引出了 <code>Hadmard (or element-wise) product</code>。</p><p>这就是当时使用<code>Hadmard (or element-wise) product</code>需要满足的条件，为了建模对称关系，要保证:</p><p>$$r_ir_i = 1 = r_jr_j$$</p><p>其实，这就是上文中要保证 </p><p>$$| r_i | = 1$$</p><p>的原因。</p><p>We map the head and tail entities $h$ , $t$ to the complex embeddings, i.e., $\mathbf{h}, \mathbf{t} \in \mathbb{C}^ k$ , then we <code>deﬁne the functional mapping</code> induced by each relation $\mathbf{r}$ as an element-wise rotation from the head entity $\mathbf{h}$ to the tail entity $\mathbf{t}$ .</p><p>这里，开始时不明白为什么选择 <code>Hadmard (or element-wise) product</code>，这个与欧拉公式是啥关系？因为原文用了 <code>define</code>，我觉得逻辑可能并不充分，可能是一种启发式的选择，只要它满足三种关系的形式化建模就行。</p><blockquote><p>其实这种思考方法，我仔细想了一下，其实是两种方式的区别，我一开始不明白，是因为没有严格的逻辑推导出要用Hadmard，所以它出来时，我一头雾水，这是一种从因到果的思考方式。但是这里换一种方法去思考，Hadmard的结果满足我们开始时的假设，即能够建模对称关系，因此我们选了它，这是一种由果及因的方式，我的感觉，在ML领域这种方式好像更常见，也是被数学系的人吐槽的原因。</p></blockquote><h2 id="用Hadmard-product验证关系约束"><a href="#用Hadmard-product验证关系约束" class="headerlink" title="用Hadmard product验证关系约束"></a>用Hadmard product验证关系约束</h2><p>验证三种关系如下：</p><ul><li><p>对于<code>symmetric</code></p><p>  需要找到满足条件的关系的embeddings</p><p>  $$ r(x, y) ⇒ r(y, x)$$</p><p>  $$\mathbf{h} \circ \mathbf{r_i} = \mathbf{t}$$</p><p>  $$\mathbf{t} \circ \mathbf{r_j} = \mathbf{h} $$</p><p>  $$\mathbf{r_i} = \mathbf{r_j} $$</p><p>  推导出：<br>  $$\mathbf{r_i} \circ \mathbf{r_i} = 1 = \mathbf{r_j} \circ \mathbf{r_j} $$<br>  符合。</p></li><li><p>对于<code>antisymmetry</code></p><p>  类似的，<br>  $$ r(x, y) ⇒ ¬r(y, x) $$</p><p>  推导出，<br>  $$\mathbf{r_i} \circ \mathbf{r_i} \ne 1 $$<br>  符合。</p></li><li><p>对于<code>inversion</code></p><p>  需要满足：</p><p>  $$r_2 (x, y) ⇒ r_1(y, x)$$ </p><p>  $$\mathbf{h} \circ \mathbf{r_i} = \mathbf{t}$$</p><p>  $$\mathbf{t} \circ \mathbf{r_j} = \mathbf{h} $$</p>  <!-- $$\mathbf{r_i} = \mathbf{r_j} $$ --><p>  推导出：<br>  $$\mathbf{r_i} \circ \mathbf{r_j} = 1 $$</p><p>  $$\mathbf{r_i} = \mathbf{r_j}^{-1} $$</p><p>  符合。</p></li><li><p>对于<code>composition</code></p><p>  需要满足：</p><p>  $$r_2 (x, y) ∧ r_3 (y, z) ⇒ r_1 (x, z)$$</p><p>  根据：</p><p>  $$\mathbf{x} \circ \mathbf{r_2} = \mathbf{y}$$</p><p>  $$\mathbf{y} \circ \mathbf{r_3} = \mathbf{z} $$</p><p>  $$\mathbf{x} \circ \mathbf{r_1} = \mathbf{z} $$</p><p>  推导出：<br>  $$\mathbf{x} \circ \mathbf{r_2} \circ \mathbf{r_3} = \mathbf{x} \circ \mathbf{r_1} $$</p><p>  $$\mathbf{r_2} \circ \mathbf{r_3} = \mathbf{r_1}$$</p><p>  完美得出。</p></li></ul><p>总结来看，<code>Hadmard product</code>能够完美建模三种关系，到此，我们的假设成立。</p><h2 id="与欧拉公式的关系"><a href="#与欧拉公式的关系" class="headerlink" title="与欧拉公式的关系"></a>与欧拉公式的关系</h2><p>用类比的方法来看，<code>TransE</code>是将所有的实体和关系映射到embedding space中，也就是实平面，使用的是<strong>向量加法运算</strong>，三者之间的关系可以使用<strong>平移</strong>这种操作来建立关联。</p><p>那么<strong>Hadmard product</strong>实现的是<strong>向量元素乘法运算</strong>，如果放到实平面中，这没办法对应一个操作，不管是用矩阵乘法实现的线性变换，还是加上平移的仿射变换，都没办法对应将两个同样长度的向量经过元素相乘得到同样长度的向量，因此在理论上说不过去。</p><p>那么，换到复平面上，会怎么样？</p><p>我们知道复平面上一个复数的表示方法有好几种：</p><ul><li>代数：$a+ib$，以 $(1,i)$ 为基的线性组合；</li><li>指数形式</li><li>极坐标</li><li>向量形式</li><li>矩阵乘法</li></ul><p>具体的内容可以参看<a href="https://zhuanlan.zhihu.com/p/85321120">这里</a>。</p><p>通过欧拉公式可以将指数形式和极坐标建立关系。</p><p>此时，复数的相乘可以看做矩阵变换：</p><p>$$z_1z_2 =(a+ib)(c+id) = (ac-bd)+(bc+ad)i$$</p><p><img src="/images/rotate/5.png" alt="复数乘法视为矩阵变换"></p><p>我们只要把embedding拆成实部和虚部，然后再利用复数的乘法进行计算，就同样能得到实部和虚部，即形式不变。</p><p>到此为止，已经弄明白几件事情了：</p><ul><li><code>TransE</code>的缺陷</li><li><code>RoratE</code>的改进想法</li><li><code>Hadmard product</code>满足三种关系的表达需求</li><li><code>Hadmard product</code>的计算可以看成是复平面中embedding的相乘</li></ul><p>还有一件事情，复平面中embedding的相乘和欧拉公式有啥关系？</p><p>我们使用了<code>Hadmard product</code>将一个head实体变成了tail实体，其中的一个操作用来衡量关系，在复空间中将一个实体变成另一个实体，使用的是乘法的方式，那就是指数了，而指数与复空间建立关系的途径，就是欧拉公式。</p><p>$$<br>e^{i\theta} = \text{cos}\theta + i\text{sin}\theta<br>$$</p><p>复空间中的每个数有指数形式和极坐标形式，这两者之间的关系也是欧拉公式。</p><p>从指数形式来看，将一个复数的embedding变换成另一个复数的embedding如下：</p><p>$$e^{i{\Theta}_h} e^{i{\Theta}_r} = e^{i{\Theta}_t}$$</p><p>用极坐标表示，就是将$e^{i{\Theta}_h}$ 逆时针方向旋转了角度 $\Theta_r$，变成了 $e^{i{\Theta}_t}$ 。</p><p>当将关系写成极坐标形式时，</p><!--$$\begin{pmatrix}    \text{cos}\theta & -\text{sin}\theta \\  \text{sin}\theta & \text{cos}\theta \end{pmatrix} $$--><p><img src="/images/rotate/math_1.png"></p><p>也就是如下所示：</p><!--$$\begin{pmatrix}    a & -b \\    b & a \end{pmatrix}\begin{pmatrix}    \text{cos}\theta & -\text{sin}\theta \\    \text{sin}\theta & \text{cos}\theta \end{pmatrix}$$ --><p><img src="/images/rotate/math_2.png"></p><p>这不就是线性变换里的旋转吗，也就是本文的名称的由来！</p><p>不明白的可以回顾一下<a href="https://blog.csdn.net/huangguohui_123/article/details/106000355">以前的知识</a>。</p><p>因为我们之前约束了关系的模长固定，为1，即 $|r_i| = 1$ 。</p><p>因此，在旋转过程中，head实体的模长不会受到影响，只是每一个维度下的复数的相位受到了影响。</p><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>For each triple $(h, r, t)$ , we deﬁne the <code>distance function</code> of RotatE as:</p><p>$$d_r (\mathbf{h}, \mathbf{t}) = \Vert \mathbf{h} \circ \mathbf{r} − \mathbf{t} \Vert$$</p><h2 id="Loss函数"><a href="#Loss函数" class="headerlink" title="Loss函数"></a>Loss函数</h2><!--$$L=-\log \sigma \left( \gamma-d_r (\mathbf{h}, \mathbf{t}) \right) - \sum_{i=1}^{n} \frac{1}{k} \log \sigma\left (d_r \left( \mathbf{h}_{i}^{\prime}, \mathbf{t}_{i}^{\prime}\right)-\gamma\right)$$--><p><img src="/images/rotate/math_3.png"></p><ul><li>$\gamma$ : 和<code>TransE</code>中一样，是<code>margin</code>，视为超参数；</li><li>$\sigma$ : <code>sigmoid function</code></li><li>$(h_i , r, t_i )$ is the <code>i-th negative triplet</code>.</li><li>$k$ 为embedding dimension</li></ul><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>原来的采样方式是使用<strong>均匀的方式</strong>替换head和tail：</p><ul><li><p>低效</p><p>  suffers the problem of inefﬁciency since many samples are obviously false as training goes on</p></li><li><p>没有足够的信息</p><p>  not provide any meaningful information.</p></li></ul><p>文中提出<code>self-adversarial negative sampling</code>，具体而言就是按照以下方式进行采样，</p><!--$$p\left(h_{j}^{\prime}, r, t_{j}^{\prime} \mid\left\{\left(h_{i}, r_{i}, t_{i}\right)\right\}\right)=\frac{\exp \alpha f_{r}\left(\mathbf{h}_{j}^{\prime}, \mathbf{t}_{j}^{\prime}\right)}{\sum_{i} \exp \alpha f_{r}\left(\mathbf{h}_{i}^{\prime}, \mathbf{t}_{i}^{\prime}\right)}$$--><p><img src="/images/rotate/math_4.png"></p><ul><li><p>$\alpha$ : temperature of sampling. </p><blockquote><p>Moreover, since the sampling procedure <strong>may be costly</strong>, we treat the above probability as the <strong>weight of the negative sample</strong>. Therefore, the ﬁnal negative sampling loss with self-adversarial training takes the following form:</p></blockquote><p>  <img src="/images/rotate/math_5.png"></p></li></ul><!--$$L=-\log \sigma\left(\gamma-d_{r}(\mathbf{h}, \mathbf{t})\right)-\sum_{i=1}^{n} p\left(h_{i}^{\prime}, r, t_{i}^{\prime}\right) \log \sigma\left(d_{r}\left(\mathbf{h}_{i}^{\prime}, \mathbf{t}_{i}^{\prime}\right)-\gamma\right)$$--><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p><img src="/images/rotate/1.png" alt="数据集"></p><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><ul><li><p><code>Filtered setting</code>: we rank test triples against all other candidate triples not appearing in the training, validation, or test set, where candidates are generated by corrupting subjects or objects: $(h^{‘} , r, t)$ or $(h, r, t^{‘} )$. </p></li><li><p><code>Mean Rank (MR)</code>, <code>Mean Reciprocal Rank (MRR)</code> and <code>Hits at N (H@N)</code> are standard evaluation measures for these datasets and are evaluated in our experiments.</p></li></ul><h2 id="超参设置"><a href="#超参设置" class="headerlink" title="超参设置"></a>超参设置</h2><ul><li><code>optimizer</code>: <code>Adam</code></li><li><code>search strategy</code>: ﬁne-tune the hyperparameters on the validation dataset with <code>grid search</code></li><li><code>embedding dimension</code>: 125, 250, 500, 1000</li><li><code>batch size</code>: 512, 1024, 2048 </li><li>self-adversarial <code>sampling temperature</code>: 0.5, 1.0 </li><li><code>ﬁxed margin</code> $\gamma$ :3, 6, 9, 12, 18, 24, 30. we ﬁnd that the ﬁxed margin $\gamma$ could prevent our model from over-ﬁtting.</li></ul><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>这里主要体现了在3个来源，4个数据集上的评估效果。</p><p><img src="/images/rotate/2.png" alt="在FB15k和WN18的结果"><br><img src="/images/rotate/3.png" alt="在FB15k-237和WN18RR的结果"><br><img src="/images/rotate/4.png" alt="在Countries的结果"></p><h1 id="结果总结"><a href="#结果总结" class="headerlink" title="结果总结"></a>结果总结</h1><p>本论文主要达成了三项目的：</p><ul><li><p>able to <strong>model and infer various relation patterns</strong> including: symmetry/antisymmetry, inversion, and composition.</p></li><li><p>propose a <strong>novel self-adversarial negative sampling technique</strong> for efﬁciently and effectively training the RotatE model.</p></li><li><p>the RotatE model is <strong>scalable to large knowledge graphs</strong> as it remains linear in both time and memory.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 表示学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TransE - 简单但有效的知识图谱表示学习方法</title>
      <link href="/2021/11/19/shu-ju-ke-xue/transe-jian-dan-dan-you-xiao-de-zhi-shi-tu-pu-biao-shi-xue-xi-fang-fa/"/>
      <url>/2021/11/19/shu-ju-ke-xue/transe-jian-dan-dan-you-xiao-de-zhi-shi-tu-pu-biao-shi-xue-xi-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>来自论文 NIPS 2013年的 <a href="https://papers.nips.cc/paper/2013/hash/1cecc7a77928ca8133fa24680a88d2f9-Abstract.html">Translating Embeddings for Modeling Multi-relational Data</a>。</p><p>这个方法开创了KGE中的一种思考方式，虽然简单，但是值得一读，因为有时候越简单的方法，取得的效果可能没有人们想得那么差。</p><h1 id="针对的问题"><a href="#针对的问题" class="headerlink" title="针对的问题"></a>针对的问题</h1><p>The problem of <code>embedding entities and relationships of multirelational data</code> in low-dimensional vector spaces.</p><h2 id="针对的研究对象"><a href="#针对的研究对象" class="headerlink" title="针对的研究对象"></a>针对的研究对象</h2><p><code>Multi-relational data</code> refers to directed graphs whose nodes correspond to <code>entities</code> and <code>edges</code> of the form <code>(head, label, tail)</code> , denoted $(h, l, t)$ , each of which indicates that there exists a relationship of name <code>label</code> between the entities <code>head</code> and <code>tail</code>.</p><h2 id="之前研究存在问题"><a href="#之前研究存在问题" class="headerlink" title="之前研究存在问题"></a>之前研究存在问题</h2><ul><li>表达能力上升以计算成本上升为代价</li></ul><blockquote><p>The greater expressivity of these models comes <code>at the expense of substantial increases in model complexity</code> which results in modeling assumptions that are <code>hard to interpret</code>, and in <code>higher computational costs</code>.</p></blockquote><ul><li>正则化方法难以设计导致过拟合</li></ul><blockquote><p>such approaches are potentially subject to either <code>overﬁtting</code> since <code>proper regularization of such high-capacity models is hard to design</code>, </p></blockquote><ul><li>非凸优化导致欠拟合</li></ul><blockquote><p>or <code>underﬁtting</code> due to the <code>non-convex optimization problems</code> with many local minima that need to be solved to train them.</p></blockquote><h1 id="研究目标"><a href="#研究目标" class="headerlink" title="研究目标"></a>研究目标</h1><p>模型希望达到的目标：</p><ul><li>easy to train,</li><li>contains a reduced number of parameters,</li><li>and can scale up to very large databases</li></ul><p>in complex and heterogeneous multi-relational domains simple yet appropriate modeling assumptions can <strong>lead to better trade-offs between accuracy and scalability</strong>.</p><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>Relationships are represented as <code>translations</code> in the <code>embedding space</code>: if $(h, l, t)$ holds, then the embedding of the tail entity $t$ should be close to the embedding of the head entity $h$ plus some vector that depends on the relationship $l$ .</p><p>模型的基本想法是<code>head</code>的向量表示 $h$ 与<code>relation</code>的向量表示 $r$ 之和与<code>tail</code>的向量表示  $t$ 越接近越好，即：</p><p>$$<br>h+r \approx t<br>$$</p><p>这里的“接近”可以使用<code>L1</code>或<code>L2</code>范数进行衡量，这也是一个可以调节的超参数。</p><h2 id="方法过程"><a href="#方法过程" class="headerlink" title="方法过程"></a>方法过程</h2><p><img src="/images/transe/1.png" alt="算法过程"></p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>损失函数是使用了负抽样的max-margin函数（原文为：<code>a margin-based ranking criterion</code>）。</p><p>$$<br>L(y, y^{\prime}) = \max(0, margin - y + y^{\prime})<br>$$</p><ul><li>$y$ 是正样本的得分；</li><li>$y^{\prime}$ 是负样本的得分。</li></ul><p>然后使损失函数值最小化，当这两个分数之间的差距大于<code>margin</code>的时候就可以了(我们会设置这个值，通常是1，这个是超参数)。</p><p>由于我们使用距离来表示得分，所以我们在公式中加上一个减号，知识表示的损失函数为：</p><p>$$<br>L(h,r,t) = \max(0, d_{pos} - d_{neg} + margin)<br>$$</p><p>其中，$d$ 是：</p><p>$$<br>d = \Vert h+r -t \Vert<br>$$</p><p>这是<code>L1</code>或<code>L2</code>范数。至于如何得到负样本，则是将head实体或tail实体替换为三元组中的随机实体，具体的方法可以参考 <a href="https://lifehit.cn/2021/11/17/zhi-shi-tu-pu-biao-shi-xue-xi-xun-lian-fang-fa/">知识图谱表示学习：训练方法</a>。</p><h2 id="需要调节的参数"><a href="#需要调节的参数" class="headerlink" title="需要调节的参数"></a>需要调节的参数</h2><p>对于模型本身来说，只需要确定：</p><ul><li>实体和关系的维度：<code>embedding size</code></li><li>衡量接近程度的指标：<code>L1</code>或者<code>L2</code></li><li><code>margin</code></li></ul><p>即可。</p><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><h2 id="使用的数据集"><a href="#使用的数据集" class="headerlink" title="使用的数据集"></a>使用的数据集</h2><p><img src="/images/transe/2.png" alt="使用的数据集"></p><h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><ul><li><p>评估指标</p><ul><li><code>mean rank</code></li><li><code>hits@10</code></li></ul></li><li><p>过滤真实三元组</p></li></ul><p>这部分可以参考 <a href="https://lifehit.cn/2021/11/17/zhi-shi-tu-pu-biao-shi-xue-xi-ping-gu-fang-fa/">知识图谱表示学习：评估方法</a>。</p><h2 id="评估结果"><a href="#评估结果" class="headerlink" title="评估结果"></a>评估结果</h2><p><img src="/images/transe/3.png" alt="Link prediction 评估结果"></p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><ul><li><code>optimizer</code>: stochastic gradient descent</li><li><code>lr</code>: 0.001, 0.01, 0.1</li><li><code>margin</code>: 1, 2, 10</li><li><code>dimension k</code>: 20, 50</li><li><code>regularization</code>: L1, L2</li><li><code>epochs</code>: &lt;1000</li></ul><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul><li>simplicity</li><li>只适合处理一对一的关系，不适合一对多/多对一/多对多的关系。<blockquote><p>举个例子，有两个三元组（中国科学院大学，地点，北京）和（颐和园，地点，北京），使用TransE进行表示的话会得到中国科学院大学的表示向量和颐和园的表示向量很接近，甚至完全相同。但是它们的亲密度实际上可能没有这么大。</p></blockquote></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个方法从模型角度来看，很简单，但是要注意文章的目标是，取得预测性能和计算性能之间的平衡，也就说是比我强的没我快，比我快的没我强。</p><p>而且整个模型，很优美，没有任何繁琐的东西，是值得读的一篇入门的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 表示学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我还是重启了博客写作</title>
      <link href="/2021/11/18/si-kao-nei-sheng/wo-huan-shi-chong-qi-liao-bo-ke-xie-zuo/"/>
      <url>/2021/11/18/si-kao-nei-sheng/wo-huan-shi-chong-qi-liao-bo-ke-xie-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="以前的博客"><a href="#以前的博客" class="headerlink" title="以前的博客"></a>以前的博客</h1><p>博客的写作已经停了很久了，至于当初是如何开始的，已经有点记不清了，不过有一点可以明确的是：当初写博客一半是为了记录技术的积累，一半是有一定的功利性的，就是能够在找工作时写到简历上。最后找到的工作不错，不知道这个有没有起作用。</p><p>当初写博客时，由于是第一次，就直接在一个技术网站上开始了，这个网站，如果经常泡技术社区的人都会知道，CSDN，开始他提供了比较便捷的方式，你只要写就行了，所以对于新手还是挺友好的，类似的平台还有博客园，等等。</p><p>在这个平台上我也写作也慢慢稳定下来，截止到现在 2021年11月18日，目前的数据如下所示：</p><p><img src="/images/restart_blog/1.png" alt="以前的博客浏览数据1"><br><img src="/images/restart_blog/2.png" alt="以前的博客浏览数据2"></p><p>最后一篇文章是发布于2017年9月份，距今已经4年多了，然后我就停止了更新。说实话，这些数据是我没有想到的，因为当时是一边学技术，一边记录下自己的问题，没想到过得到很多人的反馈，虽然与很多的大佬不能比，但是还是有一些成就感的。在此，也为之前积极给与反馈的朋友表示感谢。</p><p>但是之后为啥停了呢？除了一些其他原因，主要有以下几个方面：</p><h2 id="CSDN的环境在变坏"><a href="#CSDN的环境在变坏" class="headerlink" title="CSDN的环境在变坏"></a>CSDN的环境在变坏</h2><p>不知道从什么时候开始，CSDN中的广告和写作的体验越来越不好了，当你看到辛辛苦苦写完的文章，旁边有一个让人不适的广告时，总觉得有点难受。</p><p>同时，还有一些技术上的原因，在写作的过程中，有一次，我发现写到一半的文章消失了，没有任何记录，这导致我对这个平台产生了不信任感，同时还包括整个平台技术质量的下降，之后我有任何问题，基本都是去Stack Overflow查找，除了一些软件安装上遇到的问题。</p><p>慢慢地，当你写的越多，会发现对这个平台的失望越多，而且沉没成本越高，不容易迁移。因此，希望，能有一个自己掌控的平台。</p><h2 id="专注于技术领域的限制"><a href="#专注于技术领域的限制" class="headerlink" title="专注于技术领域的限制"></a>专注于技术领域的限制</h2><p>之前写的博客，专注于纯技术领域，但是慢慢地，我发现，这种“自我设限”的方式，不利于自己的发展，因为人的思考是多方面的，因此，我希望从各个方面来记录个人的发展和对技术的思考，而不只是技术本身。</p><p>基于这种考虑，希望建立一种综合的博客体验，全面地记录技术、思考和阅读，以及自己的一些经历。</p><h1 id="为啥重启"><a href="#为啥重启" class="headerlink" title="为啥重启"></a>为啥重启</h1><p>重启博客的写作是不容易的，开始很难，但是坚持更难，不怕笑话，之前我尝试重启了一次，但是由于种种原因，最后没有坚持下去。但是，此时此刻，我觉得可能仍然没有准备好，但不是有一句话吗？<strong>做一件事最好的时刻是10年前，其次是现在。</strong> 纵然，现在仍然有很多的事情需要处理，但是我还是挤出时间，重建了这个博客平台。因为，我知道，有些东西，<strong>如果不现在记录下来，可能就永远没有记录的机会了。</strong></p><p>为啥要重启博客写作，说到底主要有两个方面原因：</p><h2 id="留下思考的legacy"><a href="#留下思考的legacy" class="headerlink" title="留下思考的legacy"></a>留下思考的legacy</h2><p>不像4年前那么功利性了，反倒是希望留下一些legacy，能够供以后来回忆，不管是技术，还是思考，阅读。</p><p>可能是年纪大了，学生时代的尾声慢慢来到了。有很多的内容输出，虽然也有一直在整理，但是都是躺在自己的Notion里，没有输出到公开的世界，可能都是自嗨，因此，也希望找一个出口，能够呈现自己的学习，思考和经历。</p><h2 id="促进学习和交流"><a href="#促进学习和交流" class="headerlink" title="促进学习和交流"></a>促进学习和交流</h2><p>最近看了很多学习过程方面的文章和书籍，深刻领会到一件事情：<strong>说不出来的知识，就是你还不懂的。</strong> 对于你能掌握的知识，最好是以简单和易懂的方式说出来，讲给别人听，如果别人懂了，那么你也懂了，如果别人不懂，其实你也不懂，因为每次学习一个新的知识，我们都倾向于骗自己，因为自己轻易就懂了，但是事实可能正好相反。</p><p>费曼学习方法，我在好多文章和书籍里都听到了这个方法，可以简单看<a href="https://learnku.com/articles/35137">这里</a>了解，便深入查看了一下，对于费曼这个人，大家可以去wiki查看，对于这种学习方法，简单来讲，即：</p><ul><li>学东西；</li><li>教给别人；</li><li>如果讲不清，回去重学；</li><li>再教，以把外行人教懂为目标；</li></ul><p>其中需要找到一个情景，来实现“教”这个步骤，我希望这个博客能充当这个媒介，当然不是传统的“教授”，而是作为一个将学到的知识进行总结、陈述和输出的平台，这样能让自己掌握的更加夯实。</p><h1 id="以后的发展"><a href="#以后的发展" class="headerlink" title="以后的发展"></a>以后的发展</h1><p>我也不知道未来会发展成什么样子，总之希望能坚持下去，我很钦佩阮一峰、陈皓等大神的持之以恒，或许这就是他们能走出一条对于技术人员来说，很成功的路。</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>在互联网的时代，我们是幸福的，这个博客平台的搭建，并没有消耗太多时间，因为有以下的技术支撑：</p><ul><li>Github</li><li>Hexo静态博客</li><li>Hexo主题 <a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a></li><li>万网域名</li><li>Google Analytics</li></ul>]]></content>
      
      
      <categories>
          
          <category> 思考内省 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱表示学习：评估方法</title>
      <link href="/2021/11/17/shu-ju-ke-xue/zhi-shi-tu-pu-biao-shi-xue-xi-ping-gu-fang-fa/"/>
      <url>/2021/11/17/shu-ju-ke-xue/zhi-shi-tu-pu-biao-shi-xue-xi-ping-gu-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>如何对知识图谱进行评估，其实知识图谱本身并不需要评估，因为其中的实体和关系已经确定，但是考虑到应用时的效率问题等，需要将它们表示成低维向量的形式，因此这种评估是针对表示为低维向量的知识图谱，来探求：低维向量的形式是否能完美代表之前的知识图谱。</p><h1 id="评估数据准备"><a href="#评估数据准备" class="headerlink" title="评估数据准备"></a>评估数据准备</h1><p>那么如何评估这种“完美程度”呢？我们知道在一些tabular数据中使用的模型，比如random forest，GBDT，来一组新的数据，因为有标记，我们预测新数据产生的输出，来与标记进行对比。模型学到的是不同类型数据之间的交互。这种情况下，是通过对新的数据进行prediction来评估模型的学习成果。</p><p>那么在知识图谱表示学习中，模型学到了什么？因为本质上是换了一种表示方法，所以模型学到的是针对同一事务的不同的表示形式，那么就要求在评估时，仍然有同一事务的存在，这么说有点抽象，举个例子：</p><table><thead><tr><th>$x_1$</th><th>$x_2$</th><th>$…$</th><th>$x_{i-1}$</th><th>$x_{i}$</th><th>$y$</th></tr></thead><tbody><tr><td>3</td><td>4</td><td>$…$</td><td>4</td><td>3</td><td>1</td></tr><tr><td>1</td><td>5</td><td>$…$</td><td>9</td><td>0</td><td>0</td></tr><tr><td>2</td><td>1</td><td>$…$</td><td>11</td><td>7</td><td>1</td></tr></tbody></table><p> 假设这是一个tabular数据的预测问题，例如：男生能否脱单。</p><p> 每个维度的向量$x_i$ 代表一种数据，比如：</p><ul><li>$x_1$ 代表你的学历；</li><li>$x_2$ 代表你的家庭背景；</li><li>等等，如此类推…</li></ul><p> 当进行评估时，你所需要的是再出现一个同样格式的数据，每一维的数据的意义和训练集的类似，比如：你不能说在评估时出现一个 $x_{i+1}$ 代表这个人是否会养猪，因为这种类型的数据不在训练集中。</p><p> 同样的，知识图谱表示学习中学到的是一个实体或者关系的低维向量表示，当训练集中出现的是: 高圆圆和Alex, 在评估时，你让我评估 新垣结衣和小约翰(均没有出现在训练集中)的关系。</p><p> 这一点是和之前的评估方法有所区别的。</p><p> 那么如何准备训练集和测试集呢？<strong>在评估数据准备时的一个原则：保证测试集中出现的实体和关系均在训练集中出现。</strong></p><blockquote><p>不同时出现，我评估谁去？谁知道小约翰和新垣结衣合不合适？但我们能评估高圆圆和Alex合不合适… </p></blockquote><h1 id="评估任务"><a href="#评估任务" class="headerlink" title="评估任务"></a>评估任务</h1><p>在KGE评估时，一般采取的是<code>Link prediction</code>任务，在准备时，可以采取的策略：</p><ul><li>在原始的知识图谱上随机删除一些link，然后在评估时预测这些link是否存在，这种情况下，需要计算预测的准确率；</li><li>还有一种方法是，将<code>link prediction</code>视为<code>learn to rank</code>任务，通<strong>过排序的指标进行评估，这种方式目前是主流的方法</strong>，下文主要阐述这种方法；</li></ul><p>对于这种方法，首先确定需要进行评估的数据集 $\mathcal{E}$ ，因为有时候进行评估的数据集可能并不是原始的完整的数据集，然后针对数据集中的三元组，进行两种类型的替换，如下：</p><ul><li><p>$(h, r, ?)$ ：取 $\mathcal{E}$ 中的所有实体，替换？，然后计算 $(h, r, t)$ 在其中的排序，越靠前越好；</p></li><li><p>$(?, r, t)$ ：取 $\mathcal{E}$ 中的所有实体，替换？，然后计算 $(h, r, t)$ 在其中的排序，越靠前越好；</p></li></ul><h1 id="评估指标-Rank-based-method"><a href="#评估指标-Rank-based-method" class="headerlink" title="评估指标(Rank-based method)"></a>评估指标(Rank-based method)</h1><h2 id="Hits-K"><a href="#Hits-K" class="headerlink" title="Hits@K"></a>Hits@K</h2><p>hits@k根据出现在排序列表中的前k个实体中，真实实体排序的位置进行评估。</p><p>具体计算方式如下：</p><p>$$<br>\text{hits@}k = \frac{1}{|\mathcal{I}|} \sum \limits_{r \in \mathcal{I}} \mathbb{I}[r \leq k]<br>$$</p><ul><li>$\mathcal{I}$ 表示一组排序的结果；</li><li>$|\mathcal{I}|$ 表示一组排序的结果的数量；</li><li>$\mathbb{I}$ 为指示函数；</li><li>$k$ 为界定的范围，常为1, 3, 5, 10</li><li>该值越接近1，说明学习的效果越好；</li><li>这里的<code>r</code>指的是<code>rank</code>;</li></ul><p>一个例子说明：</p><p>当有3个正样本用于生成负样本时，同时考虑替换head和tail，可以生成6个负样本，也就可以得到6个排名结果。</p><table><thead><tr><th>正样本</th><th>head负样本</th><th>tail负样本</th><th>head负样本排序</th><th>tail负样本排序</th></tr></thead><tbody><tr><td>$(h_1, r_1, t_1)$</td><td>$(h_1, r_1, ?)$</td><td>$(?, r_1, t_1)$</td><td>8</td><td>4</td></tr><tr><td>$(h_2, r_2, t_2)$</td><td>$(h_2, r_2, ?)$</td><td>$(?, r_2, t_2)$</td><td>2</td><td>1</td></tr><tr><td>$(h_3, r_3, t_3)$</td><td>$(h_3, r_3, ?)$</td><td>$(?, r_3, t_3)$</td><td>90</td><td>1</td></tr></tbody></table><p>则计算如下：</p><p>$$<br>hits@1 = \frac{1}{6} \times (0 + 0 + 0 + 1 + 0 + 1) = 0.3333<br>$$</p><p>$$<br>hits@3 = \frac{1}{6} \times (0 + 0 + 1 + 1 + 0 + 1) = 0.50<br>$$</p><p>$$<br>hits@5 = \frac{1}{6} \times (0 + 1 + 1 + 1 + 0 + 1) = 0.6667<br>$$</p><p>如果你实际计算时会发现一个问题，比如对于 $(h_1, r_1, ?)$，它的排序为8，但是由于比1， 3， 5都大，所以仍然记为0，但是它比 $(h_3, r_3, ?)$ 的排序为90，要好很多，但是对于 $rank &gt; k$ 的，该指标一视同仁，也是一个缺陷。</p><h2 id="Mean-Rank-MR"><a href="#Mean-Rank-MR" class="headerlink" title="Mean Rank(MR)"></a>Mean Rank(MR)</h2><p>正如名字体现的，是triples所有排序的算术平均值，这个值的范围是: [1, 所有负样本的数量]。</p><ul><li>1 表明是最理想的情况，所有的triples的排序都是1；</li><li>所有负样本的数量：最坏的情况，所有的排序都是最后一个；</li><li>这个指标越低越好；</li></ul><p>$$<br>\text{score} =\frac{1}{|\mathcal{I}|} \sum \limits_{r \in \mathcal{I}} r<br>$$</p><p>根据上述的6个负样本，计算如下：</p><p>$$<br>\text{MR} = \frac{1}{6} \times (8 + 4 + 2 + 1 + 90 + 1) = 17.6667<br>$$</p><p>从计算方式上来看，这个评估指标比<code>Hits@K</code>好的地方在于：</p><blockquote><p>it is sensitive to any model performance changes, not only what occurs under a certain cutoff and therefore reflects average performance.</p></blockquote><p>但是它的缺陷也很明显，虽然有一定的解释性，但是由于它的边界取决于负样本的数量，但是MR=10，对于负样本为20或者200000的模型，其性能指示含义完全不同。</p><h2 id="Mean-reciprocal-rank-MRR"><a href="#Mean-reciprocal-rank-MRR" class="headerlink" title="Mean reciprocal rank(MRR)"></a>Mean reciprocal rank(MRR)</h2><p>MRR是所有排名的倒数的算术平均值，具体计算如下：</p><p>$$<br>\text{score} =\frac{1}{|\mathcal{I}|} \sum_{r \in \mathcal{I}} r^{-1}<br>$$</p><p>根据上述的6个负样本，计算如下：</p><p>$$<br>\text{MR} = \frac{1}{6} \times (\frac{1}{8} + \frac{1}{4} + \frac{1}{2} + \frac{1}{1} + \frac{1}{90} + \frac{1}{1}) = 0.4810<br>$$</p><ul><li>这个指标在 $[0, 1]$ 之间;</li><li>是对MR的一种改进，使得可以对异常值不太敏感，这里指对高rank的异常值不敏感，但是去开始对低rank值敏感；</li></ul><p>同样的问题，对于一个模型，如果观察到MRR指标为0.01， 那么这个模型是好还是不好？</p><p>这种结论很难直接下，这个值意味着，当去掉outliers时，平均排名为 100(1/0.01) 左右，这个结果可能是好的，也可能是坏的，这取决于使用的负样本的数量。</p><ul><li>当使用了100万的负样本, 那么这个结果很好，因为在100万中排名100，是很好的；</li><li>当使用了负样本只有100个，说明test triples在跟corruptions一起排名时得到的结果很差；</li></ul><p>在真实的数据集上，应该仔细看看hits@k这个指标，之后再判断模型的好坏。</p><p>其中k的选择，应该取决于针对每个test triple生成的负样本的数量。</p><blockquote><p>其实主要的评估指标，包括：<code>MRR</code>, <code>hits@k</code>, 已经是经常使用的了，例如在：<a href="https://paperswithcode.com/task/link-prediction">paperswithcode</a>和<a href="https://www.jiqizhixin.com/sota/tech-task/90c2aa81-2fb1-4363-a379-53edc69b3898">机器之心</a>的SOTA中都是以这几种组作为benchmark的。</p></blockquote><h2 id="其他的指标"><a href="#其他的指标" class="headerlink" title="其他的指标"></a>其他的指标</h2><p>针对上述常用的指标，也有一些改进的衡量指标，比如：</p><ul><li>Inverse Geometric Mean Rank</li><li>Adjusted Mean Rank</li><li>Adjusted Mean Rank Index</li></ul><p>这些指标可以参考 <a href="https://pykeen.readthedocs.io/en/stable/tutorial/understanding_evaluation.html">其他衡量指标</a></p><h1 id="深入评估细节"><a href="#深入评估细节" class="headerlink" title="深入评估细节"></a>深入评估细节</h1><h2 id="如何计算rank"><a href="#如何计算rank" class="headerlink" title="如何计算rank?"></a>如何计算rank?</h2><p>上边我们默认已经知道rank，但是rank是如何计算的，不就是排序列表的索引吗？</p><p>对于一个模型，输出针对triples的分数如下：</p><table><thead><tr><th>Triples</th><th>Score</th><th>Rank(optimistic)</th><th>Rank(pessimistic)</th><th>Rank(realistic)</th></tr></thead><tbody><tr><td>(高圆圆，喜欢，XXX)</td><td>0.9628</td><td>1</td><td>1</td><td>1</td></tr><tr><td>(高圆圆，喜欢，Alex)</td><td>0.9405</td><td>2</td><td>3</td><td>2.5</td></tr><tr><td>(高圆圆，喜欢，赵又廷)</td><td>0.9405</td><td>3</td><td>2</td><td>2</td></tr><tr><td>(高圆圆，喜欢，小约翰)</td><td>0.0001</td><td>4</td><td>4</td><td>4</td></tr></tbody></table><p>但是会出现一个问题：如果模型针对不同的triples输出同样的分数时，如何计算rank？这时候有三种方式：</p><ul><li><code>optimistic</code>：乐观的方式，当正样本和其他的负样本有同样的分数时，则排名取第一个；</li><li><code>pessimistic</code>：悲观的方式，当正样本和其他的负样本有同样的分数时，则排名取最后一个；</li><li><code>realistic</code>：务实的方式，当正样本和其他的负样本有同样的分数时，则排名取<code>optimistic</code>和<code>pessimistic</code>的平均排名；</li></ul><h2 id="rank选边"><a href="#rank选边" class="headerlink" title="rank选边"></a>rank选边</h2><p>上述我们一直默认，当生成负样本时，是针对head和tail同时进行的，但是其实可以任选一边，即：</p><ul><li>只针对head生成负样本；</li><li>只针对tail生成负样本；</li></ul><p>但是一般情况下，我们都是针对两边同时生成负样本。</p><p>但是指针对以便进行负样本的生成是有意义的，因为这样可以评估模型对于head和tail的预测差异。</p><h2 id="过滤已知triples"><a href="#过滤已知triples" class="headerlink" title="过滤已知triples"></a>过滤已知triples</h2><p>这个很明显，当生成负样本时，我们发现，针对(高圆圆，喜欢，Alex)，替换head，得到新的负样本的head可以任意替换，那么，恰巧生成一个负样本 (孙艺珍，喜欢，Alex)，这就尴尬了，因为这是一个正样本，当评估时必然会得到很高的分数，导致得到排名很前的rank，这就导致(高圆圆，喜欢，Alex)的排名靠后了，因此为了正确地衡量模型的性能，因此需要过滤掉这些正确的样本，因为它会忽略这些一直的triples带来的负面影响。</p><p>但是这种filtering的使用时机是很重要的：<strong>一个原则是评估的结果不会影响到模型的训练过程</strong>。根据这个原则，不可以使用filtering：</p><ul><li>Early stopping：不使用test data进行正样本的过滤，以免泄露信息；</li><li>hyperparameter optimization：不使用test data进行正样本的过滤，以免泄露信息；</li></ul><h2 id="实体和关系限定"><a href="#实体和关系限定" class="headerlink" title="实体和关系限定"></a>实体和关系限定</h2><p>这个问题需要阐述的是，上边根据LCWA或者sLCWA，可以生成针对所有实体或者关系的负样本，但是依赖于具体的任务，我们不想这么做，比如：在医疗知识图谱中，每个实体会有额外的实体类型，比如:</p><p>(氯吡格雷，治疗，过敏)，氯吡格雷是一种药物，可以治疗过敏，但是实体中有二甲双胍，这也是一种药品，但是根据上述的假设，则可以生成负样本：(氯吡格雷，治疗，二甲双胍)，这显然是没有意义的，因为在不符合实际，因为这种情况下，当生成负样本时，我们一般希望规定，生成的负样本时符合实际的，比如：(氯吡格雷，治疗，过敏性鼻炎)。</p><p>这种情况下，需要完成两步工作：</p><ul><li>重新生成评估数据；</li><li>针对重新生成的评估数据，来计算衡量指标；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 表示学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱表示学习：训练方法</title>
      <link href="/2021/11/17/shu-ju-ke-xue/zhi-shi-tu-pu-biao-shi-xue-xi-xun-lian-fang-fa/"/>
      <url>/2021/11/17/shu-ju-ke-xue/zhi-shi-tu-pu-biao-shi-xue-xi-xun-lian-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="前提假设"><a href="#前提假设" class="headerlink" title="前提假设"></a>前提假设</h1><h2 id="Open-World-Assumption-OWA"><a href="#Open-World-Assumption-OWA" class="headerlink" title="Open World Assumption(OWA)"></a>Open World Assumption(OWA)</h2><p>开放世界假设，其含义在于暗含的假定为是未知的事实而不是假的，这也是“开放”这个词的含义，这么理解起来有点抽象，一个例子：宇宙内有除了人类的外星人，这个描述在Open World Assumption条件下，不是假的，你只能说它是未知的，这个问题的答案是“开放”的。</p><h2 id="Closed-World-Assumption-CWA"><a href="#Closed-World-Assumption-CWA" class="headerlink" title="Closed World Assumption(CWA)"></a>Closed World Assumption(CWA)</h2><p>封闭世界假设，与开放对立，即：所有未知的都是假的。同样上述的例子：宇宙内有除了人类的外星人，这个描述在Closed World Assumption条件下，我们均认为它是错误的。</p><h2 id="Local-Closed-World-Assumption-LCWA"><a href="#Local-Closed-World-Assumption-LCWA" class="headerlink" title="Local Closed World Assumption(LCWA)"></a>Local Closed World Assumption(LCWA)</h2><p>这个是什么意思呢？与Closed World Assumption相关，这涉及到局部的情况。同样上述的例子：宇宙内有除了人类的外星人，比如：对于不同的人类，这个描述在Local Closed World Assumption条件下，不同的人可能有不同的回答，对于NASA或者国家航天局来说，他们可能知道但是不说，因此他们对这个的回答可能是正确的，而对于我们来说，一般来说是错误的，因为你肯定不知道。这种情况导致不同的人群对于同样的问题出现认知的不同，所以Closed World Assumption假设过于绝对了，因此引入了Local Closed World Assumption，即：对于所有未知的知识中的一部分认为是错误的（因为有人认为那是对的）。</p><h2 id="Stochastic-Local-Closed-World-Assumption-sLCWA"><a href="#Stochastic-Local-Closed-World-Assumption-sLCWA" class="headerlink" title="Stochastic Local Closed World Assumption(sLCWA)"></a>Stochastic Local Closed World Assumption(sLCWA)</h2><p>这个假设，是在Local Closed World Assumption基础之上构建的。其实这个词相比于上述三者使用的较少，<strong>它需要和具体的采样策略结合来看</strong>。因为人类的知识没有办法具体的统计出来，因此日常接触到的知识均可以视为Local Knowledge, 而基于Local Closed World Assumption，所有不属于Local Knowledge的知识都是错误的。Stochastic Local Closed World Assumption则告诉我们，如果在这些“错误”的知识中进行采样，来帮助训练。</p><h1 id="不同假设对于训练的影响"><a href="#不同假设对于训练的影响" class="headerlink" title="不同假设对于训练的影响"></a>不同假设对于训练的影响</h1><p>这种假设条件对于知识图谱嵌入的影响如下：</p><table><thead><tr><th>Assumptions</th><th>影响</th><th>采用情况</th><th>说明</th></tr></thead><tbody><tr><td>Open World Assumption</td><td>会导致欠拟合under-fitting，也即over-generalization)</td><td>一般不用</td><td>直观理解，当一个模型对于一个自己认知之外事务，不明确表达态度时，其实是一种“缺乏自信”的表现，也会对所有已知和未知的事务同样保持“中庸”。</td></tr><tr><td>Closed World Assumption</td><td>会导致over-fitting，即泛化程度很低</td><td>一般不用</td><td>这种假设太过绝对，只要我不知道，就是错误的，有点过于“自负”，这种模型除了自己知道的事务，对其他均不认可。</td></tr><tr><td>Local Closed World Assumption</td><td>根据已有的知识，生成一部分“假”知识</td><td>可用</td><td></td></tr><tr><td>Stochastic Local Closed World Assumption</td><td>根据已有的知识，生成一部分“假”知识，从这些假知识中进行采样</td><td>可用</td><td></td></tr></tbody></table><h1 id="如何生成“假”知识？"><a href="#如何生成“假”知识？" class="headerlink" title="如何生成“假”知识？"></a>如何生成“假”知识？</h1><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>来自于 <a href="https://pykeen.readthedocs.io/en/stable/reference/training.html">source</a>。</p><blockquote><p>Throughout the following explanations of training loops, we will assume the set of entities $\mathcal{E}$ , set of relations $\mathcal{R}$ , set of possible triples $\mathcal{T} = \mathcal{E} \times \mathcal{R} \times \mathcal{E}$. We stratify $\mathcal{T}$ into the disjoint union of positive triples $\mathcal{T^{+}} \subseteq \mathcal{T}$ and negative triples $\mathcal{T^{-}} \subseteq \mathcal{T}$ such that $\mathcal{T^{+}} \cap \mathcal{T^{-}} = \emptyset$ and $\mathcal{T^{+}} \cup \mathcal{T^{-}} = \mathcal{T}$ .</p></blockquote><h2 id="“朴素”的方法"><a href="#“朴素”的方法" class="headerlink" title="“朴素”的方法"></a>“朴素”的方法</h2><p>对于一个已有的知识图谱而言，根据Closed World Assumption，任何不在该知识图谱内的知识或者三元组都是假知识。</p><p>一种“朴素”的负样本的生成办法是：</p><p>对于三元组，可能的组合有以下几种：</p><ul><li>N(head): 代表head实体的种类数量；</li><li>N(rel): 代表relation的种类数量；</li><li>N(tail)：代表tail实体的种类数量；</li></ul><p>则可能的三元组的数量为：</p><p>$$<br>N(head) \times N(rel) \times N(tail)<br>$$</p><p>当删除知识图谱内的三元组时，就可以认为是所有的负样本。这种负样本的数量是巨大的。</p><p>一种可以解决方法是：采样。具体的采样方法有很多种，这里不赘述了。</p><p>但是有一种情况，我们的模型需要<strong>更容易地对真知识进行判断</strong>，举个例子：</p><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTM15gYJOEGxQqr5jBsWUzpAw6RJjvCzus8MA&usqp=CAU" alt="高圆圆"></p><p>对比，高圆圆比娜扎漂亮，我们假设它是对的，当出现凤姐时，模型已经认识高圆圆，它能得出高圆圆比凤姐漂亮。但是当得到的负样本为：梅根福克斯与克劳馥时，你觉得模型对：</p><ul><li>高圆圆与凤姐</li><li>梅根福克斯与克劳馥</li></ul><p>哪个容易判断。</p><h2 id="LCWA下的负样本生成"><a href="#LCWA下的负样本生成" class="headerlink" title="LCWA下的负样本生成"></a>LCWA下的负样本生成</h2><p>基于上述的情况，在Local Closed World Assumption下，<strong>负样本的生成基于以下原则：任意替换三元组的任意一个位置，得到的负样本不属于知识图谱本身，即认为是负样本。</strong></p><p>根据这个原则，可以有三种类型的操作：</p><ul><li><p>head generation: $(h, r, t)$ -&gt; $(h, r, t_i)$;</p><p>   In this setting, for any triple $(h, r, t) \in \mathcal{K}$ that has been observed, a set<br>   $\mathcal{T^{-}} (h, r) $ of negative examples is created by considering all triples $(h, r, t_i) \notin \mathcal{K}$ as false.</p></li><li><p>relation generation: $(h, r, t)$ -&gt; $(h, r_i, t)$; </p><p>   In this setting, for any triple $(h, r, t) \in \mathcal{K}$ that has been observed, a set<br>   $\mathcal{T^{-}} (h, t) $ of negative examples is created by considering all triples $(h, r_i, t) \notin \mathcal{K}$ as false.</p></li><li><p>tail generation: $(h, r, t)$ -&gt; $(h_i, r, t)$;</p><p>   In this setting, for any triple $(h, r, t) \in \mathcal{K}$ that has been observed, a set<br>   $\mathcal{T^{-}} (r, t) $ of negative examples is created by considering all triples $(h_i, r, t) \notin \mathcal{K}$ as false.</p></li></ul><p>一般情况下，在Local Closed World Assumption下，很多的实现都只会考虑head generation和relation generation，不会考虑tail generation。</p><h2 id="sLCWA下的负样本生成"><a href="#sLCWA下的负样本生成" class="headerlink" title="sLCWA下的负样本生成"></a>sLCWA下的负样本生成</h2><p>从Local Closed World Assumption中的三种情况下进行的集合进行采样，即：</p><ul><li>$(h, r, t)$ -&gt; $(h, r, t_i)$</li><li>$(h, r, t)$ -&gt; $(h, r_i, t)$</li><li>$(h, r, t)$ -&gt; $(h_i, r, t)$</li></ul><p>但从实际来看，有时候只需要$(h, r, t)$ -&gt; $(h, r, t_i)$和$(h, r, t)$ -&gt; $(h_i, r, t)$，而没有考虑关系的替换，然后从这两者的集合中进行采样。</p><table><thead><tr><th>Assumptions</th><th>Local Closed World Assumption</th><th>Stochastic Local Closed World Assumption</th></tr></thead><tbody><tr><td>负样本来源</td><td>$(h, r, t)$ -&gt; $(h, r, t_i)$， $(h, r, t)$ -&gt; $(h, r_i, t)$</td><td>$(h, r, t)$ -&gt; $(h, r, t_i)$，$(h, r, t)$ -&gt; $(h_i, r, t)$</td></tr><tr><td>是否要采样</td><td>不需要</td><td>需要</td></tr><tr><td>过滤正样本</td><td>需要</td><td>需要</td></tr></tbody></table><h2 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h2><p>这个具体的帮助理解的例子来自于:<br><a href="https://arxiv.org/abs/2006.13365">Bringing Light Into the Dark: A Large-scale Evaluation of Knowledge Graph Embedding Models Under a Unified Framework</a></p><p><img src="https://pykeen.readthedocs.io/en/stable/_images/training_approaches.png"></p><p>该图对比了负样本在：</p><ul><li>Local Closed World Assumption</li><li>Stochastic Local Closed World Assumption<br>两种生成策略。</li></ul><p>对于同一种关系 <code>works_at</code>, 红色部分是true triples。</p><ul><li>在LCWA生成的是深蓝色对应的负样本，它们都没在原始的知识图谱上。</li><li>在sLCWA生成的是浅蓝色对应的负样本，并从其中采样，它们都没在原始的知识图谱上。</li><li>黄色部分则不在负样本的考虑之列。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 表示学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - Convolutional 2D Knowledge Graph Embeddings</title>
      <link href="/2021/11/14/shu-ju-ke-xue/convkb/"/>
      <url>/2021/11/14/shu-ju-ke-xue/convkb/</url>
      
        <content type="html"><![CDATA[<h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>Link prediction是在知识图谱中预测实体之间的关系的任务，在查询扩展和语义关系预测中需要解决的，也是本论文致力于解决的。</p><p>在解决Link prediction, 其核心考虑因素在于：</p><blockquote><p>link predictors should scale in a manageable way with respect to <strong>both the number of parameters and computational costs</strong> to be applicable in real-world scenarios.</p></blockquote><p>同时需要考虑计算成本，还是考虑模型本身的预测性能，而参数数量是模型性能的一个指标。</p><p>之前方法的问题在于：</p><blockquote><p>Previous work on link prediction has <strong>focused on shallow, fast models</strong> which can scale to large knowledge graphs. However, these models <strong>learn less expressive features</strong> than deep, multi-layer models which potentially limits performance.</p></blockquote><p>简单来讲，之前的方法过于关注在大型知识图谱上进行快速的学习，这需要网络不太复杂。但是其架构学习到的特征不够丰富，性能不够强。</p><p>为了提高知识图谱上的预测性能，从而提高表现力，在不使用深层模型的前提下，只能提高embedding size，但是难以应用到大型知识图谱上。</p><p>换一种思路，使用深度模型，就可以减少embedding size，因为可以学到高层特征，但是在过往的模型中，深度模型中的使用的架构都是全连接层，因此会造成过拟合问题。</p><p>以上问题的一种解决办法是：</p><blockquote><p>use parameter efﬁcient, fast operators which can be composed into deep networks.</p></blockquote><p>因此，自然而然，卷积的操作就被引入了，因为以下特点：</p><ul><li>parameter efﬁcient</li><li>fast to compute: highly optimised GPU implementations</li></ul><p>本文提出来的模型：ConvE, a multi-layer convolutional network model for link prediction，这是一个基于卷积的多层架构。它的优点如下：</p><ul><li><strong>highly parameter efﬁcient</strong>: yielding the same performance as <strong>DistMult</strong> and <strong>R-GCN</strong> with 8x and 17x fewer parameters;</li><li><strong>particularly effective at modelling nodes with high indegree</strong>: common in highlyconnected, complex knowledge graphs such as Freebase and YAGO3;</li></ul><h1 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h1><h2 id="2-1-1D-vs-2D-Convolutions"><a href="#2-1-1D-vs-2D-Convolutions" class="headerlink" title="2.1 1D vs 2D Convolutions"></a>2.1 1D vs 2D Convolutions</h2><p>NLP任务中，多数使用1D卷积进行操作，即在文本的序列方向上进行卷积操作，本文使用2D卷积，不仅在文本序列方向进行操作，同时还在embedding的纵向上进行操作，这使用卷积操作捕捉到的交互信息更丰富。</p><p>这种操作的优点在于： increases the expressiveness of our model through additional points of interaction between embeddings.</p><p>这种操作如何理解？</p><p>当把1D的embedding 进行拼接时，你仍然需要得到1D的embedding，那么拼接的方法只能是在一维上，如下例：</p><p><img src="/images/conve/lex0.png"></p><p>其中假如你的卷积核k=3, 那么能捕捉到的交互只有最临近的a和b, 除非你讲卷积核的尺寸增加，这样才能捕捉到更多的交互。</p><p>当换到2D时，由于是在二维的方向上进行拼接和堆叠，因此其方式可以有多种，因此当卷积进行操作时，可以捕捉的信息可以是左右方向的，也可以是上下方向的，如下图：</p><p><img src="/images/conve/lex1.png"></p><p>如果两种元素代表的意义不同, 那么交换它们的拼接方式还能进一步的提升交互次数:</p><p><img src="/images/conve/lex2.png"></p><p>因此在2D条件下，捕捉到的交互信息数量是不单单与卷积核有关，而且还与矩阵的尺寸有关。</p><h2 id="2-2-问题形式化"><a href="#2-2-问题形式化" class="headerlink" title="2.2 问题形式化"></a>2.2 问题形式化</h2><p>link prediction 可以认为是 a pointwise learning to rank problem。具体而言，对每个输入的三元组 triples: $x = (s, r, o)$, 目标是 learning a scoring function $\psi(x)$, 其结果正比于x为true的likelihood。</p><h2 id="2-3-Neural-Link-Predictors"><a href="#2-3-Neural-Link-Predictors" class="headerlink" title="2.3 Neural Link Predictors"></a>2.3 Neural Link Predictors</h2><p>这个组件是干嘛的，深度学习中总有一些为了唬人提出的名词，其实这个predictors就是一个多层神经网络，包括：</p><ul><li>encoding component: 对 $x = (s, r, o)$, 该部分将subject和object映射为embeddings, $e_s$, $e_o$; </li><li>scoring component: 使用 $\psi_r$ 对embeddings评分，即: $\psi(s, r, o) = \psi_r(e_s, e_o)$ </li></ul><p>一些经常使用的典型predictors如下: </p><p><img src="/images/conve/1.png" alt="经常使用的典型predictors"></p><h2 id="2-4-模型主要内容"><a href="#2-4-模型主要内容" class="headerlink" title="2.4 模型主要内容"></a>2.4 模型主要内容</h2><h3 id="2-4-1-Scoring-function"><a href="#2-4-1-Scoring-function" class="headerlink" title="2.4.1 Scoring function"></a>2.4.1 Scoring function</h3><p>scoring function定义如下:<br>$$<br>\psi_{r}\left(\mathbf{e}_s, \mathbf{e}_o\right)=f\left(\operatorname{vec}\left(f\left(\left[\overline{\mathbf{e}_s} ; \overline{\mathbf{r}_r}\right] \ast \omega\right)\right) \mathbf{W}\right) \mathbf{e}_o<br>$$</p><p>一些符号如下:</p><ul><li><p>$\mathbf{e}_s, \mathbf{e}_o$ 分别代表头实体和尾实体的Embedding；</p></li><li><p>$\overline{\mathbf{e}_s}, \overline{\mathbf{r}_r}$ 分别代表Reshape后的头实体和关系向量，这种操作如下：如果 $\mathbf{e}_s, \mathbf{r}_r \in \mathbb{R}^k$, 那么 $\overline{\mathbf{e}_s}, \overline{\mathbf{r}_r} \in \mathbb{R}^{k_w \times k_h} $, 则 $k = k_w  k_h$</p></li><li><p>$\omega$ 代表卷积核；</p></li><li><p>$\mathbf{W}$ 代表投影矩阵；</p></li></ul><h3 id="2-4-2-模型架构"><a href="#2-4-2-模型架构" class="headerlink" title="2.4.2 模型架构"></a>2.4.2 模型架构</h3><p><img src="/images/conve/2.png" alt="ConvE"></p><p><code>ConvE</code>的整个训练过程如下.</p><ul><li>先通过Embedding的方式分别获得头实体表示 $\mathbf{e}_s$ 和关系表示 $\mathbf{r}_r$ ；</li><li>将头实体和关系表示先<code>Concat</code>起来, 然后将其<code>Reshape</code>到某一种尺寸, 此时头实体和关系的表示记为 $\left[ \overline{\mathbf{e}_s} ; \overline{\mathbf{r}_r} \right]$；</li><li>接着利用卷积抽取Reshape后的二维向量, 也就是对头实体和关系的交互信息进行捕捉；</li><li>利用卷积(可以是任意数量的卷积核)抽取完信息后, 将所有的特征打平成一个一维向量；</li><li>通过投影矩阵 $\mathbf{W}$ 投影到一个中间层中，输出的尺寸与embedding size相同，以便与尾实体表示 $\mathbf{e}_o$ 做内积, 获得相似度, 即Logits；</li><li>这种方式通过内积来比较所获向量与尾实体的相似度, 越相似得分越高.</li><li>然后将Logits经过 $\sigma$ 函数, 得到每个实体的概率：  $$p=\sigma(\psi_r\left(\mathbf{e}_s, \mathbf{e}_o \right))$$</li></ul><p>优化时的损失函数采用BCE(binary cross-entropy loss)：</p><p>$$\mathcal{L}(p, t)=-\frac{1}{N} \sum_i\left(t_i \cdot \log \left(p_i \right)+\left(1-t_i \right) \cdot \log \left(1-p_i \right)\right)$$</p><p>$t$ 是尾实体的one-hot vector. 对于和输入的 $(s, r, ?)$ 匹配的位置为1，其余为0.</p><h3 id="2-4-3-训练tips"><a href="#2-4-3-训练tips" class="headerlink" title="2.4.3 训练tips"></a>2.4.3 训练tips</h3><h4 id="2-4-3-1-基本tips"><a href="#2-4-3-1-基本tips" class="headerlink" title="2.4.3.1 基本tips"></a>2.4.3.1 基本tips</h4><ul><li>rectiﬁed linear units: as the non-linearity $f$, 加快训练；</li><li>batch normalization: after each layer to stabilise</li><li>regularise: dropout</li><li>optimiser: Adam</li><li>label smoothing: to lessen overﬁtting due to saturation of output non-linearities at the labels</li></ul><h4 id="2-4-3-2-加速评估tips"><a href="#2-4-3-2-加速评估tips" class="headerlink" title="2.4.3.2 加速评估tips"></a>2.4.3.2 加速评估tips</h4><p>卷积操作消耗大量时间</p><blockquote><p>convolution consumes about 75-90% of the total computation time, thus it is important to minimise the number of convolution operations to speed up computation</p></blockquote><p>思路1：增加batch size加速，但是CNN会使得GPU的内存超过限制；</p><p>解决办法：1-N scoring</p><p>ConvE最后的输出, 能获得对所有实体相关的Logits, 这样就能<strong>对所有的尾实体同时打分</strong>, <strong>而不用考虑采样的问题</strong>. 在原文中这种打分方式被称为<strong>1-N Scoring</strong>.</p><p>过去评估时，需要采样负样本，进行1-1评估。现在这种方式能极大地加快Evaluation的速度, 因为负采样只能对单一的三元组打分, 而这种方式能同时对所有的尾实体同时打分。这种思想能够应用于所有的1-1 scoring Model.</p><p>这种方式其实本质上利用GPU并行执行的特点，在架构上将训练和评估同时考虑，通过将平衡计算性能和收敛速度，来使得评估过程加快。</p><h1 id="3-实验评估"><a href="#3-实验评估" class="headerlink" title="3. 实验评估"></a>3. 实验评估</h1><h2 id="3-1-数据集"><a href="#3-1-数据集" class="headerlink" title="3.1 数据集"></a>3.1 数据集</h2><table><thead><tr><th>数据集</th><th>来源</th><th>关系</th><th>实体</th><th>三元组</th><th>说明</th></tr></thead><tbody><tr><td>WN18</td><td>a subset of WordNet</td><td>18</td><td>40943</td><td>151442</td><td>consist of hyponym and hypernym relations and, for such a reason, WN18 tends to follow a strictly hierarchical structure. 用WN18RR替代。</td></tr><tr><td>FB15k</td><td>a subset of Freebase</td><td>1345</td><td>14951</td><td>——</td><td>A large fraction of content in this knowledge graph describes facts about movies, actors, awards, sports, and sport teams. 用FB15k-237替代。</td></tr><tr><td>YAGO3-10</td><td>a subset of YAGO3</td><td>37</td><td>123182</td><td>entities which have a minimum of 10 relations each</td><td>Most of the triples deal with descriptive attributes of people, such as citizenship, gender, and profession.</td></tr><tr><td>Countries</td><td></td><td></td><td></td><td></td><td>a benchmark dataset that is useful to evaluate a model’s ability to learn long-range dependencies between entities and relations. It consists of three sub-tasks which increase in difﬁculty in a step-wise fashion, where the minimum pathlength to ﬁnd a solution increases from 2 to 4.</td></tr></tbody></table><h2 id="3-2-超参"><a href="#3-2-超参" class="headerlink" title="3.2 超参"></a>3.2 超参</h2><ul><li><p>选择方法: <code>grid search</code> according to the <code>mean reciprocal rank (MRR)</code> on the validation set</p></li><li><p>选定范围:</p><ul><li><code>embedding dropout</code>: 0.0, 0.1, 0.2</li><li><code>feature map dropout</code>: 0.0, 0.1, 0.2, 0.3</li><li><code>projection layer dropout</code>: 0.0, 0.1, 0.3, 0.5</li><li><code>embedding size</code>: 100, 200</li><li><code>batch size</code>: 64, 128, 256</li><li><code>learning rate</code>: 0.001, 0.003</li><li><code>label smoothing</code>: 0.0, 0.1, 0.2, 0.3</li></ul></li><li><p>最佳参数:</p><ul><li>WN18, YAGO3-10 and FB15k<ul><li><code>embedding dropout</code>: 0.2</li><li><code>feature map dropout</code>: 0.2</li><li><code>projection layer dropout</code>: 0.3</li><li><code>embedding size</code>: 200</li><li><code>batch size</code>: 128</li><li><code>learning rate</code>: 0.001</li><li><code>label smoothing</code>: 0.1</li></ul></li><li>Countries dataset<ul><li><code>embedding dropout</code>: 0.3</li><li><code>hidden dropout</code>: 0.5</li><li><code>label smoothing</code>: 0</li></ul></li><li><code>early stopping</code> according to the <code>mean reciprocal rank</code> (WN18, FB15k, YAGO3-10) and <code>AUC-PR</code> (Countries) statistics on the validation set</li></ul></li></ul><h2 id="3-3-结果"><a href="#3-3-结果" class="headerlink" title="3.3 结果"></a>3.3 结果</h2><p>实验中进行评估时，有几件注意事项：</p><ul><li><p>由于数据出现leakage，因此使用了rule-based method来识别逆向关系作为对照，同时在数据集包括有无逆向关系)中进行评估；</p></li><li><p>使用了<code>filtered setting</code>;</p><blockquote><p>Rank test triples against all other candidate triples not appearing in the training, validation, or test set.</p></blockquote><blockquote><p>Candidates are obtained by permuting either the subject or the object of a test triple with all entities in the knowledge graph.</p></blockquote></li></ul><h3 id="3-3-1-从参数效率看"><a href="#3-3-1-从参数效率看" class="headerlink" title="3.3.1 从参数效率看"></a>3.3.1 从参数效率看</h3><p><img src="/images/conve/3.png" alt="参数数量和性能(ConvE vs. DistMult)"></p><h3 id="3-3-2-结果-含有逆向关系"><a href="#3-3-2-结果-含有逆向关系" class="headerlink" title="3.3.2 结果(含有逆向关系)"></a>3.3.2 结果(含有逆向关系)</h3><p><img src="/images/conve/4.png" alt="结果(含有逆向关系)"></p><h3 id="3-3-3-结果-不含逆向关系"><a href="#3-3-3-结果-不含逆向关系" class="headerlink" title="3.3.3 结果(不含逆向关系)"></a>3.3.3 结果(不含逆向关系)</h3><p>这里将数据集中存在逆向关系的三元组全部删除了，来避免leakage造成的负面影响。</p><p><img src="/images/conve/5.png" alt="结果(不含逆向关系)1"></p><p><img src="/images/conve/6.png" alt="结果(不含逆向关系)2"></p><h2 id="3-4-分析"><a href="#3-4-分析" class="headerlink" title="3.4 分析"></a>3.4 分析</h2><h3 id="3-4-1-消融实验"><a href="#3-4-1-消融实验" class="headerlink" title="3.4.1 消融实验"></a>3.4.1 消融实验</h3><p>为了查看，哪部分组件在整个架构中的作用最重要，消融实验显示：</p><p><img src="/images/conve/7.png" alt="消融实验结果"></p><ul><li>hidden dropout的影响最大;</li><li>但是label smoothing的影响几乎可以忽略；</li></ul><h3 id="3-4-2-从图的结构分析优点"><a href="#3-4-2-从图的结构分析优点" class="headerlink" title="3.4.2 从图的结构分析优点"></a>3.4.2 从图的结构分析优点</h3><h4 id="3-4-2-1-假设1"><a href="#3-4-2-1-假设1" class="headerlink" title="3.4.2.1 假设1"></a>3.4.2.1 假设1</h4><p>datasets contain nodes with very high relation-speciﬁc indegree时，<code>ConvE</code>效果更好，而indegree较小时，一些模型足以应对<code>DistMult</code>。</p><blockquote><p>Our hypothesis is that deeper models, that is, models that learn multiple layers of features, like ConvE, have an advantage over shallow models, like DistMult, to capture all these constraints.</p></blockquote><ul><li>验证：通过将数据中indegree中的过大或者过小的node删除，然后分别使用ConvE和DistMult进行实验，验证了上述假设。</li></ul><h4 id="3-4-2-2-假设2"><a href="#3-4-2-2-假设2" class="headerlink" title="3.4.2.2 假设2"></a>3.4.2.2 假设2</h4><p>平均PageRank越高的graph，ConvE的性能相比于<code>DistMult</code>越好；</p><blockquote><p>This gives additional evidence that models that are deeper have an advantage when modelling nodes with high (recursive) indegree.</p></blockquote><ul><li>验证：通过计算各个数据集的平均pagerank值，然后计算pagerank值与(convE - DistMult)差值计算相关性，验证了上述假设，这个假设2与假设1其实可以看成等价。</li></ul><h1 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h1><ul><li><p><a href="https://github.com/TimDettmers/ConvE">原文实现</a></p></li><li><p><a href="https://github.com/Accenture/AmpliGraph">AmpliGraph</a></p></li></ul><h1 id="5-问题"><a href="#5-问题" class="headerlink" title="5. 问题"></a>5. 问题</h1><ol><li>与CV中CNN的应用对比，模型仍是浅层，未来会增加深度的卷积模型。</li><li>2D卷积的解释；</li><li>如何更多地捕捉embedding之间的交互，例如通过增加大型结构；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 表示学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《美国陷阱》中阿尔斯通被肢解背后的经济战</title>
      <link href="/2021/11/13/du-shu-gan-wu/mei-guo-xian-jing-zhong-a-er-si-tong-bei-zhi-jie-bei-hou-de-jing-ji-zhan/"/>
      <url>/2021/11/13/du-shu-gan-wu/mei-guo-xian-jing-zhong-a-er-si-tong-bei-zhi-jie-bei-hou-de-jing-ji-zhan/</url>
      
        <content type="html"><![CDATA[<p>疫情在家，除了完成正常的工作学习外，由于没啥好的娱乐项目，读书是一种廉价的消遣方式。正巧遇到一本书《美国陷阱》，其中的情节和阴谋论恐怕电影都拍不出来，甚至可以当成悬疑小说来读。</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/1.png" alt="《美国陷阱》"></p><h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h1><p>最近几年，美国加大对中国的打压力度，尤其是科技领域，其中以华为最为大家所熟悉。那么最为人所知伎俩即，扣押孟晚舟（任正非的女儿和华为的高管）。大家肯定跌破眼镜，这种流氓式的手段，对于被称为“世界最大的民主国家”的美国，怎么干得出来？</p><p>当然，理由还是要有的，不然无法说服世界舆论，其实估计也没人信。因为这种套路也不是第一次了，本书讲得就是同样的套路，应用到另一个公司的另一个人身上。</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/2.png" alt="两起事件的对比"></p><p>而本书，讲得就是阿尔斯通的故事，而且是由当事人弗雷德里克-皮耶鲁齐自己陈述的。因此对于我们具有极大的参考价值。</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/3.png" alt="这位老哥比孟晚舟惨得多"></p><h1 id="2-阿尔斯通与中国"><a href="#2-阿尔斯通与中国" class="headerlink" title="2. 阿尔斯通与中国"></a>2. 阿尔斯通与中国</h1><p>阿尔斯通是法国一家有战略意义的工业巨头，关于它的内容，大家可以在网上搜索，我这里不过多阐述，大家认识到这是一家工业巨头就可以了，法国的核电站都是它来维护的，舰艇的燃气轮机也是它提供的。</p><p>而他与中国的渊源也是颇深，三峡水利工程、向家坝水利工程等好多项目，都有它的参与，<strong>甚至书中还披露，当然是阿尔斯通的认罪协议中，阿尔斯通曾经为参与台北地铁项目，而贿赂相关负责人。</strong></p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/4.png" alt="阿尔斯通"></p><h1 id="3-书中主要内容"><a href="#3-书中主要内容" class="headerlink" title="3. 书中主要内容"></a>3. 书中主要内容</h1><p>为了大家能够明白书中的主要线索，我首先用图的方式表达其中涉及到的参与人和机构。</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/5.png" alt="当事人和相关关系"></p><ol><li>首先，美国司法部质控阿尔斯通违反《反腐败法》，逮捕作者，也就是皮耶鲁齐，希望他认罪，在阿尔斯通内部充当“间谍”，以便掌控该企业的内部信息，作者拒绝，被监禁；</li><li>陆续有其他阿尔斯通的高管被逮捕，公司CEO惶恐，希望摆脱诉讼和入狱；</li><li>通用电气介入，摆出了可以帮助阿尔斯通摆脱当前困局的慈善面目，公司CEO为脱罪，达成秘密协议（推测，当事人都矢口否认，但作者强烈暗示这种行为），将阿尔斯通能源部门出售给通用电气（是该公司最有价值的资产）；</li><li>法国政府对这种行为保持暧昧态度，后来知晓，通用电气和阿尔斯通花费将近3亿欧元进行公关，还有一层原因，马克龙（现任法国总统，时任经济部长）相信阿尔斯通CEO与美国司法部、通用电气有交易，但是没有证据；同时受限于大西洋主义以及对美国强大实力的深深恐惧；</li><li>“肢解”交易达成，作者被判入狱30个月。</li></ol><p>从上述过程中，从头到尾，<strong>作者的角色和所处的地位，相较于整个事件，简直微不足道！所以，实际上他当了一个背锅侠和替罪羊！</strong></p><h1 id="4-带给我们的思考和启示"><a href="#4-带给我们的思考和启示" class="headerlink" title="4. 带给我们的思考和启示"></a>4. 带给我们的思考和启示</h1><p><strong>第一点</strong>，战争的形式已经发生变化了，从之前枪炮相加，血肉横飞到网络世界的攻防，可能并没有人死亡，但是损失可能更大。<strong>这本书中提到的有两点很值得注意，一个是舆论公关战，一个就是法律战。</strong></p><p>通用电气和阿尔斯通为促成收购，在媒体和网络上，大肆说明该收购带来的好处，比如增加就业岗位，帮助阿尔斯通摆脱诉讼，同时游说法国政界和企业界的精英。结果，一个曾经在戴高乐将军领导下致力于独立自主的法国居然在外人收购自己的核心资产时，居然沉默是“金”，简直可怕！想想我们这个社会，这样的人会在少数吗？</p><p>法律战，也即本事件的起因，违反《反海外腐败法》。这个法是个什么东西呢？简单来说，美国之外国家的公司，如果使用了与美国相关的工具，则全部收受到该法律的管辖。是不是，有点治外法权的意味呢！比如，在我们国家犯罪，却用美国的法律诉讼，是不是有点滑稽，这种域外法的行使，使得美国的“全球警察”地位坐实了。而且，还让人产生错觉，好像是我错了（虽然在本书中提到的阿尔斯通确实有腐败行为）！</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/6.png" alt="《反海外腐败法》"></p><p><strong>第二点</strong>，我想引述书中的一句话，</p><blockquote><p>我们不能上当受骗。不管谁当美国总统，无论他是民主党人还是共和党人，华盛顿都会维护少数工业巨头的利益</p></blockquote><p>有人曾经，觉得美国民主党上台，对我们可能会温和一点（可能法国人也是这么想的），还是放弃这种幻想吧！这是体制决定的，不是简单的人事变动能够改变的，美国政府和企业巨头的纠缠不断的联系导致“旋转门”的不断上演，所以我们还是做好准备吧！</p><p><strong>第三点</strong>，“人权”和“自由”这种过于抽象的东西，每个人都有自己的理解，比如说那个只喝矿泉水的归国人员，它的解释就为“特权”。<strong>而且每个人的理解都会倾向于自己的利益</strong>，比如作者在狱中的遭遇，美国的监狱的确是没有“人权”，你能相信监狱是私人的，所以当然是需要盈利的，“人权”多费钱啊，与资本主义的核心目标——攫取利益不符啊，当事情与他们的利益不符时，就会有这样的论调。当人权在敌对国家遭到威胁时，这时候美国这个道德楷模就出来了。</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/7.png" alt="你品，你细品！"></p><p>第四点，爱国主义，这种东西在人们的脑海中是正面的东西，我也倾向于这样认为。但是有一点在书中提及，声称“自己生于斯，长于斯”的人，向大家彰显自己的爱国举动，真是是所谓的“爱国人士”吗，或许阿尔斯通CEO柏珂龙的话有助于我们思考，</p><blockquote><p>我是法国择优选拔人才体制的产物。借此机会，我想说，我的父母都是移民。自从在阿尔斯通任职后，我在法国创造了将近1.5万个就业岗位，对此我感到非常自豪。每个人都必须为法国就业做出一份贡献。我已经努力做出了微薄的贡献。</p></blockquote><p>不要忘记，就是他私下与通用电气密谋，肢解了自己服务的“工业明珠”！</p><p>在这本书中，还有很多值得人们思考的东西，包括友情、爱情、劳资关系、糖衣炮弹、爱国主义等等，建议大家去看一下，会收获不一样的东西！其中，对个人来说，最想提及的一点是，找一个好妻子真的是很重要的事情，尤其是像这位老哥遭遇监禁这样的遭遇时，更能体现这一点。</p><h1 id="5-Q-amp-A"><a href="#5-Q-amp-A" class="headerlink" title="5. Q&amp;A"></a>5. Q&amp;A</h1><p>看本书时，我一直不明白的有几个问题，后来弄明白了，在这里列出来同大家分享。</p><p><strong>1) 美国为啥可以管理国外的犯罪？怎么管？</strong></p><p>这与美国在国际上巨大的影响力和超强的实力有关，比如：做国际贸易需要美元结算，没有美元的话没办法进行交易，大家伙都不认，这也是我们一直推进人民币国际化的原因之一。因此，你只要涉及到美元交易，就归美国管，因为美元是美国发行的，具体怎么管，国际贸易会有清算，主要的清算中心在美国，通俗点讲，不听话的话，你就没办法收到货款，也没办法进口。这里，顺便提一句，你觉得Facebook的Libra能成功吗？</p><p>还有一点，除了中国外，世界主要的信息技术公司都是美国公司，所以只要你用了Gmail、Facebook等就都和美国有关系了。</p><p>其实，立什么法不重要，重要的是要有执行能力，这是美国厉害的地方。比如，有一天，你说全世界都得听我的，人家以为你有病呢，但是有人不听时，你有办法治人家，这时大家才服你，最起码表面上服你！</p><p><strong>2) 大西洋主义 VS 亲欧洲主义</strong></p><p>简单来讲，大西洋主义，就是西欧和北美互相合作，保护共同的安全和价值观，但是被认为是美国操纵欧洲的工具，尤其是对于盟友，美国的小动作也在不断的情况下。亲欧洲主义，强调欧洲一体化，摆脱美国的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 读书感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
            <tag> 政治 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
