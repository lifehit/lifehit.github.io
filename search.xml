<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机的存储器层次结构</title>
      <link href="/2022/10/16/ji-suan-ji-ji-chu/ji-suan-ji-de-cun-chu-qi-ceng-ci-jie-gou/ji-suan-ji-de-cun-chu-qi-ceng-ci-jie-gou/"/>
      <url>/2022/10/16/ji-suan-ji-ji-chu/ji-suan-ji-de-cun-chu-qi-ceng-ci-jie-gou/ji-suan-ji-de-cun-chu-qi-ceng-ci-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在计算机中，除了CPU之外，另外一个非常重要的组件是——存储器，根据冯•诺依曼结构的设计思想，计算机中含有存储功能的有：</p><ul><li>运算器 central arithmetical</li><li>存储器 main memory</li><li>外部记录介质 outside recording medium</li></ul><p>对于计算机中的存储器，我们人类都是用贪婪的眼光看待：</p><blockquote><p>We are … forced to recognize the possibility of constructing a hierarchy of memories, each of which has greater capacity than the preceding but which is less quickly accessible.<br>——  A. W. Burks, H. H. Goldstine, and J. von Neumann</p></blockquote><blockquote><p>我比较认同懒惰是人类技术进步的驱动力，同时，认为贪婪也是技术进步的推动力之一。</p></blockquote><p>既想要容量大，又想要访问快。从技术角度来看，这样是可以的吗？可以的，但是需要很多成本。但是考虑现实因素，这样做性价比不高，<strong>所以人们希望建立一个“虚拟”的存储器，能够同时实现这两者，以完成人们的“梦想”，这就是通过memory hierarchy实现的</strong>。这种技术方案是在两者之间取得一个均衡，而不是过分极端，同时考虑成本等因素。</p><h1 id="一些存储器选择的考虑因素"><a href="#一些存储器选择的考虑因素" class="headerlink" title="一些存储器选择的考虑因素"></a>一些存储器选择的考虑因素</h1><ul><li>非易失性<ul><li>即电路断电后，存储器中的信息仍然存在，不会消失。</li><li>CPU中的通用存储器和main memory均为易失性存储器，即断电后数据消失。</li><li>BIOS和硬盘均为非易失性存储器；</li></ul></li><li>可读可写<ul><li>硬盘和main memory均为可读可写的；</li><li>BIOS为只读存储器，用于引导计算机启动，避免任何写入；</li></ul></li><li>随机访问<ul><li>随机访问指，当<strong>对存储器中任意位置数据的访问时间与其所在的位置没有关系。</strong></li><li>这种典型的数据结构是数组和hashmap</li><li>一种典型的非随机访问的设备是磁带，只能顺序访问，否则就要倒带。</li><li>如果不支持随机访问，会对存储器有很大的影响。</li></ul></li><li>访问时间<ul><li>这里所说的访问时间，指的是CPU对存储器的访问时间。</li><li>不同存储器装置的电路结构、与CPU的距离决定了访问时间；</li><li>例如：硬盘由于有机械装置的存在，因此其访问速度难以媲美main memory。</li></ul></li><li>功耗<ul><li>功耗在移动设备上尤其重要；</li><li>也与存储器的电路结构有关，比如是否需要刷新；有时还与总线有关；</li></ul></li><li>还有其他的，如：容量、价格等等；</li></ul><blockquote><p>📌 虽然有这么多考虑因素，但是其中访问速度和容量使我们考虑的核心因素，memory hierarchy也是围绕着两者设计的。</p></blockquote><h1 id="不同类型存储器件的特点"><a href="#不同类型存储器件的特点" class="headerlink" title="不同类型存储器件的特点"></a>不同类型存储器件的特点</h1><h2 id="问题1：硬盘的优点和缺点"><a href="#问题1：硬盘的优点和缺点" class="headerlink" title="问题1：硬盘的优点和缺点"></a>问题1：硬盘的优点和缺点</h2><p>我们都了解硬盘，动辄几百GB，甚至TB，也很常见，<strong>这是它的突出的特点，容量大，同时很便宜，但是缺点是访问速度慢</strong>。导致CPU与硬盘难以直接进行数据交互。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/1.png" alt="硬盘的相关数据"></p><p>如上图所示：</p><ul><li>CPU对比Disk，发现2010相对于1980，CPU的时钟周期，变快了2500倍，但是Disk只提升了29倍，而且两者完全不在一个数量级上。因此CPU直接与Disk交互时，会等待Disk完成IO操作，期间闲置，因此会严重被Disk拖累；</li><li>DRAM相比于Disk则更快一些，其速度提升了9倍，但是与CPU的时钟周期处在同一个数量级上。</li><li>但是Disk的成本降低了1600000倍，而DRAM只降低了130000倍。</li></ul><h2 id="问题2：DRAM存储器性能的影响"><a href="#问题2：DRAM存储器性能的影响" class="headerlink" title="问题2：DRAM存储器性能的影响"></a>问题2：DRAM存储器性能的影响</h2><blockquote><p>DRAM相比于Disk，虽然在访问时间上有提升，但是比CPU的时钟周期还是慢100倍，这种造成怎样的结果呢？</p></blockquote><p>计算执行一条指令，分为4个步骤: </p><ul><li>fetch 取码</li><li>decode 译码</li><li>execute 执行</li><li>write-back 写回</li></ul><p>受限于存储器的性能，当CPU执行其中的特定步骤时，需要等待存储器的访问结束才能进行下一个步骤。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2.png" alt="计算机访问内存执行指令的过程"></p><p>针对这种问题，在CPU和DRAM之间添加SRAM来获得高速访问的效果，以保证程序和数据大部分时间都在SRAM中，SRAM的访问时间一般为3个时钟周期。当使用SRAM作为cache后，指令执行时间大幅下降。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3.png" alt="计算机访问cache执行指令的过程"></p><h2 id="问题3：SRAM的问题"><a href="#问题3：SRAM的问题" class="headerlink" title="问题3：SRAM的问题"></a>问题3：SRAM的问题</h2><p>虽然SRAM的访问速度能够大幅提升性能，但是我们并不用SRAM作为main memory，因为其价格是DRAM的1000倍。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/4.png" alt="SRAM的相关数据"></p><p>但是考虑到其优秀的访问性能，仍作为Cache被不断地引入计算机中。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/5.png" alt="1980 x86-CPU的cache设计"></p><h1 id="Memory-hierarchy的设计"><a href="#Memory-hierarchy的设计" class="headerlink" title="Memory hierarchy的设计"></a>Memory hierarchy的设计</h1><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>考虑到上述不同组件而特点，同时兼顾现实场景，我们对于存储器数据的的访问是等概率的吗？当然不是，肯定有最常访问的数据和程序；那些特定文件夹内吃灰的大部头书籍，肯定很少访问。基于这个现实考虑，人们依据 <code>principle of locality</code> 设计整个结构，有两种 locality:</p><ul><li><code>Temporal locality</code> (locality in time): if an item is referenced, it will tend to be referenced again soon.</li><li><code>Spatial locality</code> (locality in space): if an item is referenced, items whose addresses are close by will tend to be referenced soon.</li></ul><p>依据这两个locality进行了整体结构的设计。</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>这个结构有如下的特点：</p><ul><li>整个结构包含多个层次，每个层次的组件有不同的访问速度和容量；</li><li>访问速度越快，越靠近CPU，也越贵，同时容量也越小；速度慢的则完全相反；</li><li>不仅存储器呈现层次化，其中的数据也呈现层次化，<strong>靠近CPU存储器中的数据是底层存储器的子集，越靠近底层存储的数据越完整</strong>；</li><li>在这个结构中，<strong>仅仅两个相连的levels之间可以进行数据传递</strong>，所以我们只需要关注两个level即可；</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/6.png" alt="Memory Hierarchy整体结构"></p><h2 id="locality如何在结构中体现"><a href="#locality如何在结构中体现" class="headerlink" title="locality如何在结构中体现"></a>locality如何在结构中体现</h2><p>在整体结构中：</p><ul><li><code>temporal locality</code>: 体现在将访问频次高的数据放到顶层，靠近CPU；</li><li><code>spatial locality</code>: 体现在数据读取的最小单位上，电路中数据的存储以bit为单位，但是在memory hierarchy两个levels之间数据的传递，不是按照bit，甚至不是按照byte，而是按照 <code>block (line)</code>，这个是传递信息的最小单位，在底层level中的一段连续的存储单元，即要读就一起，因为彼此相连，可能会被访问。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://www.coursera.org/learn/jisuanji-zucheng/home/week/8">北京大学-计算机组成-第七讲：存储层次结构</a></p></li><li><p>Computer Organization and Design : the hardware/software interface</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储器 </tag>
            
            <tag> memory hierarchy </tag>
            
            <tag> memory </tag>
            
            <tag> cache </tag>
            
            <tag> disk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>述说Vulkan的历史及特点</title>
      <link href="/2022/10/14/ji-suan-ji-tu-xing-xue/vulkan/vulkan-de-li-shi-ji-te-dian/vulkan-de-li-shi-ji-te-dian/"/>
      <url>/2022/10/14/ji-suan-ji-tu-xing-xue/vulkan/vulkan-de-li-shi-ji-te-dian/vulkan-de-li-shi-ji-te-dian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>📌 由于工作的原因，开始进入计算机图形学的领域，开始研究Vulkan，后面会有一系列的学习总结文章，在此挖坑为证。</p></blockquote><h1 id="Vulkan的来源"><a href="#Vulkan的来源" class="headerlink" title="Vulkan的来源"></a>Vulkan的来源</h1><p>不管什么东西，我都喜欢了解一下历史，这样才会激起兴趣，了解它为什么出现、发展，乃至我为什么学习它。</p><p>在我最开始了解图形学时，还是本科的时候，那时候还是OpenGL的天下，因为后面也没有深入图形学领域，也就没有深究，现在开始工作了，发现虽然还是OpenGL占据主流，但是Vulkan、DirectX等API也在不断发展。</p><p>Vulkan最开始起源于AMD的Mantle，之后大家发现这个东西很不错，showcased cutting-edge capabilities，于是AMD就将它开源了，并捐给了Khronos，没错，就是那个掌握OpenGL的组织，这个Khronos是一个产业联盟，里面有很多的软硬件厂商，不包括巨硬。</p><blockquote><p>我发现，国外的企业很愿意把好东西捐给社区，一方面，建立了技术生态，为自己赚取名声，另一方面，由于是自己设计开发的，经常还可以占据主导地位，从而做大做强。</p></blockquote><p>从2016年开始，发布版本（我的mac是2015款的，不过后来发现即便是新款也需要<a href="https://github.com/KhronosGroup/MoltenVK">MoltenVK</a>, 经过一个中介才可以）。</p><h1 id="Vulkan到底是啥"><a href="#Vulkan到底是啥" class="headerlink" title="Vulkan到底是啥"></a>Vulkan到底是啥</h1><blockquote><p>Vulkan is a <strong>software interface</strong> that is capable of controlling GPU hardware settings to <strong>harness the power of paralleling computing.</strong></p></blockquote><ul><li>是一个interface，叫标准、协议也罢，就是大家约定一下，干同样的活遵循同样的步骤，别瞎干，形成了统一的规范后，有利于提高生产率，对于规范的实现，各家GPU厂商自己决定，这是竞争力的体现；</li><li>目的是啥？利用GPU并行计算的能力，说白了，让GPU好好干活，隐含地暗示，之前的API在这件事上做的不好；</li><li>怎么干？通过控制GPU的硬件设置，GPU可复杂了，如果要完全控制，那工作可繁琐了，这也是vulkan的优点，也是它的缺点。</li></ul><h1 id="Vulkan之前的API有啥问题"><a href="#Vulkan之前的API有啥问题" class="headerlink" title="Vulkan之前的API有啥问题"></a>Vulkan之前的API有啥问题</h1><p>之前最主要的是OpenGL，OpenGL本质上是一个state machine，通过控制各种状态，形成不同的组合，从而以最优的方式，达到最高的性能。但是，关键是但是，它的操作是implicit的，开发者有时候并不知道，而且OpenGL太想帮开发者做好各种工作了，但是随着各种复杂场景的出现，力有不逮，频频出错，导致各种问题。</p><p>核心是，OpenGL在之前的场景中，帮大家干得不错，管理的很高，但是现在人们群众的生活水平提高了，大家想要更好的游戏体验，但是OpenGL无法完全满足这种场景，或者说如果要满足，需要付出很大的代价。</p><p>相比于OpenGL这种，希望帮开发者多做事的设计思想，vulkan就很流氓了，老子不管了，出了问题是你们自己的事情，美其名曰开发者最了解自己的需求（当然这也没错啦），将所有的操作全部放到台面上，要干什么，让开发者自己决定，出了错也自己承担，这就是vulkan最核心的思想。</p><blockquote><p>这种思想我不止一次看到，之前在读书的时候，看到很多的设计思想也是这样的，而且，如果仔细看，有没有发现这两种思想和欧洲、美国的政治、社会文化很像，欧洲比社会主义还社会主义，就是OpenGL，太想把大家都照顾好了，可是各种出问题，福利、医疗等等，美国就是自己的事情自己负责，就是Vulkan代表的思想嘛，好处嘛：自己的事情自己负责，成功了是你的本事，上不封顶；坏处嘛：失败了你也别来找我，政府不给你兜底。</p></blockquote><h1 id="Vulkan有啥特点"><a href="#Vulkan有啥特点" class="headerlink" title="Vulkan有啥特点"></a>Vulkan有啥特点</h1><p>说起Vulkan，其实不只有他一家API，除了上面提到的OpenGL，还有巨硬家的DirectX，为了推自己的API，做的事情名声不太好。还有苹果家的Metal API，永远那么特立独行。但是后两个都是针对特定的平台的。</p><blockquote><p>这里Vulkan将跨平台作为优点说，也不是不可以，但是并不意味着针对特定平台的就不好，我觉得还是要中立看待，从商业角度看，苹果家只针对自己的平台做，软硬件融合的很好，只要对市场有足够的掌控力，这就是现金奶牛。</p></blockquote><p>由于OpenGL和Vulkan均是跨平台的，而且又都是Khronos家的，因此他俩比最合适。</p><h2 id="Vulkan减少了driver的工作"><a href="#Vulkan减少了driver的工作" class="headerlink" title="Vulkan减少了driver的工作"></a>Vulkan减少了driver的工作</h2><p>这就是前面提到的，将一些OpenGL driver做的工作放弃，全部交给开发者去做，让他们直接操纵底层硬件，这对于优秀的开发者来说就是好事，对于一些新手来说就是灾难。</p><p>这种设计，使得Vulkan的driver很thin，抛弃了很多责任，可以轻装上阵，因此可以使得GPU渲染地更快。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E7%89%B9%E7%82%B9/1.png" alt="Vulkan Driver的设计——thin"></p><p>Vulkan Driver的设计——thin</p><h2 id="Explicit的设计"><a href="#Explicit的设计" class="headerlink" title="Explicit的设计"></a>Explicit的设计</h2><p>之前说过OpenGL是implicit的，即悄悄地帮你把很多工作都做了，你还不知道（真是个好人）。但是呢，并不招人喜欢，因为管了太多的闲事，有时候还管不好。因此，Vulkan放弃了当这种好人的机会，把之前resource management等工作都甩给开发者，这种方式使得开发者可以看到所有的操作，也会知道哪里出现了问题。</p><h2 id="支持Multithread-scalability"><a href="#支持Multithread-scalability" class="headerlink" title="支持Multithread scalability"></a>支持Multithread scalability</h2><p>多个计算机中多CPU和多核的发展，多线程的能力决定了程序的性能。有<a href="https://www.youtube.com/watch?v=rvCD9FaTKCA">一个视频</a>对比了vulkan和OpenGL ES的能力：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E7%89%B9%E7%82%B9/2.png" alt="Vulkan和OpenGL多核CPU利用的对比"></p><p>对于多核CPU的利用：</p><ul><li>Vulkan是雨露均沾；</li><li>OpenGL ES是独宠一个；</li></ul><p>这是Vulkan多线程能力的一个体现。</p><h2 id="对内存的控制"><a href="#对内存的控制" class="headerlink" title="对内存的控制"></a>对内存的控制</h2><p>由于Vulkan是explicit，因此对于内存的控制，也是开放、透明的，允许开发者选择不同类型的内存来应用在资源上；相比之下，OpenGL把这部分工作也帮你做了，因为是implicit的。</p><p>这一点，还是在上面的视频中有体现，因为内存的访问不仅决定了性能，还决定了功耗：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E7%89%B9%E7%82%B9/3.png" alt="Vulkan和OpenGL功耗的对比"></p><p>vulkan比OpenGL ES更省电。</p><h2 id="统一的API"><a href="#统一的API" class="headerlink" title="统一的API"></a>统一的API</h2><p>我觉得可能是OpenGL被提出的太早，早期的API都是针对桌面的，后面以手机为代表的嵌入式设备不断发展，因此OpenGL中又提出了OpenGL ES，相比之下，Vulkan只有一套API，这样更统一、清晰。同时，手机等移动设备在Vulkan中是第一等公民的角色，而OpenGL中会先更新桌面版，之后再同步到ES。</p><h2 id="Error-check-amp-validation"><a href="#Error-check-amp-validation" class="headerlink" title="Error check &amp; validation"></a>Error check &amp; validation</h2><p>对于程序的错误和异常行为的检查是很重要的，尤其是在debug时，但是在release时就不需要这部分了。OpenGL ES隐式地帮所有程序都进行了错误的检查和验证，不管程序本身是否需要，一个不恰当的比喻，这就好比去西餐厅吃饭，餐厅不管你是否同意，默认帮你找了一个小提琴手演奏，但是之后你发现，这个服务不便宜，而且自己压根不需要。</p><p>相比之下，Vulkan将选择权交给了开发者本身，我们知道，Vulkan在driver中尽量少做事，因此错误的检查和验证不是标准的一部分，标准内的错误验证的功能也很弱。但是它作为了extension出现，形成validation layers，这部分不用被Vulkan的API显示调用，而是通过hook函数注入的，所以使用过程中可能会感知不到。</p><h2 id="Precompiled-shaders"><a href="#Precompiled-shaders" class="headerlink" title="Precompiled shaders"></a>Precompiled shaders</h2><p>在OpenGL ES中shader的代码通过GLSL编写，并且是动态编译的，也就是说在渲染时，OpenGL ES还要去编译shader，这显然更慢了。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Vulkan/Vulkan%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E7%89%B9%E7%82%B9/4.png" alt="Untitled"></p><p>对比而言，Vulkan使用一种中间语言——Standard Portable Intermediate Language (SPIR-V)来表示shader程序，这个shader程序是预先编译好的，其中源代码可以是GLSL，通过Vulkan提供的工具预先编译成SPIR-V，从而减少了后续的工作时间，提升效率。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Book —— Learning Vulkan</li><li><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">Shader modules</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++:函数指针</title>
      <link href="/2022/10/12/bian-cheng-zhi-dao/c-han-shu-zhi-zhen/"/>
      <url>/2022/10/12/bian-cheng-zhi-dao/c-han-shu-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<blockquote><p>📌 参考C++ primer 6.7</p></blockquote><blockquote><p>A function pointer is just that—a pointer that denotes a function rather than an object.</p></blockquote><ul><li>a function pointer points to a particular type.</li><li>A function’s type is determined by its return type and the types of its parameters. The function’s name is not part of its type.  函数的类型，由返回值类型和参数类型决定，名称不起作用，这也是函数重载能成功的原因。</li></ul><h1 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h1><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 函数指针的声明, pf as a pointer to function bool(const string &amp;, const string &amp;)</span><span class="token comment" spellcheck="true">// (*pf)是整体，bool(const string &amp;, const string &amp;)是整体</span><span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 函数的声明, 该函数的类型为bool(const string &amp;, const string &amp;)</span><span class="token keyword">bool</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>函数指针</strong>的声明特别容易与<strong>返回指针类型的函数</strong>的声明混淆，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 不是函数指针的声明，而是一个返回指向bool类型指针的函数</span><span class="token comment" spellcheck="true">// pf(const string &amp;, const string &amp;) as a pointer to bool</span><span class="token comment" spellcheck="true">// pf(const string &amp;, const string &amp;) 是整体</span><span class="token keyword">bool</span> <span class="token operator">*</span><span class="token function">pf</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>所以，<strong>不要忘记那对括号</strong>。</p><p>当使用函数名称作为一个value，其自动转化为一个pointer。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 两种初始化方式等价，&amp;是可选的。</span>pf <span class="token operator">=</span> lengthCompare<span class="token punctuation">;</span>pf <span class="token operator">=</span> <span class="token operator">&amp;</span>lengthCompare<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可以使用空指针初始化，意味着该函数指针未指向任何函数</span>pf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pf <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 函数指针声明的类型，必须与用于初始化的函数类型相同</span><span class="token keyword">int</span> <span class="token function">sumLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cstringCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pf <span class="token operator">=</span> sumLength<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// error, 返回值类型不匹配</span>pf <span class="token operator">=</span> cstringCompare<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// error, 参数类型不匹配</span></code></pre><h1 id="函数指针的使用"><a href="#函数指针的使用" class="headerlink" title="函数指针的使用"></a>函数指针的使用</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>我们可以使用指向一个函数的指针，调用这个函数。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 三种方式等价，*也是可选的</span></code></pre><p>当调用重载函数时，compiler会根据函数指针中声明的类型，选择对应的重载函数之一进行调用，不要忘记，<strong>函数的类型由返回值类型和参数类型决定</strong>。</p><h2 id="函数指针作为参数"><a href="#函数指针作为参数" class="headerlink" title="函数指针作为参数"></a>函数指针作为参数</h2><p>函数中也不能定义函数类型(<code>function type</code>)作为参数，而是需要使用<code>pointer to function</code>, 和<a href="https://lifehit.cn/2022/10/11/bian-cheng-zhi-dao/c-shu-zu-zuo-wei-can-shu-jin-xing-chuan-di/">数组的方式</a>有点像。</p><p>在函数中如果要传递函数类型的参数，使用如下方式：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 两者的声明等价，</span><span class="token comment" spellcheck="true">// 一个隐式转为pointer to function</span><span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 一个显式定义为pointer to function</span><span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用如下</span><span class="token function">userBigger</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> lengthCompare<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中，当传递的参数为function type时，编译器会自动将其转为pointer to function. 这两种类型的区别，可以通过一个小例子查看：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pf <span class="token operator">=</span> lengthCompare<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">using</span> F <span class="token operator">=</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    F f<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">bool</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出：</span><span class="token comment" spellcheck="true">// PF: pointer to function</span><span class="token comment" spellcheck="true">// PFbRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7_E</span><span class="token comment" spellcheck="true">// F: function</span><span class="token comment" spellcheck="true">// FbRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7_E</span></code></pre><p>之前提过，C++中的类型过于复杂会导致问题，这里函数指针就遇到了这个问题，因此可以使用<strong>类型别名</strong>进行替代。在这里需要注意<code>function type</code>和<code>pointer to function</code> 两种类型的区别。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Func and Func2 have function type</span><span class="token keyword">typedef</span> <span class="token keyword">bool</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>lengthCompare<span class="token punctuation">)</span> Func2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// equivalent type</span><span class="token comment" spellcheck="true">// FuncP and FuncP2 have pointer to function type </span><span class="token keyword">typedef</span> <span class="token keyword">bool</span><span class="token punctuation">(</span> <span class="token operator">*</span>FuncP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>lengthCompare<span class="token punctuation">)</span> <span class="token operator">*</span>FuncP2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// equivalent type</span></code></pre><ul><li>Func和Func2均为function type;</li><li>FuncP和FuncP2均为pointer to function type;</li></ul><p>当作为函数的参数传递时，这两种方式均可以：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 两者声明等价</span><span class="token comment" spellcheck="true">// 编译器自动将function type转为pointer to function</span><span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> Func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接传递pointer to type</span><span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> FuncP2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="函数指针作为返回值"><a href="#函数指针作为返回值" class="headerlink" title="函数指针作为返回值"></a>函数指针作为返回值</h2><ul><li>函数指针还可以作为返回值，但是仍然不能返回函数类型，而是需要使用pointer to function.</li><li><strong>编译器不会自动将函数类型转为指针类型，需要显式给出</strong>；注意，这一点与将函数类型作为参数传递不同（那里会自动转为指针类型）。</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// F是function type</span><span class="token keyword">using</span> F <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// PF是pointer type</span><span class="token keyword">using</span> PF <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, return pointer to function</span>PF <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error, return function type</span>F <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, return pointer to function</span>F <span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 可以使用auto + trailing return 简写</span><span class="token keyword">auto</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">(</span> <span class="token operator">*</span> <span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="推导函数指针类型"><a href="#推导函数指针类型" class="headerlink" title="推导函数指针类型"></a>推导函数指针类型</h2><p>这里的pointer to function 和 function type各种写法混在一起，非常容易出错，无法理解。因此，可以使用<code>decltype</code>等来推导，如下：</p><pre class=" language-cpp"><code class="language-cpp">string<span class="token operator">::</span>size_type <span class="token function">sumLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> string<span class="token operator">::</span>size_type <span class="token function">largerLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>sumLength<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">getFcn</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里需要注意的是：当对函数使用decltype时，返回的是<code>function  type</code>，不是 <code>pointer to function</code>, 因此在<code>getFcn</code>前的<code>*</code>千万不能忘记。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> 函数指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++:表达式类型带来的困扰</title>
      <link href="/2022/10/12/bian-cheng-zhi-dao/c-zhong-lei-xing-de-kun-rao/"/>
      <url>/2022/10/12/bian-cheng-zhi-dao/c-zhong-lei-xing-de-kun-rao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>📌 参考C++ primer 2.5</p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在大型程序中，对象的类型往往十分复杂，例如，一个函数指针的类型，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> b <span class="token operator">&amp;</span><span class="token punctuation">)</span></code></pre><p>当作为一个整体放到函数中作为参数时，即冗长，不好理解，又容易出错，鉴于这种情况，我们需要一些解决办法。</p><h1 id="类型别名-type-alias"><a href="#类型别名-type-alias" class="headerlink" title="类型别名 type alias"></a>类型别名 type alias</h1><blockquote><p>A type alias is a name that is a synonym for another type.</p></blockquote><p>定义类型的别名，可以通过两种方式。</p><h2 id="通过typedef定义"><a href="#通过typedef定义" class="headerlink" title="通过typedef定义"></a>通过typedef定义</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 定义double的别名是wages</span><span class="token keyword">typedef</span> <span class="token keyword">double</span> wages<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 定义wages(double)的别名是base, 定义double *的别名是p;</span><span class="token comment" spellcheck="true">// 相当于typedef wages base; typedef wages * p;</span><span class="token keyword">typedef</span> wages base<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>wages i <span class="token operator">=</span> <span class="token number">1.3</span><span class="token punctuation">;</span>p k <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出Pd, 代表pointer to double</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><h2 id="通过using定义"><a href="#通过using定义" class="headerlink" title="通过using定义"></a>通过using定义</h2><blockquote><p>The new standard introduced a second way to deﬁne a type alias, via an <strong>alias declaration</strong>.</p></blockquote><ul><li>An alias declaration starts with the keyword <em><strong>using</strong></em> followed by the alias name and an =.</li><li>The alias declaration deﬁnes the name on the left-hand side of the = as an alias for the type that appears on the right-hand side.</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">using</span> SI <span class="token operator">=</span> Sales_item<span class="token punctuation">;</span>SI si<span class="token punctuation">;</span></code></pre><h2 id="Pointer-amp-const中使用的注意事项"><a href="#Pointer-amp-const中使用的注意事项" class="headerlink" title="Pointer &amp; const中使用的注意事项"></a>Pointer &amp; const中使用的注意事项</h2><p>当类型别名与复杂类型，如pointer等一起使用时，会出现一些难以理解的事情。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span> pstring<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 定义pstring为指向char的指针类型， pointer to char</span><span class="token keyword">const</span> pstring cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// cstr is a constant pointer to char </span><span class="token keyword">const</span> pstring <span class="token operator">*</span>ps<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// ps is a pointer to a constant pointer to char</span></code></pre><p>在我们的使用，如果要判断具体的类型，会倾向于将类型替换为原始类型，如：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> pstring cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可以变成， 容易误解</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// cstr is a pointer to const char</span></code></pre><p>但是这种替换，导致了错误的理解，这里cstr不是<code>pointer to const char</code>, 而是 <code>const pointer to char</code>.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span> pstring<span class="token punctuation">;</span><span class="token keyword">const</span> pstring cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 能修改</span><span class="token operator">*</span>cstr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 错误，不能修改</span>cstr <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>pstring<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出：Pc 代表pointer to char</span></code></pre><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++%E4%B8%AD%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%B0%E6%89%B0/1.png" alt="上述代码输出"></p><ul><li>这里对于 *cstr = 1，没有报错，说明并不是<code>pointer to const char</code>;</li><li>对cstr = &amp;a报错，说明cstr本身是const，即<code>const pointer to char</code>;</li></ul><blockquote><p>这里进行类型替换理解时，需要将pstring整体考虑，即全部都是类型，不能将char * 拆开来看。可以这样理解，pstring是一个指针类型，这是正确的，将pstring视为一个类似int等的简单类型，因此 const pstring就是const pointer，不是pointer to const.</p></blockquote><h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>当类型很复杂时，判断表达式的类型有时很困难，容易出错，C++11提出auto来告诉编译器推断表达式的类型。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// item为int</span><span class="token keyword">auto</span> item <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, int i, int *p</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error, int sz, double pi</span><span class="token keyword">auto</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span></code></pre><p><strong>当在一个声明中，出现多个初始化操作时，要保证所有变量的base type是一致的。</strong></p><h2 id="复杂类型中auto的奇异表现"><a href="#复杂类型中auto的奇异表现" class="headerlink" title="复杂类型中auto的奇异表现"></a>复杂类型中auto的奇异表现</h2><p>对于复杂类型，比如，指针、引用等，auto的结果并不一定是基本数据类型中那么直接，而是编译器会调整。</p><ul><li>对于reference<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// c 为int, 不是 int&amp;</span><span class="token keyword">auto</span> c <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出: i</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre></li><li>对于const<ul><li>忽略 top-level const</li><li>保留 low-level const</li></ul>  top-level const和low-level const是啥，可以参考<a href="https://lifehit.cn/2022/10/07/bian-cheng-zhi-dao/c-const-guan-jian-zi/">这里</a>.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cr <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token keyword">auto</span> b <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token keyword">auto</span> c <span class="token operator">=</span> cr<span class="token punctuation">;</span><span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">auto</span> e <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出</span>i<span class="token operator">:</span> <span class="token keyword">int</span>i<span class="token operator">:</span> <span class="token keyword">int</span>Pi<span class="token operator">:</span> pointer to <span class="token keyword">int</span>PKi<span class="token operator">:</span> pointer to <span class="token keyword">const</span> <span class="token keyword">int</span></code></pre>  因为，auto忽略了top-level const，如果想要保证变量为const，需要显式说明:<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">auto</span> f <span class="token operator">=</span> ci<span class="token punctuation">;</span></code></pre></li><li>对于自动推导类型的reference:  此时，<strong>top-level const不再忽略了，而是保留下来。</strong><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// g 为reference to auto - int, ci的const被保留，因此为const int &amp;, 不是 int或int &amp;</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>g <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error, 是字面量，无法取引用</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>h <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok. j 为 const reference, 不是 reference to const int</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span></code></pre>  这里，跟typedef一样，使用const修饰auto或者typedef定义的类型时，const得到的是const reference(技术上不存在这个概念)或者 const pointer。</li></ul><h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>使用auto时, a variable that uses auto as its type speciﬁer must have an initializer. 但是，并不是每个变量都要初始化，比如函数返回值，此时auto无法使用，可以使用<code>decltype</code>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 不会调用f(), 而是使用返回值类型作为sum的类型</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> sum <span class="token operator">=</span> x<span class="token punctuation">;</span></code></pre><h2 id="复杂类型下的表现"><a href="#复杂类型下的表现" class="headerlink" title="复杂类型下的表现"></a>复杂类型下的表现</h2><ul><li>decltype returns the type of that variable, including top-level const and references.  这一点与auto的表现不同。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cj <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// x has type const int </span><span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// y has type const int&amp; and is bound to x </span><span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> z<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: z is a reference and must be initialized</span></code></pre></li><li>Generally speaking, decltype returns a reference type for expressions that yield objects that can <strong>stand on the left-hand side of the assignment</strong>.  即，decltype推断表达式的类型时，当该表达式可以作为左值时，返回的是它的引用，不是原始类型。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// r + 0 不能作为左值</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: addition yields an int; b is an (uninitialized) int </span><span class="token comment" spellcheck="true">// *p 可以作为左值，接受赋值</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> c<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: c is int&amp; and must be initialized</span></code></pre></li><li>Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression.  在decltype中使用()将变量包起来，会影响类型的推断。<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// decltype of a parenthesized variable is always a reference </span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> d<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: d is int&amp; and must be initialized </span><span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> e<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: e is an (uninitialized) int</span></code></pre><blockquote><p>📌 Remember that decltype((variable)) (note, double parentheses) is always a reference type, but decltype(variable) is a reference type only if variable is a reference.</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> auto </tag>
            
            <tag> decltype </tag>
            
            <tag> typedef </tag>
            
            <tag> 表达式类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++:数组作为参数进行传递</title>
      <link href="/2022/10/11/bian-cheng-zhi-dao/c-shu-zu-zuo-wei-can-shu-jin-xing-chuan-di/"/>
      <url>/2022/10/11/bian-cheng-zhi-dao/c-shu-zu-zuo-wei-can-shu-jin-xing-chuan-di/</url>
      
        <content type="html"><![CDATA[<blockquote><p>📌 来自C++ primer中的6.2.4部分</p></blockquote><h1 id="数组的特性"><a href="#数组的特性" class="headerlink" title="数组的特性"></a>数组的特性</h1><ul><li>数组名称作为指向其中第一个元素的pointer；</li><li>数组不能被copy<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 错误，不能用一个数组初始化另一个数据</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误，不能数组赋值和copy</span></code></pre><blockquote><p>📌 有些编译器允许数组赋值，但是这种是作为compiler extension存在的，不是标准支持的语法，跨编译器时可能会存在问题。</p></blockquote></li></ul><h1 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h1><p>基于数组的特性，不能复制，因此无法使用数组作为函数的形参，也就不能按值传递数组；但是，可以利用另一个特性，向函数传递数组名称作为第一个元素的指针。</p><h2 id="声明数组作为函数参数"><a href="#声明数组作为函数参数" class="headerlink" title="声明数组作为函数参数"></a>声明数组作为函数参数</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 三种声明等价，忽略它们定义的样子</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述三种方式中，函数的参数均为<code>const int*</code>. 因此，当函数调用时，判断传入的参数时，只会按照这个类型进行匹配。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, int *类型，可以传入</span><span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ok, 数组的维度不相关</span></code></pre><p>这里，数组的维度即使不匹配也没问题，因为不影响。</p><p>但是，因此函数也不知道数组的大小了，为了进行遍历，需要一些额外的方法，共有3种。</p><h2 id="依赖数组中的变量类型存在标识符"><a href="#依赖数组中的变量类型存在标识符" class="headerlink" title="依赖数组中的变量类型存在标识符"></a>依赖数组中的变量类型存在标识符</h2><p>典型的就是C风格的字符串，结尾有“\0” null charactor. 因此，可以根据这个判断是否到结尾，如下:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">*</span>cp<span class="token punctuation">)</span><span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>cp<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这种方法对于字符串等类型友好，但是不适用于如int等类型的数据，因为没有结尾标识符。</p><h2 id="传递数组的收尾指针"><a href="#传递数组的收尾指针" class="headerlink" title="传递数组的收尾指针"></a>传递数组的收尾指针</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> beg<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>beg <span class="token operator">!=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>beg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        beg<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中：</p><ul><li>begin返回第一个元素的指针；</li><li>end返回最后一个元素之后的指针，注意，这个指针指向的元素不在数组中，但是是有效的指针value；</li></ul><p>这种方法，通用，安全，不受类型的限制。</p><h2 id="显式传递数组长度"><a href="#显式传递数组长度" class="headerlink" title="显式传递数组长度"></a>显式传递数组长度</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> ia<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">int</span> j<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种方法也是安全的，但是要保证size与ia的长度是一致的。</p><h1 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h1><ul><li>上述函数的定义中，参数均为 pointer to const；<blockquote><p>When a function does not need write access to the array elements, the array parameter should be a pointer to const. A parameter should be a plain pointer to a nonconst type only if the function needs to change element values.</p></blockquote></li><li>reference对于数组参数的影响  对于一个数组变量，可以定义它的reference, 对于函数参数中数组，也可以定义数组的reference，但是会有一点迷惑。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> elem <span class="token operator">:</span> arr<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> elem <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 1. arr[10] stores ten reference to ints.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 2. 表示，arr is a reference to an array of ten ints, (&amp;arr)中括号必须存在</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>  对第一个来说，因为数组的维度是数组类型的一部分，当调用函数<code>print(int (&amp;arr)[10])</code>时，必须保证维度相同。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> k<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: argument is not an array of ten ints </span><span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: argument is not an array of ten ints </span><span class="token function">print</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: argument is an array of ten ints</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 参数传递 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++:const关键字</title>
      <link href="/2022/10/07/bian-cheng-zhi-dao/c-const-guan-jian-zi/"/>
      <url>/2022/10/07/bian-cheng-zhi-dao/c-const-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💡 本篇的内容来自C++ Primer中的2.4节</p></blockquote><h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><h2 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h2><blockquote><p>We can make a variable unchangeable by deﬁning the variable’s type as <strong>const</strong>.</p></blockquote><ul><li>因为const变量，不能改变，因此必须初始化。</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确，runtime初始化 </span><span class="token keyword">const</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 正确，compile time初始化</span><span class="token keyword">const</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 错误，没有初始化</span></code></pre><p>const变量可以接受那些无法改变变量本身数据的操作，例如赋值和copy等。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token keyword">int</span> j <span class="token operator">=</span> ci<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 正确，j初始化后，与ci无关。</span></code></pre><h2 id="特性：const-Objects-Are-Local-to-a-File"><a href="#特性：const-Objects-Are-Local-to-a-File" class="headerlink" title="特性：const Objects Are Local to a File"></a>特性：const Objects Are Local to a File</h2><ul><li>const variables are deﬁned as local to the ﬁle.</li><li>When we deﬁne a const with the same name in multiple ﬁles, it is as if we had written deﬁnitions for separate variables in each ﬁle.</li></ul><p>对于const变量，规定其只在本文件中起作用。</p><blockquote><p>为什么这样规定？这要提到compiler。对于<code>const int bufSize = 512</code>这种使用编译时常量初始化const变量时， 在编译时，编译器会将所有提到的变量进行替换，为了完成替换，编译器必须知道初始化值，当程序分成多个文件时，为了支持编译器的这种操作，需要在所有使用该变量的多个文件中定义同名的const变量，这是我们不愿见到的，因此定义const变量只在本文件生效。</p></blockquote><p>当在一个文件中定义了const变量，但是想在另一个文件中使用，需要使用<code>extern</code>关键字。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// file_1.cc deﬁnes and initializes a const that is accessible to other ﬁles </span><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bufSize <span class="token operator">=</span> <span class="token function">fcn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// file_1.h </span><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bufSize<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// same bufSize as deﬁned in file_1.cc</span></code></pre><p>这样可以实现const变量的共享。</p><h1 id="References-to-const"><a href="#References-to-const" class="headerlink" title="References to const"></a>References to const</h1><blockquote><p>我想，有时候学技术，还是要看英文原版的说明，用词更准确和直接。</p></blockquote><h2 id="澄清概念"><a href="#澄清概念" class="headerlink" title="澄清概念"></a>澄清概念</h2><p>这里首先明确 <strong>references to const</strong> 指的是：</p><ul><li>bind a reference to an object of a const type.</li><li>the object is a reference that refers to a const type;</li></ul><p>但是，这种对于const的引用，不能通过引用改变其值。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: both reference and underlying object are const </span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> ci<span class="token punctuation">;</span> r1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// error: r1 is a reference to const</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> ci<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// error: nonconst reference to a const object</span></code></pre><p>我们在之前讲引用时，提到<strong>引用必须初始化，且在整个生命周期中，不能改变其绑定的变量</strong>。因此，这里需要澄清一下references to const 中易于混淆的概念：</p><ul><li>有人认为：references to const即为 const references，这会造成误解，其实本质不同；</li><li>由于引用本身不能更换引用的对象，因此 in some sense all references are const，或者说，技术上，不存在const references；</li><li>我们一直提的const，不能改变，其实指的是reference to const中，不能通过该引用改变其绑定的值；</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在引用中，引用本身的类型必须与绑定的变量的类型匹配，但是加入了const后，就出现了例外。</p><h3 id="const对reference初始化的影响"><a href="#const对reference初始化的影响" class="headerlink" title="const对reference初始化的影响"></a>const对reference初始化的影响</h3><p>reference必须初始化，且终生不能改变绑定对象；而且其引用的对象类型必须与自己相匹配；且初始化时使用的表达式只能是objects, 不能是 literal 或者运算表达式。</p><p>但是const的使用改变了这些规则。</p><blockquote><p>we can initialize a <strong>reference to const</strong> from any expression that can be converted to the type of the reference.</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// ok: r1 is a reference to const </span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r3 <span class="token operator">=</span> r1 <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: r3 is a reference to const</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r4 <span class="token operator">=</span> r <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//error: r4 is a plain, nonconst reference</span></code></pre><p>对于类型不匹配的也是可以的，其中存在隐式类型转换。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>i <span class="token operator">=</span> dval<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 输出3</span></code></pre><blockquote><p>这里可以这样理解，编译器会生成一个临时变量  const int temp = dval, 然后通过i 引用该temp，所以i 并没有直接引用dval。</p></blockquote><h3 id="references-to-const可以绑定非常量对象"><a href="#references-to-const可以绑定非常量对象" class="headerlink" title="references to const可以绑定非常量对象"></a>references to const可以绑定非常量对象</h3><p>我们提到references to const不能改变绑定对象的值，但是并不意味着绑定对象只能是const变量，只要保证无法通过references to const改变其值即可，因此绑定对象可以为非常量。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> i<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// ok </span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok </span>r1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// ok, i可以改变</span>r2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// error， i不能通过r2改变</span></code></pre><p>所谓，功成不必在我。</p><h1 id="Pointers-and-const"><a href="#Pointers-and-const" class="headerlink" title="Pointers and const"></a>Pointers and const</h1><h2 id="pointer-to-const"><a href="#pointer-to-const" class="headerlink" title="pointer to const"></a>pointer to const</h2><p>使用指针指向一个const变量，是可行的，但是前提是该pointer是一个pointer to const。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>   <span class="token keyword">double</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// error: ptr is a plain pointer</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, pointer to const</span><span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// error: cannot assign to *cptr</span></code></pre><p>注意事项：</p><ul><li>pointer to const: 指向的对象不一定是const，这个有一点离奇，但是就是这么回事，其核心要强调的点是：通过该pointer to const不能改变指向对象的值，但是该对象的值可以通过别的方式改变；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span><span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token number">1.23</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span><span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">1.23</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span></code></pre></li></ul><h2 id="const-pointer"><a href="#const-pointer" class="headerlink" title="const pointer"></a>const pointer</h2><ul><li>与reference不同，pointer是一个object, 因此其本身也可以是const的。</li><li>const pointer指的是该pointer本身不能改变，即不能指向其他的对象；</li><li>同一般的reference一样，也必须进行初始化；</li><li>最容易的理解方式：还是从右往左读；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> errNumb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> curErr <span class="token operator">=</span> <span class="token operator">&amp;</span>errNumb<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// const pointer</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>errNUmb<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pointer to const </span><span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span><span class="token keyword">const</span> pip <span class="token operator">=</span> <span class="token operator">&amp;</span>pi <span class="token comment" spellcheck="true">// const pointer and pointer to const</span></code></pre></li><li>对于const pointer，与pointer to const一样，对于所指向的对象是否为const，没有限制；</li></ul><h2 id="Top-level-const"><a href="#Top-level-const" class="headerlink" title="Top-level const"></a>Top-level const</h2><p>这里只是一个名词的解释：</p><ul><li>top-level const: indicate that the pointer itself is a const;</li><li>low-level const: indicate that a pointer can point to a const object;</li></ul><p>这两个名词，从英文来看很好理解，有什么用呢？语法规定：</p><ul><li>Top-level const can appear in any object type;</li><li>Low-level const appears in the base type of compound types such as pointers or references;  因为只有指针和引用可以指向别的对象。</li></ul><aside>📌 The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level consts are ignored and low-level const is never ignored.</aside><p>什么意思？</p><ul><li>在const对象和非const之间可以随便赋值，拷贝对象，不限制一定是const；</li><li>但是，在pointer to const对象中，如果进行赋值和拷贝，两者必须都是pointer to const.  这样保证，即便发生了复制，也不能通过新的pointer改变指向的对象的值。</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// error</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span></code></pre><h1 id="Constant-Expressions"><a href="#Constant-Expressions" class="headerlink" title="Constant Expressions"></a>Constant Expressions</h1><blockquote><p>A constant expression is an expression whose value cannot change and that can be evaluated <strong>at compile time</strong>.</p></blockquote><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const修饰的一定是constant expression吗？不一定，因为这些值不一定是compile time时确定的, 即：const并不会区分runtime 和compile time变量。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// sz is not a constant expression</span></code></pre><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><h3 id="编译时检查"><a href="#编译时检查" class="headerlink" title="编译时检查"></a>编译时检查</h3><p>由于const与constant expression, 即不是充分条件，也不是必要条件，但是会让人混淆。在C++11中，constexpr被提出，让compiler确认，通过其修饰的一定是compile time常量，即constant expression, 因此其一定必须初始化。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> mf <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 20 is a constant expression constexpr </span><span class="token keyword">int</span> limit <span class="token operator">=</span> mf <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mf + 1 is a constant expression constexpr </span><span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok only if size is a constexpr function</span></code></pre><p>因此，最好使用constexpr代替const，使得能够在compile time时进行检查。</p><blockquote><p>数组的维度，也是在compile time检查的，可以结合进行验证。</p></blockquote><h3 id="literal-types"><a href="#literal-types" class="headerlink" title="literal types"></a>literal types</h3><p>由于constexpr变量在编译时验证，因此其应用的类型也受到限制，只能是literal types:</p><ul><li>arithmetic, reference, and pointer types are literal types.</li><li>the library IO and string types are not literal types.</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> string i <span class="token operator">=</span> <span class="token string">"hello, world"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error, c++20可以</span></code></pre><h3 id="pointers"><a href="#pointers" class="headerlink" title="pointers"></a>pointers</h3><blockquote><p>when we deﬁne a pointer in a constexpr declaration, the constexpr speciﬁer applies to the pointer, not the type to which the pointer points.</p></blockquote><p>constexpr产生的是 <strong>top-level const</strong> on the objects it defines.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// p is a pointer to a const int</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// q is a const pointer to int</span><span class="token keyword">constexpr</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p is a constant pointer to the const int i</span></code></pre><p>这语法，C++ NB。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常量 </tag>
            
            <tag> const </tag>
            
            <tag> constexpr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++:数组的使用以及相关内容</title>
      <link href="/2022/10/07/bian-cheng-zhi-dao/c-shu-zu-de-shi-yong-yi-ji-xiang-guan-nei-rong/"/>
      <url>/2022/10/07/bian-cheng-zhi-dao/c-shu-zu-de-shi-yong-yi-ji-xiang-guan-nei-rong/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💡 本篇的内容来自C++ Primer中的3.5节</p></blockquote><h1 id="Define-amp-Initialize"><a href="#Define-amp-Initialize" class="headerlink" title="Define &amp; Initialize"></a>Define &amp; Initialize</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>数组像指针和引用一样是复杂类型，数组的形式<code>a[d]</code>,</p><ul><li>其中 a为name；</li><li>d为dimension，必须大于0。<blockquote><p>The number of elements in an array is part of the array’s type.</p></blockquote>  因此，dimension必须<strong>在编译时已知</strong>，因此它必须是一个constant。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> cnt <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// not a constant expression </span><span class="token keyword">constexpr</span> <span class="token keyword">unsigned</span> sz <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// constant expression</span></code></pre><blockquote><p>📌 但是，这种问题在g++和clang++编译时可能不会报错，这是因为这些<strong>编译器提供了扩展</strong>，将这种写法视为正确，但是建议禁止这些特性，因为会导致无法在别的compiler中成功运行，在g++和clang++对应的选项是-pedantic-errors。</p></blockquote></li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="隐式"><a href="#隐式" class="headerlink" title="隐式"></a>隐式</h3><p>数组的初始化与数据元素的类型（内置类型、复合类型）、变量作用域（全局变量、局部变量）有关。</p><ul><li>string类型数组全部初始化为空串，无论全局还是局部；</li><li>int类型在全局则全部初始化为0，在函数内部则undefined，如果尝试拷贝或者输出这些变量，会有奇怪的事情发生；</li></ul><p>因此，<strong>千万要显示初始化，不要留有悬疑空间</strong>。</p><h3 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h3><ul><li>将初始化元素全部列出，此时可以忽略dimension；<ul><li>compiler会自动推导；</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li><li>如果给定dimension，初始化元素不能超过它；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a5<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: too many initializers</span></code></pre></li><li>如果初始化元素数量小于dimension，使用默认初始化；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a3<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// equivalent to a3[] = {0, 1, 2, 0, 0} </span>string a4<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"hi"</span><span class="token punctuation">,</span> <span class="token string">"bye"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// same as a4[] = {"hi", "bye", ""} </span></code></pre></li></ul><h2 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h2><p>通过对数组遍历可以访问其中的元素，在C++中遍历数组，除了经典的for循环和while循环外，在C++11中还可以使用类似Java中for…each循环。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> ai<span class="token operator">:</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> ai <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在数组的访问中，<strong>当出现数组越界等问题时，会出现buffer overflow等bug</strong>，而且这些bug在编译时往往难以检查出来，只能在运行时出现异常。</p><h1 id="Array-vs-Vector"><a href="#Array-vs-Vector" class="headerlink" title="Array vs Vector"></a>Array vs Vector</h1><table><thead><tr><th></th><th>array</th><th>vector</th></tr></thead><tbody><tr><td>存放数据类型</td><td>必须是相同类型</td><td>必须是相同类型</td></tr><tr><td>访问存放元素</td><td>无名字，必须通过位置访问</td><td>无名字，必须通过位置访问</td></tr><tr><td>容量</td><td>固定，不能扩展，性能较好</td><td>不固定，能扩展，但是损害性能</td></tr><tr><td>数组维度获取</td><td>无size函数：(1)对于字符数组，可以用<code>strlen</code>；(2)其他数组，只能用<code>sizeof(array)/sizeof(array[0])</code>计算长度；(3)<code>end(array) - begin(array)</code>(c++11)</td><td>有size函数</td></tr><tr><td>下标类型</td><td>可以为负值，涉及指针的算数运算，即便为负值，也需要指向原始数组中的元素。</td><td>必须为非负值</td></tr></tbody></table><p>两者之间的转换：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> int_arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ivec has six elements; each is a copy of the corresponding element in int_arr </span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ivec</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>int_arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>int_arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// subset</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">subVec</span><span class="token punctuation">(</span>int_arr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> int_arr <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="Array-amp-Pointer"><a href="#Array-amp-Pointer" class="headerlink" title="Array &amp; Pointer"></a>Array &amp; Pointer</h1><ul><li><strong>arrays hold objects, 因此可以存储pointers，但是references不是objects, 因此不能存储references。</strong></li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li>数组中的元素均为objects（因此有地址，对比reference不是objects, 因此没有地址）, 因此可以将这些元素的地址赋值给指针；<pre class=" language-cpp"><code class="language-cpp">string nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> string <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p points to the ﬁrst element in nums</span></code></pre></li><li>存储指针的数组<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>parr<span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// array of 42 pointers to int</span><span class="token comment" spellcheck="true">// -----</span><span class="token comment" spellcheck="true">// parr[sz] stores pointers to int. </span></code></pre>  这里容易混乱.<blockquote><p>By default, <em><strong>type modiﬁors bind right to left</strong></em>.</p></blockquote></li></ul><h2 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h2><ul><li>特殊性质：<strong>多数情况下，编译器将数组名称视为第一个元素的指针</strong>；<pre class=" language-cpp"><code class="language-cpp">string <span class="token operator">*</span>p2 <span class="token operator">=</span> nums<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//equivalent to p2 = &amp;nums[0]</span></code></pre></li><li>数组的操作经常可以认为是指针的操作；<ul><li>when we use an array as an initializer for a variable deﬁned using <strong>auto</strong>, the deduced type is a pointer, not an array.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ia is an array of ten ints </span><span class="token keyword">auto</span> <span class="token function">ia2</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ia2 is an int * that points to the ﬁrst element in ia </span>ia2 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: ia2 is a pointer, and we can’t assign an int to a pointer</span></code></pre></li><li>when we use <strong>decltype</strong>. The type returned by decltype(ia) is array of ten ints.<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ia3 is an array of ten ints </span><span class="token keyword">decltype</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span> ia3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span> ia3 <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: can’t assign an int * to an array </span>ia3<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: assigns the value of i to an element in ia3</span></code></pre></li></ul>  <aside>  📌 建议：这里容易混乱的，就不要在实践中使用。    </aside>  </li></ul><h2 id="Pointers-are-Iterators"><a href="#Pointers-are-Iterators" class="headerlink" title="Pointers are Iterators"></a>Pointers are Iterators</h2><h3 id="off-the-end-pointer"><a href="#off-the-end-pointer" class="headerlink" title="off-the-end pointer"></a>off-the-end pointer</h3><p> 前面提到数组的名字可以视为指向其中第一个元素的指针，因此可以通过对名称进行加减操作，来移动指向地址的位置，如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p points to the first element in arr </span><span class="token operator">++</span>p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p points to arr[1]</span></code></pre><p>基于这种特性，可以使用point对array中的元素进行遍历。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pointer just past the last element in arr</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> b <span class="token operator">=</span> arr<span class="token punctuation">;</span> b <span class="token operator">!=</span> e<span class="token punctuation">;</span> <span class="token operator">++</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// print the elements in arr</span><span class="token punctuation">}</span></code></pre><p>其中，<code>&amp;arr[10]</code>是4种有效的指针数据之一，在<a href="https://lifehit.cn/2022/09/18/bian-cheng-zhi-dao/reference-he-pointer/">指针知识部分</a>有说明, 这是一种off-the-end pointer, 非常易于出错。</p><h3 id="begin-amp-end"><a href="#begin-amp-end" class="headerlink" title="begin &amp; end"></a>begin &amp; end</h3><p>在c++11种提出，begin和end函数：</p><ul><li>begin returns a pointer to the ﬁrst;</li><li>end returns a pointer one past the last element in the given array:</li><li>These functions are deﬁned in the iterator header.</li></ul><p>使用如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>pbeg <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>pend <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>pbeg <span class="token operator">!=</span> pend<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pbeg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    pbeg<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这种方法，本质上与off-the-end pointer的做法相同，end函数得到的还是末端之外的指针，但是不用显式操作指针计算，更加安全。</p><h3 id="pointer算数运算"><a href="#pointer算数运算" class="headerlink" title="pointer算数运算"></a>pointer算数运算</h3><p>Pointers that address array elements can use all the iterator operations listed in  the following tables.</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++:%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/table1.png" alt="pointer算数运算1"></p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++:%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/table2.png" alt="pointer算数运算2"></p><p>几个典型的使用如下：</p><ul><li>指针偏移形成新的指针；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ip <span class="token operator">=</span> arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// equivalent to int * ip = &amp;arr[0] </span><span class="token keyword">int</span> <span class="token operator">*</span>ip2 <span class="token operator">=</span> ip <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ip2 points to arr[4]</span><span class="token comment" spellcheck="true">// 注意：这两种写法，意义完全不同</span><span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// == arr[4]</span>last <span class="token operator">=</span> <span class="token operator">*</span>arr <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// == arr[0] + 4</span></code></pre>  此时要保证，新的指针ip2必须指向ip所指向的数组，否则出错。<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> arr <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确，但是使用*p3取数据出错，因为是off-the-end pointer</span><span class="token keyword">int</span> <span class="token operator">*</span>p4 <span class="token operator">=</span> arr <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误，超出范围</span></code></pre></li><li>指针之间相减<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//n is 5, the number of elements in arr</span></code></pre><ul><li>The result of subtracting two pointers is a library type named <code>ptrdiff_t</code>.</li><li>Like <code>size_t</code>, the <code>ptrdiff_t</code> type is a machine-speciﬁc type and is deﬁned in the <code>cstddef</code> header.</li><li><code>ptrdiff_t</code> is a signed integral type.</li></ul>  相减的结果，可以为负数，因此，指针不同于vector，其下标可以为负值，但是必须指向原始数组中的元素。</li><li>指针相比较<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span> b <span class="token operator">=</span> arr<span class="token punctuation">,</span> <span class="token operator">*</span>e <span class="token operator">=</span> arr <span class="token operator">+</span> sz<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// use *b</span>    <span class="token operator">++</span>b<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre>  此时，进行的比较的指针必须均对应相同的数组（或者off-the-end元素），否则没有意义。  <aside>  📌 对于null pointer 也是可以比较的。    </aside>  <pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p <span class="token operator">-</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ia <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ia <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> ia <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// --- output ---</span><span class="token number">0x0</span><span class="token number">0x4</span><span class="token number">1</span><span class="token number">10</span><span class="token number">10</span><span class="token number">0x7ffee03e32fc</span></code></pre></li></ul><h1 id="Array-amp-String"><a href="#Array-amp-String" class="headerlink" title="Array &amp; String"></a>Array &amp; String</h1><h2 id="C-Style-Character-Strings"><a href="#C-Style-Character-Strings" class="headerlink" title="C-Style Character Strings"></a>C-Style Character Strings</h2><p>因为C++继承了C语言，因此C语言中关于字符串的使用方式也被继承下来。</p><aside>📌 但是，C语言中的字符串很难使用，而且是很多安全问题的根源，容易引入各种bugs，因此在C++语言中应该强烈避免使用这种风格的字符串形式，而应该使用<strings>代替，不仅安全，而且效率更高。</aside><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>C语言中的字符串，是使用char[]表示的，一个重要的地方是，这些字符数组必须均以null charactor <code>\0</code>结尾。</p><ul><li>C-style strings are not a type.<ul><li>they are a convention for how to represent and use character strings.</li><li>Strings that follow this convention are stored in character arrays and are null terminated.</li><li>By null-terminated we mean that the last character in the string is followed by a null character (’\0’).</li></ul></li><li>Ordinarily we use pointers to manipulate these strings.</li></ul><p>在C语言，操作字符串，更多是使用pointer完成，这也是此处将pointer和string放到一起的原因之一。</p><p>这种使用方式中，字符串的初始化可以有以下几种：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">char</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'+'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 声明没有问题，但是未使用\0结尾，只能当做字符数组使用，当做字符串使用或相关函数中会出现问题</span><span class="token keyword">char</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确方式</span><span class="token keyword">char</span> a3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"C++"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 正确方式，结尾自动添加了\0</span><span class="token keyword">const</span> <span class="token keyword">char</span> a4<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Daniel"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译时错误，该字符串包括\0占据7个，空间不够</span><span class="token comment" spellcheck="true">// 查看长度</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">end</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出3</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">end</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出4</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">end</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出4</span><span class="token comment" spellcheck="true">// 输出字符串</span>cout <span class="token operator">&lt;&lt;</span> a1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// --- output ---</span><span class="token comment" spellcheck="true">// C++PSj��: 因为a1没有使用\0结尾。</span><span class="token comment" spellcheck="true">// C++: 正确输出，找到第一个\0作为结尾。</span><span class="token comment" spellcheck="true">// C++: 正确输出</span></code></pre><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>C语言中，有很多字符串函数，如下：</p><p><img src="/images/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/C++:%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/strfunc.png" alt="C语言中的字符串函数"></p><p>当这些函数用在char[]中时，也会受到\0的影响, 接上例。</p><pre class=" language-cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// --- output ---</span><span class="token number">9</span><span class="token number">3</span><span class="token number">3</span></code></pre><p>第一个为什么输出9？因为字符串函数strlen()会寻找第一个\0, 然后计算长度，但是a1中没有\0, 因此结果undefined, 也可能是别的。</p><h3 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h3><p>C语言中字符串的比较与C++中strings中不同, 字符串的比较有两个角度，比较数组地址，和比较数组内容。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 比较不同数组的地址，无意义</span><span class="token keyword">const</span> <span class="token keyword">char</span> ca1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"A string example"</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">char</span> ca2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"A different string"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// undeﬁned: compares two unrelated addresses</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ca1 <span class="token operator">&lt;</span> ca2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 比较数组的数据，使用strcmp</span><span class="token comment" spellcheck="true">// same effect as string comparison s1 &lt; s2</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>ca1<span class="token punctuation">,</span> ca2<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><p>C语言风格下，只能使用strcmp来比较字符串，结果为0，字符串相同。</p><p>在C++中，字符串可以简单的使用 ca1 &lt; cal2 完成。</p><h3 id="字符串拼接和复制"><a href="#字符串拼接和复制" class="headerlink" title="字符串拼接和复制"></a>字符串拼接和复制</h3><p>在C语言风格中，也不能使用如下风格的写法：</p><pre class=" language-cpp"><code class="language-cpp">string largeStr <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> s2<span class="token punctuation">;</span></code></pre><p>而是通过<code>strcpy</code>和<code>strcat</code>完成字符串的拼接和复制。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">strcpy</span><span class="token punctuation">(</span>largeStr<span class="token punctuation">,</span> ca1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// copies ca1 into largeStr </span><span class="token function">strcat</span><span class="token punctuation">(</span>largeStr<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// adds a space at the end of largeStr </span><span class="token function">strcat</span><span class="token punctuation">(</span>largeStr<span class="token punctuation">,</span> ca2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// concatenates ca2 onto largeStr</span></code></pre><p>这种使用，必须事先计算好largeStr是否能够容纳最终的结果，否则就会出错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><aside>📌 Modern C++ programs should use vectors and iterators instead of built-in arrays and pointers, and use strings rather than C-style array-based character strings.</aside>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 数组 </tag>
            
            <tag> array </tag>
            
            <tag> 字符串 </tag>
            
            <tag> string </tag>
            
            <tag> pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《邻家的百万富翁》如何生活？</title>
      <link href="/2022/09/25/du-shu-gan-wu/lin-jia-de-bai-wan-fu-weng-ru-he-sheng-huo/"/>
      <url>/2022/09/25/du-shu-gan-wu/lin-jia-de-bai-wan-fu-weng-ru-he-sheng-huo/</url>
      
        <content type="html"><![CDATA[<h1 id="阅读思考"><a href="#阅读思考" class="headerlink" title="阅读思考"></a>阅读思考</h1><p><strong>📌 这本书从名称上看好像是是市面上那种俯拾皆是的成功学的书，但是深入书的内容，可以发现它不仅对于你的财务生活有用，而且还有很多日常生活经验，能够让我们反思自己的行为。</strong></p><p>本书中提到的所谓财富自由，作者特意做出了说明：</p><blockquote><p>本书所论述的百万富翁都达到金钱上的充分自立，即拥有无须工作而能过舒适生活的财富。他们即使连一个月的工资也得不到，仍然能够年复一年地保持他们的日常生活方式不变。</p></blockquote><p>其核心上不是指钱越来越多，而是担心钱的烦恼越来越少，直到消失。</p><p>本书中，通篇都在尝试回答：</p><ul><li>人为什么会致富？</li><li>这些人有哪些特点？</li><li>如何才能致富？</li></ul><h1 id="先读调查方法"><a href="#先读调查方法" class="headerlink" title="先读调查方法"></a>先读调查方法</h1><p>这本书中对于百万富翁的调查取样方法就是很值得学习的，在书的结尾中，作者提到参与市场营销调查课程的成绩为C的学生，认为只要搞到一张豪华汽车车主的名单，就能完成取样的工作，但是全书看下来，如果按照这种方法，我们大概是无缘看到这本书的，因为大多数百万富翁不用豪车。</p><p>鉴于这种情况，从穿着外表、使用的物品和住的房子都不能决定性地判断一个人是不是百万富翁，作者采用了不同的调查方法。因此，译者也建议先读调查方法，可能会让我们对于富翁的情形有一个新的认识。</p><h1 id="百万富翁什么样"><a href="#百万富翁什么样" class="headerlink" title="百万富翁什么样"></a>百万富翁什么样</h1><h2 id="你的误解"><a href="#你的误解" class="headerlink" title="你的误解"></a>你的误解</h2><p>在我们这些平常人的印象中，富人应该是什么样子：</p><ul><li>穿着华丽；</li><li>拥有各种代表社会地位的奢侈品，如手表、珠宝和豪车；</li><li>出入各种高档场所，等等；</li></ul><p>当然，这些印象不一定错误，尤其是当今这种（自）媒体发达的社会，每个人都会将自己包装为成功人士，没有人愿意让自己看起来是个穷人，而且各种炫富的新闻充斥着网络，但是这些人中都是作者定义的富翁吗？不一定，可能他们还在为下个月的房租发愁，也未可知。</p><p>作者的书中提到的人物，无论是路人还是富豪本身，对这种对富人的印象与我们大差不差。</p><h2 id="什么是富"><a href="#什么是富" class="headerlink" title="什么是富"></a>什么是富</h2><p>在作者看来：</p><blockquote><p>许多人夸耀自己高消费的生活方式，却只有很少一点投资或完全没有投资，没有规模足够大的值得注意的资产、能产生收入的资产……与此相反，我们所定义的富人却有着大量的值得重视的资产，所有者从中得到的快乐要比展示高消费生活方式得到的快乐大得多。</p></blockquote><p>因此，我们得到作者的一个核心观点：</p><p><strong>📌 高消费，但是没有增值的投资品的人是不应该称为富人的。</strong></p><p>如何判断一个人是否富有呢？作者给出了一个定量的方法：</p><p><strong>📌 年龄乘以实现的税前年家庭收入，除以10，减去所得到的遗产价值，就是你该有的净值。</strong></p><p>当然，这只是一种粗略的算法，但是可以让我们大致估算一下自己当前的水平，以及努力的空间。而要成为高级财富积累者，还要在此基础上double。</p><h2 id="积累财富的富人的特点"><a href="#积累财富的富人的特点" class="headerlink" title="积累财富的富人的特点"></a>积累财富的富人的特点</h2><p>作者在开篇总结了富人的7个特点，这些特点将他们送往富裕的世界：</p><ol><li>多入少出的生活；</li><li>有效率地安排时间、精力和金钱，致力于财富的积累；</li><li>认为：金钱的充分自立比展示高层次的社会地位更重要；</li><li>没有接受过父母的经济援助；</li><li>他们的孩子经济上能自给自足；</li><li>准确把握市场机会；</li><li>选择了合适的职业；</li></ol><p>我将这些特点分为了三个方面：</p><ul><li>这些富翁信奉的准则，包括：1、2、3；</li><li>他们的家庭和子女关系，包括：4、5；</li><li>努力的方向，包括6、7；</li></ul><h1 id="他们信奉的准则"><a href="#他们信奉的准则" class="headerlink" title="他们信奉的准则"></a>他们信奉的准则</h1><h2 id="多入少出"><a href="#多入少出" class="headerlink" title="多入少出"></a>多入少出</h2><p>人们普遍认为美国是一个高消费的社会，事实也是如此，每当美国禁止一些国家将产品输入时，便会给当事国造成很大麻烦，因此美国是一个巨大的消费市场。</p><p>但是，作者书中提到的这些富翁们却强调一个观点——<strong>避免高消费，或者说合理消费。</strong></p><blockquote><p>财富，是积累下来的东西，而不是你花掉的东西。作者认为构筑财富的大厦虽然要有一定的收入作为前提条件，但主要是依靠克己自律、肯作牺牲和辛勤工作。</p></blockquote><p>你消费的越多，积累的就越少，这是一个很朴素的道理，但是很多人看不明白，或者受限于特殊原因和场景，无法达到。</p><blockquote><p>汽车趋向于迅速减值，而金融资产则趋向于增值。</p></blockquote><p>这些富翁通过多积累能增值的东西，减少贬值的东西来达到多入少出的目标。对于人们的质疑，或者排斥，比如是否有乡村俱乐部的会员资格等等，他们的回应是这样的：</p><blockquote><p>我的企业看起来不漂亮。我不扮那富豪角色……不摆那谱。</p></blockquote><p>在这些人看来，节俭是财富大厦的基石，特别你是从0开始，没有积累，没有家庭的帮助，所以控制好你的手。媒体上那些充满噱头的高消费者被推崇的太过分了。很少有人可以一方面一掷千金，另一方面又是百万富翁。</p><p>有一类人往往被认为是富翁，就是那些收入很高的人，但是如果实地了解的话，他们的大部分收入都纳税、高消费花掉了，想买什么就买什么，希望理解满足需求，因此延迟满足也是一种有效的手段来多入少出。</p><p>相比于那些很高的收入，财富积累的基石是防守，即减少不必要的支出，利用预算和计划监督支出，这里要铭记于心：消费品几乎等同于贬值，不能指望它可以钱生钱。</p><h2 id="合理安排时间、精力和金钱"><a href="#合理安排时间、精力和金钱" class="headerlink" title="合理安排时间、精力和金钱"></a>合理安排时间、精力和金钱</h2><p>这些富翁在制定计划，努力工作方面也有一些为人称道的特质，这些特质可能已经超过本书的主题，但是正是这些隐藏在背后的努力造就了今天的他们。</p><blockquote><p>他们经济有效地分配时间、精力和金钱，致力于构筑他们的财富大厦。</p></blockquote><h3 id="越早开始越好"><a href="#越早开始越好" class="headerlink" title="越早开始越好"></a>越早开始越好</h3><p>即便我们无法做到其他的方面，但是在合理安排计划方面，这些富翁的经验也是值得借鉴的。<strong>为了致富，越早开始自己的投资，成功的机会越大，这是第一点要记住的</strong>，而在学校待得越久，致富的目标可能会延迟。</p><p>相比那些花费大量时间在消费上的人，这些富翁认识到：</p><blockquote><p>把时间和精力花在追求摆阔上，常常会得到一种注定将得到的结果，那就是较差的经济成就。</p></blockquote><h3 id="认真计划工作和投资"><a href="#认真计划工作和投资" class="headerlink" title="认真计划工作和投资"></a>认真计划工作和投资</h3><p>因此，他们对待工作要严谨认真的多：</p><blockquote><p>约翰尼·卢卡斯，作为富裕的企业主是十分守时的。他从来不会迟到，每个工作日早上6点半准时到公司上班。</p></blockquote><blockquote><p>我坚持凡事都定好目标。我有一整套经过明确阐释的每天目标、每周目标、每月目标、每年目标和整个一生的目标。我甚至连洗澡都有个目标。我经常对我们那些年轻的经理说，他们必须定有目标。</p></blockquote><p>相比之下：</p><blockquote><p>低级的财富积累者每月所浪费的时间要数倍于他们用于计划投资策略的时间。</p></blockquote><p>这份认真当然也带到了金钱的管理上。</p><blockquote><p>这些人首先每年已实现的收入至少15%用于投资，然后才用于支付食物、衣服、住房、信用等方面的需要。</p></blockquote><p>对消费的计划和控制是财富积累的关键。因此，做预算和计划投资是十分必要的，作者调查的很多人都会进行预算规划，甚至精确到1美元。</p><blockquote><p>计划工作只是构筑财富大厦的许多关键部件中的一件。大多数财富积累能手都规定有一套系统的计划工作日程。每周、每月、每年，他们都计划自己的投资。</p></blockquote><p>一些不是那么富裕的人认为没有必要，甚至鄙视：</p><blockquote><p>然而她快乐吗？这是谈到节俭的百万富翁时别人经常向我们提出的问题。是的，她快乐。她有金钱上的保障。</p></blockquote><p>这是因为：</p><blockquote><p>金钱上充分自立的人，要比那些处于同样的收入年龄组而没有金钱上的保证的人更加快乐。</p></blockquote><p>而这些鄙视富翁的人，花费在计划和管理上的时间远远不够，这或许也是他们未能致富的原因吧。</p><p>在开展计划时，我们这些未能致富的人们总有一些误解：进行计划就意味着生活标准的下降，也就是生活的不好。而在我们一般看来，所谓生活的好，意味着通过消费各种高级商品来展示自己的高收入。但是之前我们也提到，本书的富翁对这种行为从来不感冒。</p><p>有时即便是受过高等教育的人，也不一定认可计划的重要性或者制定好计划，</p><blockquote><p>这是因为受过良好教育的高收入者并不会自动转化为能在金钱上充分自立的人。这需要有计划工作和作出自我牺牲。</p></blockquote><blockquote><p>如果你的目标是要达到金钱上的充分自立，那该怎样做呢？你的计划应该是，牺牲现在的消费，取得将来金钱上的充分自立。</p></blockquote><h3 id="富贵不能淫"><a href="#富贵不能淫" class="headerlink" title="富贵不能淫"></a>富贵不能淫</h3><p>这些富翁的一个显著的特点是，即便已经达到本书中所说的财务独立，但是他们依然简朴，属于是“富贵不能淫”了。我觉得做到这一点还是挺难的，有些在奋斗的开始阶段，尚能做到上述中提到的各种品质，但是达到一定的层次后，开始抛弃之前的行为。</p><p>但是这些富翁，即便已经富裕了：</p><ul><li>仍然买二手汽车；</li><li>处在普通居民区；</li><li>为了200美元参加本书中的调查；</li><li>不吃昂贵的食品；</li></ul><p>这里有必要提一点他们的看法，<strong>一件超出当前财富水准的物品是不能单独存在的</strong>。举例来说，你在农村的房子里挂了一幅梵高的画，显然是不太合适的，你要买个符合风格的房子，配一辆符合这个房子的车，出入符合这辆车的餐厅，等等，所以不只是一幅画的事情。</p><p>因此，这些人</p><blockquote><p>克己自律，低消费，有危机感，能刻苦工作。</p></blockquote><h1 id="家庭与子女的关系"><a href="#家庭与子女的关系" class="headerlink" title="家庭与子女的关系"></a>家庭与子女的关系</h1><p>这些能够致富的人，其所在的家庭也对其有很大的影响。</p><blockquote><p>一个家庭有两种不同的用钱习惯，是不可能积累大量财富的。</p></blockquote><p>在这里，我将其分为了妻子和下一代。但是这些人的父母对孩子也起到了决定性的影响，一般来说，父母节俭的人，其孩子一般也会很节俭。但也不一定，这点在下文中展开说明。</p><h2 id="妻子"><a href="#妻子" class="headerlink" title="妻子"></a>妻子</h2><blockquote><p>我们的妻子在金钱上远比我们保守得多。</p></blockquote><p>本书中提到的大多数富翁的妻子比他们自己要更节俭。甚至作者还问了3个问题：</p><ol><li>你们的父母很节俭吗？</li><li>你节俭吗？</li><li>你的配偶比你更加节俭吗？</li></ol><p>多数的富翁给出的都是肯定的回答。这种情况对我们寻找自己的配偶可能有一点点启示：</p><blockquote><p>如果跟爱浪费的人结婚，大多数人都决不可能在一个世代就变为富翁。一对配偶如果有一方是高消费者，那就不能积累财富。</p></blockquote><p>我觉得这一点在当前的中国社会也是很有借鉴，虽然男主外女主内的格局逐渐被打破，女性的家庭地位随着经济地位的上升也得到提升，但是操心家庭事务的仍然是多数的女性，如果她是一个大手大脚的人，显然你的日子不会好过。</p><h2 id="下一代"><a href="#下一代" class="headerlink" title="下一代"></a>下一代</h2><p>龙生龙，凤生凤，老鼠的孩子会打洞。我们一般认为富翁的孩子仍然是富翁，但是情况并不一定如此。</p><blockquote><p>一般说来，成年子女接受的美元越多，他们的财富积累就越少；而给的美元越少，积累则越多。</p></blockquote><p>这与我们的认知有差别。书中为我们揭示了部分原因：</p><ul><li>富翁们倾向于向不能经济独立人提供更多经济支持，因此逻辑是颠倒的；</li><li>富翁有一种情结：不想让孩子经历自己经历过的苦日子和风险；</li></ul><p>因此，这些富翁经常向孩子转钱，这些钱一般都会被拿来消费，即富翁自己避免了消费陷阱，但是自己的孩子没有成功摆脱这种陷阱，一个讽刺。</p><p>但是，更一般的是，</p><blockquote><p>父母积累的财富越多，他们的成年子女就越有可能在经济上得到更多的训练。</p></blockquote><p>这种也是符合我们的认知的。</p><h3 id="为什么接受经济支持的人更弱呢？"><a href="#为什么接受经济支持的人更弱呢？" class="headerlink" title="为什么接受经济支持的人更弱呢？"></a>为什么接受经济支持的人更弱呢？</h3><p>作者探索了那些从父母那里拿到更多钱的人，为什么经济会更差？</p><ol><li>从天而降的财富多用于消费，而不是储蓄和投资；</li><li>这些人未将自己的财富与父母分割，认为父母的就是自己的；</li><li>这些人本来财务状况就不好，才会得到更多的支持；</li><li>他们的投资聊胜于无；</li></ol><h3 id="应该给下一代做-留什么呢？"><a href="#应该给下一代做-留什么呢？" class="headerlink" title="应该给下一代做/留什么呢？"></a>应该给下一代做/留什么呢？</h3><p>一些经验和原则：</p><ol><li>告诉他们：不管你有多少收入， 生活永远要多入少出；</li><li>教会他们钓鱼，而不是直接给他们鱼；</li><li>教会孩子节俭；</li><li>让他们自己做决策，吃苦头；</li><li>自律地生活；</li><li>不要给出承诺：我的钱全部留给你；</li><li>有勇气尝试，即便失败也好；<blockquote><p>当你把全部心思都放进去的时候，你能干出些什么来，那是很不可思议的。</p></blockquote></li><li>教导他们靠自己生活；<blockquote><p>应为子女创造一种环境，使独立的思想和业绩受到尊敬，个人的成就受到珍惜，责任心才能得到应有的报偿。不错，生活中最重要的常常是自由。要教育你的子女依靠自己生活。</p></blockquote> 孩子也应该避免成为父母的经济奴隶，因为在经济上受制于别人，你的精神也受制于人。</li><li>不要告诉他们：自己的家庭很富裕；</li><li>父母对孩子的教导要与父母自己的行为一致；<blockquote><p>行动比规则更有号召力；规则只是言词，不是行动。</p></blockquote></li><li>绝不把给钱作为谈判策略的一部分<blockquote><p>给予，是因为爱，甚至是出于义务、责任或仁慈。父母如果采用高压的谈判策略，常常会失去成年子女的尊敬与爱戴。</p></blockquote></li><li>不参与成年子女家事；</li><li>不要试图与子女竞争；不夸耀自己的学历，不炫耀自己的财富。</li><li>强调子女的成就，促使他们拼搏奋斗；</li><li>告诉他们：很多东西比金钱更宝贵；</li></ol><h1 id="努力的方向"><a href="#努力的方向" class="headerlink" title="努力的方向"></a>努力的方向</h1><h2 id="瞄准富人"><a href="#瞄准富人" class="headerlink" title="瞄准富人"></a>瞄准富人</h2><p>跟着金钱走，是富翁给出的建议，谁有最多的金钱，也是富人，因此这些人提供服务，是致富的便捷通道。作者在书中提到的几个方向，可能在中国并不能适用，但是这个原则是没错的，尤其现在对高质量保姆、育婴、家政等都需求很大。</p><h2 id="选好职业"><a href="#选好职业" class="headerlink" title="选好职业"></a>选好职业</h2><p>另外一个建议是：选择好的职业，书中提到很多的富翁作为企业家，并不希望自己的孩子从事相同的职业，而是希望他们从事医生、律师等职业，这里引用书中的一个例子：</p><blockquote><p>我们问一位在二战期间因纳粹集中营大屠杀而逃离欧洲的富人，为什么他所有的成年子女都是自营的专业人员？他的回答是：“他们能拿走你的企业，但是他们拿不走你的才识！”</p></blockquote><p>因此选择一个需要丰富学识的职业会给你致富之路助力。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这本书是1998年出版的，已经过去将近25年了，但是其中的原则和经验一点也不过时，甚至我们认为再过100年，也不过时。</p><p>当今的社会风潮显然在朝着书中富人生活的相反面发展，也给了部分人机会。当然，在书中作者有预见性地提到，一旦你从事书中描述的富翁那样生活，大概率会遇到各种刁难和鄙视，或者与当前的社会环境格格不入，不过，管他呢！</p><blockquote><p>一种敌意环境，即使是在美好人群之中，对于狗——或者对于财富积累能手来说，也不是一个好地方。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 致富 </tag>
            
            <tag> 投资 </tag>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reference and Pointer</title>
      <link href="/2022/09/18/bian-cheng-zhi-dao/reference-he-pointer/"/>
      <url>/2022/09/18/bian-cheng-zhi-dao/reference-he-pointer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💡 本篇的内容来自C++ Primer中的2.3节</p></blockquote><p>在C++中除了基本数据类型，还包括复杂数据类型，主要有2种：</p><ul><li>reference 引用</li><li>pointer 指针</li></ul><blockquote><p>A compound type is a type that is deﬁned in terms of another type.</p></blockquote><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p>Technically speaking, when we use the term reference, we mean “lvalue reference.”</p></blockquote><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ul><li>A reference deﬁnes an <strong>alternative name</strong> for an <strong>object</strong>;</li><li>A reference type “refers to” another type;</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal <span class="token operator">=</span> ival<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// right, refVal refers to(is another name for) ival</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal2<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// error, 引用必须被初始化</span></code></pre><h3 id="定义过程"><a href="#定义过程" class="headerlink" title="定义过程"></a>定义过程</h3><ul><li>引用只能是object的别名；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal4 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10 不是变量</span></code></pre></li><li>引用的类型与其所指向的对象的类型要匹配；<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal5 <span class="token operator">=</span> dval<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误，类型不匹配</span></code></pre></li></ul><h2 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h2><p>对于基本类型的变量而言，当初始化一个变量时，用于初始化的对象的值被拷贝到创建的对象上。但是当创建reference时，不拷贝该值，而是将reference与该对象绑定。</p><p>这一点对于需要性能的场景很重要，不希望拷贝数据，只希望引用同样的数据，这样避免了拷贝操作。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>所有对象引用的声明都必须要初始化；</li><li>引用一旦初始化，没有任何方式能够解绑其引用另外一个对象，即整个生命周期和初始化对象“死磕”；</li><li>当引用与初始化对象绑定后，所有针对该引用操作引起的变化都会反映到初始化对象上；<pre class=" language-cpp"><code class="language-cpp">refVal2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此时，ival也是2；</span></code></pre></li><li>Reference is not an object, and it is just another name for an already existing object.  因此我们不会定义reference的reference，因为reference只能定义object的别名；</li><li>一个技巧：由于reference使用的&amp;后续的获取变量的地址时也会使用，因此会让人困惑，  因此一种读法是，如下：<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>val <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//val refers to a int variable a. 从右向左读，&amp;换成refer to </span></code></pre></li></ul><h1 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h1><h2 id="含义说明"><a href="#含义说明" class="headerlink" title="含义说明"></a>含义说明</h2><blockquote><p>A pointer is a compound type that “points to” another type.</p></blockquote><p>与reference对比：</p><ul><li>a pointer is an object in its own right.<ul><li>reference is not an object;</li></ul></li><li>Pointers can be assigned and copied;</li><li>a single pointer can point to several different objects over its lifetime;</li><li>a pointer need not be initialized at the time it is deﬁned;</li></ul><h2 id="声明和使用方式"><a href="#声明和使用方式" class="headerlink" title="声明和使用方式"></a>声明和使用方式</h2><ul><li>使用<code>*</code><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// dp1是指针，dp是浮点数</span><span class="token keyword">double</span> dp<span class="token punctuation">,</span> <span class="token operator">*</span>dp1<span class="token punctuation">;</span></code></pre></li><li>the types of the pointer and the object to which it points must match;<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> dval<span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token operator">*</span> pd <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: initializer is the address of a double </span><span class="token keyword">double</span> <span class="token operator">*</span> pd2 <span class="token operator">=</span> pd<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok: initializer is a pointer to double </span><span class="token keyword">int</span> <span class="token operator">*</span> pi <span class="token operator">=</span> pd<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: types of pi and pd differ </span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: assigning the address of a double to a pointer to int</span></code></pre></li><li>use the dereference operator (the * operator) to access that object;<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span> p<span class="token punctuation">;</span></code></pre></li><li>同时定义多个变量时的误解<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>i<span class="token punctuation">,</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// i为指向int的指针，j为int变量，不是指针； </span></code></pre>  这种写在一起时会引发误解，两种方法可以避免：<ol><li>写成 <code>int *i</code>, 而不是 <code>int* i</code>;</li><li>写在两个声明语句中，就不会误解；</li></ol></li></ul><h2 id="Pointer指向对象地址"><a href="#Pointer指向对象地址" class="headerlink" title="Pointer指向对象地址"></a>Pointer指向对象地址</h2><ul><li>A pointer holds the address of another object;</li><li>Because references are not objects, they don’t have addresses. Hence, <strong>we may not deﬁne a pointer to a reference</strong>.</li><li>Because a pointer is an object, we can deﬁne a reference to a pointer.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>r <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// r is a reference to the pointer p</span>r <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 更改r所引用对象的值</span></code></pre></li><li>we can store the address of a pointer in another pointer as pointers are also objects.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p is a pointer to val;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>pp <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pp is a pointer to pointer to p.</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"val is "</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">" by val"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"val is "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> <span class="token string">" by *p"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"val is "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token operator">*</span>pp <span class="token operator">&lt;&lt;</span> <span class="token string">" by **pp"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre>  对于存在多种符号，如<code>&amp;</code>，<code>*</code>等涉及reference或者pointer的声明时，遵守以下原则就不会出错；<ul><li>The easiest way to understand the type of r is to read the deﬁnition right to left.</li><li>The symbol closest to the name of the variable (in this case the &amp; in &amp;r) is the one that has the most immediate effect on the variable’s type.</li></ul>  将<code>*</code>称为pointer to, <code>&amp;</code>称为reference to.</li></ul><h2 id="Pointer-Value"><a href="#Pointer-Value" class="headerlink" title="Pointer Value"></a>Pointer Value</h2><p>指针在实践中很容易出错，但是pointer的value只能是下面4种之一：</p><ol><li>point to an object; （正常，我们希望的状态）</li><li>point to the location just immediately past the end of an object; 这种情况如何理解呢？比如在一个数组中，最后一个元素之后的位置，在循环和迭代器中，我们会有指向最后元素之后的元素的指针，可以阅读<a href="https://stackoverflow.com/questions/21850108/what-is-pointer-past-the-end-of-an-object-means">这篇文章</a>；</li><li>null pointer: not bound to any object; （注重注意的情况）</li><li>invalid: 除了上述三者之外的所有情况；（极力避免）<ul><li>It is an error to copy or otherwise try to access the value of an invalid pointer.</li><li>The result of accessing an invalid pointer is undeﬁned.</li></ul></li></ol><h2 id="Null-Pointers"><a href="#Null-Pointers" class="headerlink" title="Null Pointers"></a>Null Pointers</h2><h3 id="具体含义"><a href="#具体含义" class="headerlink" title="具体含义"></a>具体含义</h3><blockquote><p>A null pointer does not point to any object.</p></blockquote><h3 id="获取null-pointers"><a href="#获取null-pointers" class="headerlink" title="获取null pointers"></a>获取null pointers</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// method 1</span><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// method 2</span><span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// method 3</span><span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 必须#include &lt;cstdlib></span></code></pre><p>在这三种方法中：</p><ul><li>法1最被推荐使用，新的标准，可以转换为任意其他的指针类型；</li><li>法2是之前的方法；  一种“骚操作”：<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">int</span> zero <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pi <span class="token operator">=</span> zero<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 错误，不允许将int赋值给pointer</span></code></pre></li><li>法3等价于法2，继承自C语言，<code>NULL</code>是一个preprocessor variable，在compiler编译之前，会将其替换为0；</li></ul><blockquote><p>💡 强烈建议：在pointer声明时，最好初始化，以免出现未定义的pointer；如果不定义，最好使用nullptr赋值。</p></blockquote><h2 id="Pointer的其他操作"><a href="#Pointer的其他操作" class="headerlink" title="Pointer的其他操作"></a>Pointer的其他操作</h2><h3 id="条件语句中"><a href="#条件语句中" class="headerlink" title="条件语句中"></a>条件语句中</h3><blockquote><p>if the pointer is 0, then the condition is false, any nonzero pointer evaluates as true.</p></blockquote><p>只要pointer为null pointer, 其条件判定即为0；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p is null pointer"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p is not null poiner"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出：p is not null poiner</span></code></pre><h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><p>Given two valid pointers of the same type, we can compare them using the equality (==) or inequality (!=) operators.</p><ul><li>Two pointers are equal if they hold the same address and unequal other-wise.</li><li>Two pointers hold the same address (i.e., are equal)<ul><li>if they are both null,</li><li>if they address the same object,</li><li>or if they are both pointers one past the same object.</li></ul></li><li>Using an invalid pointer as a condition or in a comparison is undeﬁned. 这种情况指的是，pointer values中的第四种情况。</li></ul><h2 id="void-Pointers"><a href="#void-Pointers" class="headerlink" title="void * Pointers"></a><code>void *</code> Pointers</h2><ul><li>The type <code>void *</code> is a special pointer type that can hold the address of any object.</li><li>a <code>void *</code> pointer holds an address, but the type of the object at that address is unknown:</li></ul><blockquote><p>💡 之前我一直以为这是指向一个void地址，这个起名太奇怪了。</p></blockquote><p>虽然这种指针类型可以指向任意类型的指针，但是其只支持有限的操作。</p><ul><li>We can compare it to another pointer,</li><li>we can pass it to or return it from a function,</li><li>and we can assign it to another <code>void *</code> pointer.</li></ul><p>但是不可以：</p><ul><li>use a <code>void *</code> to operate on the object it addresses<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>vp <span class="token operator">=</span> p<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p points to "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vp points to "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>vp <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误</span></code></pre></li></ul><h1 id="对比Reference和Pointer"><a href="#对比Reference和Pointer" class="headerlink" title="对比Reference和Pointer"></a>对比Reference和Pointer</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul><li>Both pointers and references give indirect access to other objects.</li></ul><blockquote><p>💡 在Reference和Pointer中，&amp;和*出现的频率很高，但是在不同context中代表的含义不同，这一点尤其需要注意。</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// &amp;代表r refers to i</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// *代表p points to i, &amp;代表取i的地址</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// &amp;代表r2 refers to the object which p points to.</span></code></pre><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><table><thead><tr><th></th><th>Reference</th><th>Pointer</th></tr></thead><tbody><tr><td>内存地址</td><td>不是独立对象，也就没有独立的内存地址，而是附属在特定的对象上。</td><td>作为独立的对象，像基本类型的对象一样存在内存地址。</td></tr><tr><td>可变性</td><td>作为引用本身，无法改变成针对另一个对象的引用；但是可以改变引用对象本身的值。</td><td>可以改变指向对象的值，也可以改变指向的对象。</td></tr><tr><td>初始化</td><td>声明时，必须初始化。</td><td>声明时，不必初始化，但是如果不初始化，则会有一个undefined的值。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引用 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-13-01-Ray Tracing - Basics &amp; Methods</title>
      <link href="/2022/09/18/ji-suan-ji-tu-xing-xue/games/games101-13-01-ray-tracing-basics-methods/"/>
      <url>/2022/09/18/ji-suan-ji-tu-xing-xue/games/games101-13-01-ray-tracing-basics-methods/</url>
      
        <content type="html"><![CDATA[<p>光线追踪和光珊化是两个不同的成像方法。</p><h1 id="为什么用Ray-Tracing"><a href="#为什么用Ray-Tracing" class="headerlink" title="为什么用Ray Tracing"></a>为什么用Ray Tracing</h1><ul><li>在rasterization中一些事情不能很好的处理：<ol><li>不能很好地处理global effect<ul><li>如上一节中提到的shadow mapping, 只能实现hard shadow;</li><li>glossy reflection 光滑的反射；</li><li>indirect illumination 间接光照</li></ul> 特别是，当光经过多次反射才能到达人眼的场景下，光栅化的效果都不太好； <img src="/images/games101/13/bad_rasterization.png" alt="光珊化做不好的事情"></li><li>光栅化很快，但是质量相对较低；</li></ol></li><li>Ray tracing 很准确，但是非常慢  光栅化可以realtime，而ray tracing一般是offline。  一般下，在实际场景中渲染一帧需要10k CPU core hours. </li></ul><h1 id="基本Ray-Tracing算法"><a href="#基本Ray-Tracing算法" class="headerlink" title="基本Ray Tracing算法"></a>基本Ray Tracing算法</h1><h2 id="Light-Rays定义"><a href="#Light-Rays定义" class="headerlink" title="Light Rays定义"></a>Light Rays定义</h2><p>在图形学中一些假设：</p><ul><li>光线直线传播；</li><li>两个光线相遇时，不会发生碰撞；</li><li>reciprocity: 光线是可逆的, 实际是从光源经过各种反射到眼睛，但是我们可以认为是从眼睛发出回溯到光源；</li></ul><h2 id="首先——Ray-Casting-光线投射"><a href="#首先——Ray-Casting-光线投射" class="headerlink" title="首先——Ray Casting 光线投射"></a>首先——Ray Casting 光线投射</h2><p>光线投射从眼睛开始，望向物体，假设在眼睛面前存在一个屏幕，里边被分为各种像素点。</p><ol><li>将眼睛和物体连接起来的光线与屏幕相交的地方形成一个点，多个点形成一个image;</li><li>并将投射到物体上的光线回溯到光源，以确定光源能看见物体上的该点，从而验证有无投影；</li></ol><blockquote><p>💡 在光线追踪中，使用的是<a href="https://en.wikipedia.org/wiki/Pinhole_camera_model">Pinhole camera model</a>，即眼睛视为点光源。</p></blockquote><h3 id="第一步：generate-eye-rays"><a href="#第一步：generate-eye-rays" class="headerlink" title="第一步：generate eye rays"></a>第一步：generate eye rays</h3><p>从眼睛开始，望向物体，得到<strong>最近</strong>的物体上的点。一条eye ray可以与很多点相交，但是这一步只取最近的点，相当于做了<strong>深度测试</strong>。</p><p><img src="/images/games101/13/generate_ray.png" alt="生成光线"></p><h3 id="第二步：Shading-pixels"><a href="#第二步：Shading-pixels" class="headerlink" title="第二步：Shading pixels"></a>第二步：Shading pixels</h3><p>将获得的距离屏幕最近的点与光源相连，确定该点是否可见。然后对于该最近的点而言，其得到了两条线，从而可以确定法线，以便利用着色模型(Blinn Phong Model等)完成颜色的计算，然后写会到屏幕对应的像素上。</p><p><img src="/images/games101/13/basic_rt.png" alt="Shading pixels"></p><p>上述简单的光线追踪：</p><ul><li>基本可以达到光栅化一样的效果；</li><li>但是光线只能bounce一次；</li></ul><h1 id="Recursive-Whitted-Style-Ray-Tracing"><a href="#Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="Recursive(Whitted-Style) Ray Tracing"></a>Recursive(Whitted-Style) Ray Tracing</h1><p>为了解决上述模型中光线只能弹射一次的问题。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当eye ray射出来后，照到一个玻璃球上，会出现反射和折射，在一个点上可以无限地bounce。</p><p>在这种情况下，计算着色值的方式与上述模型不同。在上边只会计算一个最近点与光源相交后得到的着色值，现在需要计算所有的点与光源相连后的着色值，因此whitted-style下，需要将每个弹射点计算得到的着色只加到一起写到对应的像素上（除了阴影下的点）。</p><p>对每一个弹射点都需要首先确定是否能被光源看见，来确定是否包含其贡献的着色值。</p><p><img src="/images/games101/13/ws_rt.png" alt="Recursive(Whitted-Style) Ray Tracing"></p><p>几个定义：</p><ul><li>primary ray: 与第1个弹射点对应的ray</li><li>secondary ray: 除了第1个弹射点对应的其他ray</li><li>shadow ray: 与光源连接的ray;</li></ul><h2 id="Ray-Surface-Intersection"><a href="#Ray-Surface-Intersection" class="headerlink" title="Ray-Surface Intersection"></a><strong>Ray-Surface Intersection</strong></h2><h3 id="Ray-equation"><a href="#Ray-equation" class="headerlink" title="Ray equation"></a>Ray equation</h3><p>光线在数学上的定义如下，</p><p><strong>Ray is defined by its origin and a direction vector.</strong></p><ul><li>光线起点 $\mathbf{o}$；</li><li>沿着方向的单位向量；</li></ul><p>$$<br>\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}; \quad 0 \le t \le \infty<br>$$</p><ul><li>其中，$t$为时间；</li></ul><h3 id="Ray-Intersection-With-Sphere"><a href="#Ray-Intersection-With-Sphere" class="headerlink" title="Ray Intersection With Sphere"></a><strong>Ray Intersection With Sphere</strong></h3><p>对于球的表达：</p><ul><li>定义球心 $\mathbf{c}$;</li><li>球上任意一点 $\mathbf{p}$；</li></ul><p>则对于球面上的任意一点表示如下，</p><p>$$<br>(\mathbf{p} - \mathbf{c})^2 - R^2 = 0<br>$$</p><p>当求解光线与球体的交点时，需要满足：</p><p>$$<br>(\mathbf{o} + t\mathbf{d} - \mathbf{c})^2 - R^2 = 0<br>$$</p><p>求解t即可，二次函数求解，要保证t为正实数。根据解的数量的不同可以有3种情况：</p><ul><li>相离：无解；</li><li>相切：一个解</li><li>相交：两个解</li></ul><h3 id="Ray-Intersection-With-Implicit-Surface"><a href="#Ray-Intersection-With-Implicit-Surface" class="headerlink" title="Ray Intersection With Implicit Surface"></a><strong>Ray Intersection With Implicit Surface</strong></h3><p>将情况推广到任意的隐式平面，对于任意平面，根据之前的几何部分的知识，表示如下：</p><p>$$<br>f(\mathbf{p}) = 0<br>$$</p><p>因为为了求解交点，得到如下表示：</p><p>$$<br>f(\mathbf{o} + t\mathbf{d}) = 0<br>$$</p><p>下一步就是利用各种数值计算的方法和软件完成计算即可。</p><h3 id="Ray-Intersection-With-Triangle-Mesh（显式表示）"><a href="#Ray-Intersection-With-Triangle-Mesh（显式表示）" class="headerlink" title="Ray Intersection With Triangle Mesh（显式表示）"></a><strong>Ray Intersection With Triangle Mesh（显式表示）</strong></h3><p><strong><code>简单的方法</code></strong></p><ul><li>将光线与每个三角形分别计算，带来的问题必然很慢。</li><li>这里我们，我们只考虑光线和三角形有0或者1个交点的情况，不涉及平行的情况。</li></ul><p>对于一个mesh，我们首先考虑针对一个三角形的交点求解，然后迭代即可。</p><p>将光线与三角形求交分解为2部分：</p><ol><li>ray-plane intersection;</li><li>test if hit point is inside triangle;</li></ol><p>根据高数中平面方程，可以通过平面的法线和面上的一点来确定平面本身。</p><blockquote><p>Plane is defined by normal vector and a point on plane.</p></blockquote><p>对于平面上的任意一点 $\mathbf{p}$，给定法线 \mathbf{N}和给定一点 $\mathbf{p}^{\prime}$，得到以下表示：</p><p>$$<br>(\mathbf{p} - \mathbf{p}^{\prime}) \cdot \mathbf{N} = 0<br>$$</p><p>得到表示，就可以求解交点了，满足如下条件：</p><p>$$<br>(\mathbf{p} - \mathbf{p}^{\prime}) \cdot \mathbf{N} = (\mathbf{o} + t\mathbf{d} - \mathbf{p}^{\prime})\cdot \mathbf{N} = 0<br>$$</p><p>得到：</p><p>$$<br>t = \frac{(\mathbf{p}^{\prime} - \mathbf{o}) \cdot \mathbf{N} }{\mathbf{d} \cdot \mathbf{N}}<br>$$</p><p>最后别忘了一步，判断t对应的交点是不是在三角形内部。</p><p><strong><code>Möller Trumbore Algorithm</code></strong><br>上面的方法所有简单，容易理解，但是过于繁琐。</p><p>有一种快速的方法，可以一下得到答案。</p><blockquote><p>📌 一种思考方式：三角形内部一点可以使用重心坐标表示，因此判定光线与三角形相交，就可以将其表示为重心坐标的形式。</p></blockquote><p>$$<br>\mathbf{o} + t\mathbf{d} = (1- b_1-b_2) \mathbf{p}_0 + b_1\mathbf{p}_1 + b_2\mathbf{p}_2<br>$$</p><p>这个方程本质上是求解线性方程组，使用<a href="https://en.wikipedia.org/wiki/Cramer%27s_rule">Cramer’s rule</a>完成求解（还记得这是当初学线性代数时第一个主要内容）。</p><p>完成求解后需要验证：</p><ul><li>t为正实数</li><li>$b_1, b_2, 1-b_1 - b_2$ 为正实数，保证在三角形内部；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ray Tracing </tag>
            
            <tag> Recursive Ray Tracing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日本出了问题：《东京贫困女子》呈现的社会现象</title>
      <link href="/2022/07/15/du-shu-gan-wu/ri-ben-chu-liao-wen-ti-dong-jing-pin-kun-nu-zi-cheng-xian-de-she-hui-xian-xiang/"/>
      <url>/2022/07/15/du-shu-gan-wu/ri-ben-chu-liao-wen-ti-dong-jing-pin-kun-nu-zi-cheng-xian-de-she-hui-xian-xiang/</url>
      
        <content type="html"><![CDATA[<p>这本书我是去年开始读的，读这本书的契机是因为之前看过一个我个人觉得很有意思的日剧——《暗金丑岛君》。但是影视总有一些虚构的成分，所以想了解一些真实的事件，恰好发现这本书。去年刚开始读的时候，觉得有点压抑，一度读不下去，恰好又赶上毕业的事情，耽搁了，现在毕业了又重新拿起来继续读。</p><p><img src="/images/%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F/%E4%B8%9C%E4%BA%AC%E8%B4%AB%E5%9B%B0%E5%A5%B3%E5%AD%90/book.jpg" alt="东京贫困女子"></p><p>总的来说，这本书没有明显的叙事结构，基本是按照作者采访的真实事件整理而成。作为一本纪实文学，书中的文字很平和，没有过多的华丽的辞藻，但是从这些文字中，你能体会到阵阵寒意，尤其这些事情都是发生在公认为发达国家的日本。</p><p>如果你想了解当今和未来的中国，这本书你应该读一下，或为解答内心的疑虑，或者为艰难的未来做准备。如果你能够接受日剧，我同时也推荐一下《暗金丑岛君》这部日剧，两者之间有很多的共同点。</p><p>本书中共涉及了19个具体的女子贫困的案例，由3年的采访记录而来。书中以对话的形式叙述了每个人的悲惨遭遇，以及造成这些问题的可能原因，包括但不限于政府的制度、整个社会的氛围、家庭的环境、甚至历史的文化惯例等等。从阅读体验上来说，读者可以从任意感兴趣的章节阅读，因为每个人的经历都是独立的。</p><h1 id="日本出问题了"><a href="#日本出问题了" class="headerlink" title="日本出问题了"></a>日本出问题了</h1><p>作者作为一个自由撰稿人，一直在对成人影片女优和风俗业进行采访，因此本文的视角可能对外国的读者有点奇特。所有的缘起在于作者在采访中逐渐意识到：</p><blockquote><p>虽然没有意识到这是一项实地调研，但我在2006年到2007年间，渐渐产生了“日本社会是不是出问题了”这种模糊的不安感。</p></blockquote><p>我们虽然在新闻和报纸上经常看到“失去的30年”等说法，但是作者从自己的经历提出了“日本出问题”这个观点，具体包括两件事情：</p><ul><li>作者自己经历的风俗报道：涌入这个行业的女子日益增多，但是收益却大幅下降；</li><li>作者自己经营了看护机构，可以视为国内的“养老院”：发现这种福利机构中却包含这更为黑暗的一面；</li></ul><p>因此书中在探讨贫困问题时，对这两个方面多种侧重。而对于贫困的原因，作者首先提出了一个观点：</p><blockquote><p>日本社会针对贫困的当事人有一种很强的责任自负的认识。</p></blockquote><p>对于这种观点，国内相比也有同样认知的人群，他们穷是因为他们不努力，这样的认识与教育程度无关，可能只是他们靠自己的努力幸运地摆脱了贫困。我想，在本书中，作者并不否定个人的原因导致贫困，但是更多地是强调这不是唯一的原因，甚至不是最重要的原因。因为“日本出问题了”才是导致这一切的原因。</p><h1 id="日本的贫困女子们"><a href="#日本的贫困女子们" class="headerlink" title="日本的贫困女子们"></a>日本的贫困女子们</h1><blockquote><p>贫困，是在出身和成长经历、家庭环境、健康状态、就业、政策、制度、个人和配偶的性格及人格等多重因素的影响下发生的。</p></blockquote><p>作者在书中着重描述了两类群体作为贫困女子的代表：</p><ul><li>一个是女大学生；</li><li>一个是离异的单身母亲；</li></ul><p>我们直觉感受，这两类人确实是会贫困的人群，但是书中陈述的事实显然超出了我的想象。</p><h2 id="女大学生们怎么了"><a href="#女大学生们怎么了" class="headerlink" title="女大学生们怎么了"></a>女大学生们怎么了</h2><blockquote><p>大学生，是真的没钱。大学校园，就是贫困的巢窟。</p></blockquote><p>作者如此的看法是中国学生们不能理解的（起码我开始不能理解）。中国的大学多是公立大学，而且有一个跟国外大学迥异的特点——大学越好，学费越便宜。学校从国家拿到的财政补贴越多，因此你上了一个好大学，多半不用为学费和生活费发愁。但是国外的好大学多数是私立，而是为了保持“独立性”，很少从国家直接拿补贴，因此这部分负担就由学生承担，因此国外的学生相比于国内学生的经济压力更大，尤其是父母不能提供支持的前提下。</p><blockquote><p>大学生的贫穷乃至贫困的背后，是父母一代收入的下降和原则上应由受益者承担的学费的持续上浮。</p></blockquote><p>而经济压力的加重多半与国家的经济出现问题有关，对此女大学生们的解决方法没有太多选择：</p><ul><li>征集干爹：</li><li>领取日本学生支援机构助学金：</li></ul><p>征集干爹就是所谓的援交，这种美化的说法并不能掩盖其中的艰辛。</p><blockquote><p>留言板上的干爹征集，其实就是卖身吧。现在和我保持联络的有两个人。都是40多岁，详细情况我不知道。我也不喜欢这些人。我们只是偶尔一块儿吃饭，上床，然后拿钱。不过，我完全不习惯这样……和特定的人多见几次面就觉得害怕，而且我本身也不想见他们。</p></blockquote><p>作者提到这样的目的是维持基本生活，因为之前在超市打工的薪水并不能满足这些女大学生的生活所需，而家庭无法提供任何支撑，超市时薪920日元（45RMB）,一天最多工作4小时，也就是180RMB，而一年的学费是53.58万日元（26000RMB）。怎么算就无法覆盖学费，因此去风俗店打工是逼不得已的选择。</p><blockquote><p>简单来说就是，一个从地方上来，且得不到父母资助的单身大学生，如果不去陪酒或做风俗业，就没法维系求学生活。</p></blockquote><p>虽然国家对学生求学提供了助学金制度，但是这种制度有一种资本家剥削穷人的感觉，在作者看来。</p><blockquote><p>助学金制度的设立，表面上是为了让贫困家庭的孩子也有机会接受高等教育。然而，让身后没有退路的贫困家庭的孩子们背负足以让他们个人破产的债务，事实上不仅不能利用高等教育来防止贫困的连锁效应，更会使不少学生进一步陷入负债的深渊。</p></blockquote><p>申请助学金制度有几个问题要考虑：</p><ul><li>一个是投入的成本无法获得回报；<blockquote><p>靠借款升学就等同于一种商业投资，如果不能得到大于投资的回报，就会出现问题，过度地投资就会导致破产。</p></blockquote>  日本经济的不景气，导致大学生并不能很容易的找到工作。</li><li>进一步加重自己的债务负担  因为助学金中存在最高3%的利息，有些人读完大学累计需要还款1000万日元（48.65万RMB），这对于刚进入社会的人无疑是一种极大的负担。</li></ul><p>助学金的负担无疑又将这些女大学生推向风俗行业，两者形成一种负向的反馈。</p><h2 id="单身母亲的无奈"><a href="#单身母亲的无奈" class="headerlink" title="单身母亲的无奈"></a>单身母亲的无奈</h2><p>离异、单身的母亲在任何国家都是显而易见的弱势群体，但像日本社会这样一旦离婚就立即变为贫困的现象仍然让人震惊。</p><p>书中通过案例列举了单身母亲面临的挑战：</p><ul><li>前夫不付抚养费：对于这种行为只能从道德上谴责，但是法律上却无法追究，我不明白日本的法律为何无法处理这种情况；</li><li>非正式雇佣，也就是“临时工”：这是单身母亲能找到最多的工作方式，没有任何保障、可以随时被解雇。在我们的印象里，日本都是“年功序列制”，这种文化在当今也是坚持不下去的。<blockquote><p>非正式雇用是自1999年《劳动者派遣法》实施并在2004年该法修订之后开始激增进而普及的一种雇用形态。</p></blockquote>  而非正式雇佣加剧了阶级分化，这一点对于女性过于残酷。<blockquote><p>企业一般很少会特意将非正式聘用的劳动者转成正式聘用，所以社会底层的人几乎没法爬上来。如此一来，贫困的固化使得“贫富差距”发展为“不同阶级”。</p></blockquote>  因为不用负任何责任，便催化了权力欺压和性骚扰等针对女性的恶性行为。<blockquote><p>如果正式员工问你的问题你没能答上来，就可能会被甩一句“那你明天不用来上班了”，然后立刻被解雇。我们管这个叫“出禁”。毕竟不是直接雇用的关系，所以被如此冷酷地对待也很正常。我们唯一的选择就只有遵守社员的命令，没有借口和怨言，绝对服从。</p></blockquote></li><li>年龄限制：即便是非正式雇佣，当超过了45岁，这些女性也彻底的没有了机会。这让我想起了国内的35岁门槛，也有一种同病相怜的感受。</li></ul><blockquote><p>日本对曾做过专职主妇的女性还有单亲家庭，都太严苛了，连一个人的基本生活都保障不了，还不给我们机会。</p></blockquote><p>这是植草女士对当今日本社会的抱怨，也揭示了政府或者社会在关注弱势群体方面的冷漠。</p><blockquote><p>即使受过高等教育，一个女性只要做了家庭主妇，社会就不会再给予她发挥自己能力和价值的机会了吗？不仅是工作，一旦被丈夫要求离婚，其结果就是，她会失去工作同时失去家人。</p></blockquote><p>这些单身母亲们的贫困几乎是100%的会传递到下一代，因为无法在经济上支持孩子们，他们的孩子只能上不好的学校，靠自己进入风俗店赚钱缴纳学费，然后重复女大学生们的生活，然后这种生活造成她们成年后对于家庭的不信任，因此离婚成了无法避免的选择，甚至是不婚。</p><h1 id="我们怎么办"><a href="#我们怎么办" class="headerlink" title="我们怎么办"></a>我们怎么办</h1><p>本书的作者强调了政府和社会制度在导致女性贫困方面扮演的负面角色，对于作者避而不谈自我原因导致的贫困，我一开始是无法认同的。但是设身处地思考，对于一个缺失家庭支持的16岁女孩，去上大学则要面临每年的学费和生活费，不上学则无法摆脱贫困，直接进入风俗行业，我们这些局外人无法轻松地说出“多打工赚钱，少花钱”这样的风凉话。</p><p>这本书对于我们有怎样的启发，我觉得是值得思考的问题。</p><p>日本是一个发达国家，其社会保障体系比我们要全面，这一点毋庸讳言。即便是在这样的社会，仍然存在书中描写的贫困人口，显然单靠国家的保障制度，无法使我们安全度过这一生，我们需要自己计划，才不会陷入无助和混乱。</p><p>虽然很多的国家制度，我们无法左右，如作者所言：</p><blockquote><p>日本的制度设计就是让女性在最低生活保障水准线上工作和生活。我只是运气好逃离了泥沼，还有很多普通的女性过得还不如贫民窟的人。</p></blockquote><p>虽然很痛苦，但是还要活下去，这是作者留下的感叹。如果你感到焦虑或者痛苦，可能还是经历的不够多，当看见书中人物的真实经历时，或许我们面对的并不是那么糟糕。</p>]]></content>
      
      
      <categories>
          
          <category> 读书感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
            <tag> 社会 </tag>
            
            <tag> 贫困 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Notion API+Github Actions回顾阅读的文章</title>
      <link href="/2022/05/22/xiao-lu-sheng-huo/li-yong-notion-api-github-actions-hui-gu-yue-du-de-wen-zhang/"/>
      <url>/2022/05/22/xiao-lu-sheng-huo/li-yong-notion-api-github-actions-hui-gu-yue-du-de-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每天看着不断推送的手机消息，明知道其中有价值的并不多，但是又怕错过有价值的信息，这种心态在当今是一种很普遍的心态。因此，面对这种局面，<a href="https://www.tmtpost.com/5947407.html">如何摆脱海量信息的冲击和无价值信息的禁锢</a>，是面对的一个艰巨的挑战。之前看到一篇文章——<a href="https://catcoding.me/p/get-better-info/">优化自己的信息源</a>，建议主动获取信息。回想我的信息管理方法，差不多也是按照这个思路来的，一般是：</p><ul><li>收集：初步加上标签和分类；</li><li>预处理：检视阅读，找出其中要点；</li><li>深度阅读：阅读，加上摘要和思考内容；</li></ul><p>最后这些标注和内容都汇总到我的notion数据库中，但是逐渐发现缺乏回顾的环节，手动去获取这些积累的信息，也存在实际操作性不强的问题，<a href="https://sspai.com/post/71518">我是如何艰难地克服「效率成瘾」的？</a>建议我们要自动化一些操作来提升效率。</p><p>因此，我希望通过自动化的方法来回顾我看过和思考的内容。</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><ol><li>Notion API自动化获取信息；</li><li>Github Actions提供workflow；</li><li>微信接收——Notion打开；</li></ol><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>信息存储在Notion中，因此使用其提供的API实现自动化的获取；</li><li>具体的回顾方式：每天定时发送，因此需要事件触发机制——定时周期发送，这种实现方法有很多，本文采用Github Actions，因为免费且可用性很强；</li><li>接收方式：微信接收最方面，但是其SDK存在一些麻烦，因此一种间接的方式是通过发邮件到QQ邮箱，然后在微信中接收，然后利用默认浏览器打开Notion的链接；</li></ol><h1 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h1><h2 id="Notion-API"><a href="#Notion-API" class="headerlink" title="Notion API"></a>Notion API</h2><blockquote><p>本文不会介绍Notion。</p></blockquote><p>这里<a href="https://developers.notion.com/reference/post-database-query">使用Notion API来查询数据库</a>。其中注意使用的是filter和sort。其中需要考虑的问题是：</p><ul><li>查询API endpoints的方法；<ul><li><a href="https://ralphjsmit.com/api-endpoint-webhook-github-actions">在workflow中使用curl</a>：简单、直接，但是不能进行复杂逻辑的操作，比如生成随机数；</li><li>使用JavaScript查询：这个可以直接用原生js查询，也可以<a href="https://github.com/makenotion/notion-sdk-js">使用Notion提供的SDK</a>。</li></ul></li><li>API响应结果的解析<ul><li>这个需要进行测试，我感觉Notion给出的API文档说的不够清楚，需要自己去试，可能会出现很多问题；</li><li>这里我使用postman进行接口的测试；</li><li>还有一个要吐槽的是：Notion API中好像没有获取整篇文档的接口和选择，只能获取page的url；</li></ul></li></ul><h2 id="Github-Actions"><a href="#Github-Actions" class="headerlink" title="Github Actions"></a>Github Actions</h2><h3 id="1-触发事件"><a href="#1-触发事件" class="headerlink" title="1. 触发事件"></a>1. 触发事件</h3><ol><li>手动出发：便于调试；</li><li>定时触发：<a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule">schedule</a> 其中需要crontab表达式，不太了解的可以参考<a href="https://crontab.guru/">这里</a>。</li></ol><h3 id="2-设计actions"><a href="#2-设计actions" class="headerlink" title="2. 设计actions"></a>2. 设计actions</h3><p>本文设计了两个workflow，其实也不一定这样设计，主要我是为了多了解一下Github Actions的使用，如果你觉得麻烦可以放到一个workflow里，说到这里，想起之前看到的一篇文章——<a href="https://juejin.cn/post/6898953413250252814">新技术学习不完全指北：以 Rust 为例</a>。其中有一个观点，<strong>超纲训练是巩固知识的可靠方式，</strong>我这里也算超纲训练一下。</p><p>第一个workflow用来获取Notion中的信息，使用Notion提供的JavaScript SDK实现，具体包括：</p><ul><li>查询Notion database，并根据属性过滤和排序文章列表，以实现随机获取文章；</li><li>生成文章摘要模板，用于后续的邮件发送；</li></ul><p>第二个workflow主要是利用上一个workflow生成的信息并发送邮件，其中需要实现：</p><ul><li>编排不同的jobs；</li><li>获取jobs之间共享的信息，并发送出去：这里使用<a href="https://github.com/dawidd6/action-send-mail">已有的actions完成邮件的发送</a>；</li></ul><h1 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h1><h2 id="重用workflow"><a href="#重用workflow" class="headerlink" title="重用workflow"></a>重用workflow</h2><p>由于本文设计了两个workflows，从程序设计的角度看，其实是为了解耦以实现重用已有的workflow。类似于函数的设计，需要遵从一定的规范，比如：为了安全性，有些函数通过加限定符规定只能被同一个模块下的函数调用。Github Actions中也有类似的规定，与其说这些workflow像函数，不如说它们更像RPC。每个workflow都可以包含一个或者多个jobs，也就可以视为一个或者多个进程。</p><p>为了重用可共享的workflow，要求：</p><ul><li>需要复用的workflow支持 <code>workflow_call</code> 出发事件；<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> notion<span class="token punctuation">-</span>article<span class="token punctuation">-</span>query<span class="token comment" spellcheck="true"># Controls when the workflow will run</span><span class="token key atrule">on</span><span class="token punctuation">:</span>  <span class="token key atrule">workflow_call</span><span class="token punctuation">:</span></code></pre></li></ul><p>这样，此workflow才能在别的workflow中使用，该workflow只能在别的workflow的jobs中使用，而不是steps。并且<a href="https://docs.github.com/en/actions/using-workflows/reusing-workflows#access-to-reusable-workflows">需要满足一定的条件</a>，即如下其一：</p><ul><li>两个workflows需要在同一个目录下；</li><li>被重用的workflow需要存储在共有仓库并且组织允许你使用这些公有仓库；</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> notion<span class="token punctuation">-</span>article<span class="token punctuation">-</span>review<span class="token key atrule">on</span><span class="token punctuation">:</span>  <span class="token key atrule">schedule</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">cron</span><span class="token punctuation">:</span> <span class="token string">'0 4 * * *'</span>  <span class="token key atrule">workflow_dispatch</span><span class="token punctuation">:</span><span class="token key atrule">jobs</span><span class="token punctuation">:</span>  <span class="token key atrule">article-query</span><span class="token punctuation">:</span>    <span class="token key atrule">uses</span><span class="token punctuation">:</span> ./.github/workflows/notion<span class="token punctuation">-</span>article<span class="token punctuation">-</span>query.yml    <span class="token key atrule">secrets</span><span class="token punctuation">:</span> inherit  <span class="token key atrule">article-review</span><span class="token punctuation">:</span>        <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest</code></pre><p>更多复杂的功能可以参考<a href="https://docs.github.com/en/actions/using-workflows/reusing-workflows">Github Actions的文档</a>。</p><h2 id="jobs之间共享数据"><a href="#jobs之间共享数据" class="headerlink" title="jobs之间共享数据"></a>jobs之间共享数据</h2><p>首先从直觉上来看，不同的jobs可能在不同的虚拟机上，因此通过文件等方式是无法完成数据是共享的，这与RPC也是类似的。照着这个思路来想：</p><ul><li>引入第三方<ul><li>使用缓存服务器：如Redis，在Github Actions可以使用<a href="https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows">Cache</a>，官方提供了可以<a href="https://github.com/marketplace/actions/cache">直接使用的Cache Action</a>；</li><li>使用文件上传和下载：在Github Actions中<a href="https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts">使用Artifacts</a>实现；</li></ul>  两者的区别主要是：<blockquote><p><strong>Caching</strong> is used to re-use data/files between jobs or workflows while <strong>Artifacts</strong> are used to save files after workflow ended.</p></blockquote>  可以参考<a href="https://levelup.gitconnected.com/github-actions-how-to-share-data-between-jobs-fc1547defc3e">这里</a>。</li><li>workflow执行返回<ul><li>使用命令行：定义jobs的输出可以使用命令行的方式，<a href="https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs">官方直接给出例子</a>，其中的命令是Github Actions专有的命令，可以参考文档 <a href="https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions">Workflow commands for GitHub Actions</a>，告诉你怎么完成output的设置；<pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"::workflow-command parameter1={data},parameter2={data}::{command value}"</span></code></pre>  这一点本文没有使用。</li><li>使用JavaScript：这种适合复杂逻辑的场景，本文使用这种方式，通过引入<code>@actions/core</code> 完成输入和输出的设置，本文利用这个实现文章摘要的传递。<pre class=" language-bash"><code class="language-bash">const core <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"@actions/core"</span><span class="token punctuation">)</span><span class="token keyword">let</span> context <span class="token operator">=</span> `  <span class="token operator">&lt;</span>html<span class="token operator">></span>   <span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta http-equiv<span class="token operator">=</span><span class="token string">"Content-Type"</span> content<span class="token operator">=</span><span class="token string">"text/html; charset=utf-8"</span><span class="token operator">></span>   <span class="token operator">&lt;</span>/head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>      <span class="token operator">&lt;</span>p<span class="token operator">></span>题目：<span class="token variable">${title}</span><span class="token operator">&lt;</span>/p<span class="token operator">></span>      <span class="token operator">&lt;</span>p<span class="token operator">></span>标签：<span class="token variable">${tags}</span><span class="token operator">&lt;</span>/p<span class="token operator">></span>      <span class="token operator">&lt;</span>p<span class="token operator">></span>总结：<span class="token variable">${summary}</span><span class="token operator">&lt;</span>/p<span class="token operator">></span>      <span class="token operator">&lt;</span>p<span class="token operator">></span>链接：<span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"<span class="token variable">${url}</span>"</span><span class="token operator">></span>文章内容<span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>/body<span class="token operator">></span>  <span class="token operator">&lt;</span>/html<span class="token operator">></span>`<span class="token punctuation">;</span>core.setOutput<span class="token punctuation">(</span><span class="token string">'article-item'</span>, context<span class="token punctuation">)</span></code></pre>  注意，这是一个step中实现的输出，为了在重用的workflow中输出数据，需要将steps中的输出映射到jobs中，如下：<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">on</span><span class="token punctuation">:</span>  <span class="token key atrule">workflow_call</span><span class="token punctuation">:</span>    <span class="token key atrule">outputs</span><span class="token punctuation">:</span>      <span class="token key atrule">article-item</span><span class="token punctuation">:</span>        <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"article items"</span>        <span class="token key atrule">value</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> jobs.query<span class="token punctuation">-</span>article.outputs.output1 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">jobs</span><span class="token punctuation">:</span>  <span class="token key atrule">query-article</span><span class="token punctuation">:</span>    <span class="token key atrule">outputs</span><span class="token punctuation">:</span>      <span class="token key atrule">output1</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> steps.query<span class="token punctuation">-</span>step.outputs.article<span class="token punctuation">-</span>item <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token key atrule">steps</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Query Notion Articles        <span class="token key atrule">id</span><span class="token punctuation">:</span> query<span class="token punctuation">-</span>step                <span class="token comment" spellcheck="true"># 对应上述index.js的执行和输出</span>        <span class="token key atrule">run</span><span class="token punctuation">:</span> npm install &amp;&amp; npm run server</code></pre>  在其他的workflow中使用时，如下：<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">jobs</span><span class="token punctuation">:</span>  <span class="token key atrule">article-query</span><span class="token punctuation">:</span>    <span class="token key atrule">uses</span><span class="token punctuation">:</span> ./.github/workflows/notion<span class="token punctuation">-</span>article<span class="token punctuation">-</span>query.yml    <span class="token key atrule">secrets</span><span class="token punctuation">:</span> inherit  <span class="token key atrule">article-review</span><span class="token punctuation">:</span>    <span class="token key atrule">needs</span><span class="token punctuation">:</span> article<span class="token punctuation">-</span>query    <span class="token key atrule">steps</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> send mail        <span class="token key atrule">uses</span><span class="token punctuation">:</span> dawidd6/action<span class="token punctuation">-</span>send<span class="token punctuation">-</span>mail@master        <span class="token key atrule">with</span><span class="token punctuation">:</span>          <span class="token key atrule">html_body</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> needs.article<span class="token punctuation">-</span>query.outputs.article<span class="token punctuation">-</span>item <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>  其中<code>needs</code> 是用于编排不同的jobs的，后续会说明，直接引用这里使用的workflow并获取对应的输出的参数即可。</li></ul></li></ul><h2 id="编排jobs"><a href="#编排jobs" class="headerlink" title="编排jobs"></a>编排jobs</h2><p>如果没有加限制，不同的jobs之间是独立的，例如上述的两个workflow作为两个jobs使用时，如果不加限制，article-review可能无法获取article-query的article-item结果，因为它可能先执行结束，因此<a href="https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context">需要 <code>needs</code> 来保证不同的jobs的执行顺序</a>，从而构建一个dependency graph，使得不同的jobs之间可以串行、并行等。</p><p>本文需要保证 article-review 在article-query之后执行，因此需要<code>needs</code>来维护依赖关系。</p><h2 id="注意secrets"><a href="#注意secrets" class="headerlink" title="注意secrets"></a>注意secrets</h2><h3 id="存储secrets"><a href="#存储secrets" class="headerlink" title="存储secrets"></a>存储secrets</h3><p>敏感的信息保证不存在在代码中，Github提供一种不公开的方式，同时还定义了不同的粒度，<a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">可以参考具体文档</a>。</p><p><img src="/images/eff/not_git/secrets.png" alt="Untitled"></p><h3 id="使用secrets"><a href="#使用secrets" class="headerlink" title="使用secrets"></a>使用secrets</h3><p>这些secrets可以作为环境变量在workflow中使用，这里需要使用Github Actions提供的 <code>secrets</code> context实现，<a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets#using-encrypted-secrets-in-a-workflow">具体参考文档</a>，代码如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> Query Notion Articles    <span class="token key atrule">id</span><span class="token punctuation">:</span> query<span class="token punctuation">-</span>step    <span class="token key atrule">run</span><span class="token punctuation">:</span> npm install &amp;&amp; npm run server    <span class="token key atrule">env</span><span class="token punctuation">:</span>       <span class="token comment" spellcheck="true"># Required mail server address:</span>      <span class="token key atrule">NOTION_API_KEY</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> secrets.NOTION_API_KEY <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token comment" spellcheck="true"># Required mail server port:</span>      <span class="token key atrule">DATABASE_ID</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> secrets.ARTICLE_DATABASE_ID <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="不同workflow之间传递secrets"><a href="#不同workflow之间传递secrets" class="headerlink" title="不同workflow之间传递secrets"></a>不同workflow之间传递secrets</h3><p>这个问题可能很少有人提到，我在构建的时候遇到这个问题，在重用已有的workflow时，如果也存在secrets需要保密，需要在调用workflow中声明引用的workflow将集成本workflow下的所有secrets，操作如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">jobs</span><span class="token punctuation">:</span>  <span class="token key atrule">article-query</span><span class="token punctuation">:</span>    <span class="token key atrule">uses</span><span class="token punctuation">:</span> ./.github/workflows/notion<span class="token punctuation">-</span>article<span class="token punctuation">-</span>query.yml    <span class="token key atrule">secrets</span><span class="token punctuation">:</span> inherit   <span class="token key atrule">article-review</span><span class="token punctuation">:</span>        <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest</code></pre><p>具体细节可以<a href="https://docs.github.com/en/actions/using-workflows/reusing-workflows#passing-inputs-and-secrets-to-a-reusable-workflow">参考文档</a>。</p><h2 id="邮件模板"><a href="#邮件模板" class="headerlink" title="邮件模板"></a>邮件模板</h2><p>本文只是设计了一个简单文章摘要，包括：</p><ul><li>题目</li><li>标签</li><li>总结</li><li>文章内容的url；</li></ul><p>一种锦上添花的操作是使用HTML Email，<a href="http://www.ruanyifeng.com/blog/2013/06/html_email.html">阮一峰专门针对这个写了一篇文章</a>，可以参考。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个项目的代码在<a href="https://github.com/limeya/NotionReview">仓库</a>，最终的结果如下：</p><p><img src="/images/eff/not_git/result.png" alt="Untitled"></p><p>总的来看，这个过程：</p><ul><li>熟悉了Notion API和Github Actions的操作；</li><li>打开了Github Actions的有趣的世界，有很多的项目可以借鉴：<ul><li><a href="https://blog.owenyoung.com/zh/posts/actionsflow/">Actionsflow，也可以替代Github Actions实现workflow</a><strong><strong>。</strong></strong></li><li><a href="https://cloud.tencent.com/developer/article/1909652">自动同步博客文章到Github</a>，这个后边准备加入到我的仓库中；</li><li><a href="https://sspai.com/post/73188">整理Newsletter</a>；</li></ul></li><li>更大的收获，应该是让自己看过的和思考的内容不再堆在某个充满尘土的角落里，让知识和思想流动起来！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 效率生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notion </tag>
            
            <tag> Github Actions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101：Rasterization - Shadow Mapping</title>
      <link href="/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-rasterization-shadow-mapping/"/>
      <url>/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-rasterization-shadow-mapping/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>着色是局部的，这种方便但不对；</li><li>shading中无法解决阴影问题；</li></ul><p>那么：How to draw shadows using rasterization?</p><h1 id="方法：Shadow-Mapping"><a href="#方法：Shadow-Mapping" class="headerlink" title="方法：Shadow Mapping"></a>方法：Shadow Mapping</h1><h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><blockquote><p>the points NOT in shadow must be seen both <strong>by the light</strong> and <strong>by the camera</strong></p></blockquote><p>在该方法中，如果点不在“阴影”中，指的是其既能被光看见，也能被人眼看见。换句话说，当一个点在阴影中时，说明其或者不能被光看见，或者不能被人眼看见。</p><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>该方法是An Image-space Algorithm，如何理解？</p><blockquote><p>no knowledge of scene’s geometry during shadow computation</p></blockquote><p>在生成阴影的过程中不需要找到几何信息。</p><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p><img src="/images/games101/ext/1/sm_process.png" alt="Shadow Mapping具体过程"></p><p>该过程包含两个步骤：</p><ul><li>从光源看向具体的物体；</li><li>从人眼看向具体的物体；</li></ul><p>具体如上图所示：</p><ol><li>首先，从光源看向物体，可以得到光源能够看到的图，该图不进行着色，只记录看到的点的深度信息；<blockquote><p>Depth image from light source</p></blockquote></li><li>从人眼看向具体的物体，对于看到的物体上的点，将其投影回从光源角度看得到的平面，如第3部分，能够得到该点对应深度图上的哪个像素；<blockquote><p>Standard image (with depth) from eye</p></blockquote><blockquote><p>Project visible points in eye view back to light source</p></blockquote></li><li>比较投影到Depth image上的点的深度信息，与Depth image的深度信息，可以得到两个结果：<ul><li>(Reprojected) depths match for light and eye：说明该点能够被看见，不在阴影中；</li><li>depths from light and eye are not the same：该点不能被看见，在阴影中；</li></ul></li></ol><h2 id="实例操作过程"><a href="#实例操作过程" class="headerlink" title="实例操作过程"></a>实例操作过程</h2><ol><li><p>The <strong>depth buffer</strong> from the light’s point-of-view</p><p> <img src="/images/games101/ext/1/step1.png" alt="步骤1"></p></li><li><p>Comparing Dist(light, shading point) with shadow map</p><p> <img src="/images/games101/ext/1/step2.png" alt="步骤2"></p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/images/games101/ext/1/shadow_effect.png" alt="有无阴影效果"></p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><h3 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h3><blockquote><p>Involves equality comparison of floating point depth values means issues of scale, bias, tolerance.</p></blockquote><p>由于需要判断深度信息是否相等，当构建阴影时，会因为浮点数难以判断相等，导致阴影非常“脏”。如上图中的绿色图片所示。</p><p>一些方法：</p><ul><li>不判断相等，判断大小；</li><li>同时，加一个小的误差范围；</li></ul><p>但这些方法不能根本解决问题。</p><h3 id="Depth-image分辨率的影响"><a href="#Depth-image分辨率的影响" class="headerlink" title="Depth image分辨率的影响"></a>Depth image分辨率的影响</h3><blockquote><p>Quality depends on shadow map resolution (general problem with image-based techniques).</p></blockquote><p>当shadow map的分辨率很低时，其对应的深度信息可以覆盖多个重投影到该图上的点，因此会出现走样的问题，因此must deal with aliasing artifacts。增加分辨率能解决问题，但是开销增加。</p><h3 id="只能用于点光源"><a href="#只能用于点光源" class="headerlink" title="只能用于点光源"></a>只能用于点光源</h3><p>该方法只能处理点光源：因此其中的阴影，非0即1，即要么在阴影中，要么不在——硬阴影。</p><ul><li>硬阴影：完全看不到光，界限明显，光源是点光源；</li><li>软阴影：能看到部分光，界限圆滑，光源有一定大小；</li></ul><p><img src="/images/games101/ext/1/hard_vs_soft.png" alt="Hard shadows vs. Soft shadows"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>即便有很多问题，仍然是Well known rendering technique；</li><li>Basic shadowing technique for early animations and 3D video game；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光栅化 </tag>
            
            <tag> Rasterization </tag>
            
            <tag> Shadow Mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-12：Geometry - Mesh Operations</title>
      <link href="/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-12-geometry-mesh-operations/"/>
      <url>/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-12-geometry-mesh-operations/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>前面提到很多几何图形的Explicit Representations，包括：</p><ul><li>triangle meshes</li><li>Bezier curves &amp; surfaces</li><li>point clouds</li></ul><p>虽然之前详述了Bezier curves &amp; surfaces，但是在图形学中最常用的方式是Polygon Mesh，因为其有一些好的性质：</p><blockquote><p>Easier to do processing / simulation, adaptive sampling</p></blockquote><p>因此，Perhaps most common representation in graphics。</p><p>对于Mesh网络，其存在对应的几何操作：</p><ul><li>Mesh subdivision（upsampling）：细化三角形数量，实现了Increase resolution的效果；  <img src="/images/games101/12/subdivision.png" alt="Mesh subdivision"></li><li>Mesh simplification（downsampling）：正好与Mesh subdivision的效果相反；<blockquote><p>Decrease resolution; try to preserve shape/appearance.</p></blockquote>  <img src="/images/games101/12/simplify.png" alt="Mesh simplification"></li><li>Mesh regularization：使所有的三角形相同；<blockquote><p>Modify sample distribution to improve quality</p></blockquote>  这种方式有利于解决因三角形大小不同导致的渲染困难等问题，在改善三角形表示的同时，不能损失模型的表示效果。  <img src="/images/games101/12/regular.png" alt="Mesh regularization"></li></ul><p>这一节主要是对Mesh的几何操作（Geometry Processing）进行说明。</p><p><img src="/images/games101/12/gp.png" alt="Geometry Processing"></p><h1 id="Mesh-Subdivision"><a href="#Mesh-Subdivision" class="headerlink" title="Mesh Subdivision"></a>Mesh Subdivision</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>所谓的subdivision具体指两个操作：</p><ol><li>First, create more triangles (vertices)</li><li>Second, tune their positions：使得几何形状更平滑；</li></ol><p>这两步是 Common subdivision rule for triangle meshes。</p><h2 id="方法1：Loop-Subdivision"><a href="#方法1：Loop-Subdivision" class="headerlink" title="方法1：Loop Subdivision"></a>方法1：Loop Subdivision</h2><h3 id="划分三角形"><a href="#划分三角形" class="headerlink" title="划分三角形"></a>划分三角形</h3><p>该方法只针对三角形，将每条边的中点连接从而形成4个三角形。</p><blockquote><p>Split each triangle into four.</p></blockquote><p><img src="/images/games101/12/split_tri.png" alt="划分三角形"></p><h3 id="调整位置"><a href="#调整位置" class="headerlink" title="调整位置"></a>调整位置</h3><p>完成三角形划分后，需要调整三角形顶点的位置。</p><blockquote><p>Assign new vertex positions according to weights</p></blockquote><p>对于新的顶点和旧的顶点采用不同的方法进行调整。</p><blockquote><p>New / old vertices updated differently</p></blockquote><ul><li>对新顶点：对中心的新顶点，其新的位置取决于周围的旧节点；  <img src="/images/games101/12/loop_new_pos.png" alt="对新顶点调整位置"></li><li>对旧节点：其新的位置取决于自己原来的位置，和其周围节点的位置。  对于一个节点来说，当其度很大的时候，其自身的影响可以忽略不计；当度很小的时候，其需要更多的考虑自身之前的节点位置。  <img src="/images/games101/12/loop_old_pos.png" alt="对旧顶点调整位置"></li></ul><h3 id="方法效果"><a href="#方法效果" class="headerlink" title="方法效果"></a>方法效果</h3><p><img src="/images/games101/12/ls_effect.png" alt="Loop Subdivision的效果"></p><h2 id="方法2：Catmull-Clark-Subdivision"><a href="#方法2：Catmull-Clark-Subdivision" class="headerlink" title="方法2：Catmull-Clark Subdivision"></a>方法2：Catmull-Clark Subdivision</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Loop Subdivision只能针对网格中的三角形进行细分，无法作为通用的几何图形细分方法。</p><h3 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h3><ul><li>Non-quad face：不是四边形构成的面；</li><li>Extraordinary vertex：顶点的度不为4(degree != 4) ；</li></ul><p><img src="/images/games101/12/concept_def.png" alt="概念定义"></p><h3 id="增加三角形"><a href="#增加三角形" class="headerlink" title="增加三角形"></a>增加三角形</h3><p>为了增加三角形，具体步骤如下：</p><ul><li>Add vertex in each face</li><li>Add midpoint on each edge</li><li>Connect all new vertices</li></ul><p><img src="/images/games101/12/ccs_add_tri.png" alt="增加三角形"></p><p>在划分形状的过程中，经过一次划分后：</p><ul><li>extraordinary vertices数量：原始extraordinary vertices数量+原始non-quad faces数量</li><li>non-quad faces数量：无</li></ul><p>经过一次划分后，之后extraordinary vertices和non-quad faces数量不再变化。</p><h3 id="调整位置-1"><a href="#调整位置-1" class="headerlink" title="调整位置"></a>调整位置</h3><p>将顶点分为三种类型：</p><p><img src="/images/games101/12/tune_pos.png" alt="根据不同类型调整顶点位置"></p><h1 id="Mesh-simplification"><a href="#Mesh-simplification" class="headerlink" title="Mesh simplification"></a>Mesh simplification</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><blockquote><p>reduce number of mesh elements while maintaining the overall shape.</p></blockquote><p><img src="/images/games101/12/simple_goal.png" alt="Mesh simplification"></p><p>不同的场景下，选择的三角形的数量也不同，主要是考虑性能、存储空间，或者不需要考虑细节。</p><h2 id="一种方法：Collapsing-An-Edge"><a href="#一种方法：Collapsing-An-Edge" class="headerlink" title="一种方法：Collapsing An Edge"></a>一种方法：Collapsing An Edge</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><blockquote><p>simplify a mesh using <strong>edge collapsing</strong></p></blockquote><p>即将一条边转换为一个顶点。</p><h3 id="Collapse哪条边—Quadric-Error-Metrics"><a href="#Collapse哪条边—Quadric-Error-Metrics" class="headerlink" title="Collapse哪条边—Quadric Error Metrics"></a>Collapse哪条边—Quadric Error Metrics</h3><p>在确定通过坍缩一条边来简化图形后，一个问题是：应该坍缩哪条边，能够保持原来的几何形状？或许这个问题换种说法：坍缩后的边形成的节点应该在什么位置，使得能够保持几何形状？变为这个问题后，就不用判断哪条边重要，只要能够保持原有形状，确定新节点的位置即可。</p><p>如何确定新节点的位置呢？</p><ul><li>取相邻点的平均值；</li><li>取坍缩点的平均值；</li><li>……</li></ul><p>Quadric Error Metrics（⼆次误差度量）用一种度量的方法解决这个问题，该方法问一个问题：</p><blockquote><p>How much geometric error is introduced by simplification?</p></blockquote><p>其思想在于：</p><blockquote><p>Quadric error: new vertex should minimize its <strong>sum of square distance (L2 distance) to previously related triangle planes</strong>!</p></blockquote><p><img src="/images/games101/12/qem_compare.png" alt="Quadric Error Metrics与其他方法对比"></p><p>因为 Quadric Error Metrics 能够确定新的顶点位置，因此确定坍缩哪条边，可以转换为：坍缩 Quadric Error Metrics 最小的边，这样保证能够保持原有的形状，然后再一次坍缩第二小的，等等。</p><p>那么如何坍缩几何图形呢？一种方式是对整个几何图形的所有边都进行坍缩，然后计算每次坍缩操作对应的Quadric Error，然后排序，取最小误差对应的边进行坍缩。</p><p><strong>一个问题：当坍缩一条边后，其连接的边也发生了变化，之前对应该边的Quadric Error也就发生了变化。即Quadric Error随坍缩过程会发生动态变化。</strong></p><p><img src="/images/games101/12/dynamic.png" alt="一条边坍缩会引起其他边发生变化"></p><p>因此，上述的做法是行不通的。</p><p>实际的做法是：</p><ol><li>首先对整个几何物体的每条边进行坍缩，取最小Quadric Error对应的边；</li><li>将与该边连接的其他边对应的Quadric Error更新，再计算剩余最小Quadric Error对应的边；</li><li>对上述过程不断重复；</li></ol><p>该过程需要应用有优先队列或者堆来实现。</p><p><strong>一个问题：按照上述过程的顺序得到的所有边，对应的Quadric Error也是从最小到最大吗？显然不一定，其只是局部最小，因此是通过用局部最小代替全局最小</strong>——greedy algorithm。但是在实际中，这种方法的效果得到了认可。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/images/games101/12/collapse_effect.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geometry </tag>
            
            <tag> Mesh </tag>
            
            <tag> Mesh Operations </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-11-2：Geometry - Bézier Surfaces</title>
      <link href="/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-11-2-geometry-bezier-surfaces/"/>
      <url>/2022/05/06/ji-suan-ji-tu-xing-xue/games/games101-11-2-geometry-bezier-surfaces/</url>
      
        <content type="html"><![CDATA[<h1 id="Bezier-Surfaces"><a href="#Bezier-Surfaces" class="headerlink" title="Bézier Surfaces"></a>Bézier Surfaces</h1><blockquote><p>Extend Bézier curves to surfaces.</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="/images/games101/11/2/bs.png" alt="Bézier Surfaces例子"></p><h2 id="绘制Bezier-Surfaces"><a href="#绘制Bezier-Surfaces" class="headerlink" title="绘制Bézier Surfaces"></a>绘制Bézier Surfaces</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><blockquote><p>Bezier surface and 4 x 4 array of control points.</p></blockquote><p><img src="/images/games101/11/2/bs_patch.png" alt="Bicubic Bézier Surface Patch"></p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>以bi-cubic Bezier surface为例进行说明。</p><ul><li>输入：$4 \times 4$ control points；</li><li>输出：2D surface parameterized by $(u,v)$ in $[0,1]^2$；</li></ul><p>与Bézier curves同样的过程，只不过这里是在两个方向上进行双线性插值。</p><p><img src="/images/games101/11/2/step1.png" alt="步骤1"></p><p>该方法称之为——Separable 1D de Casteljau Algorithm。由于在贝塞尔曲线的生成中，需要利用一个时间 $t$ 来生成对应的曲线，泛化到三维空间中，则需要两个时间来生成曲面，这里定义为 $u, v$。 </p><p>具体过程如下：</p><ol><li>首先，在时间 $u$ 方向上生成对应的贝塞尔曲线，这里定义使用 $4 \times 4$ 的控制点构建曲面，因此这一步需要生成4条对应的贝塞尔曲线，得到的结果是任意时间 $u_i$ 下的最终的插值结果。</li><li>将第一步得到的4个插值点视为 $v$ 方向上的控制点，然后再进行同样的插值操作，然后形成曲面上的一个点；</li><li>按照上述过程，不断递归，从而形成最终所有的曲面上的点。</li></ol><p><img src="/images/games101/11/2/step2.png" alt="步骤2"></p><p>动画效果如下：</p><p><img src="/images/games101/11/2/animation_effect.gif" alt="动画效果"></p><h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><p>这里类似之前在曲线中讨论的问题，如：</p><ul><li>各个曲面如何拼接；</li><li>如果保证曲面拼接的“平滑”；</li></ul><p>在曲线中遇到的问题在这里均会遇到，对于进一步的学习可以参考之前在曲线中提到的参考资料。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geometry </tag>
            
            <tag> Bézier Surfaces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-11-1：Geometry - Curves</title>
      <link href="/2022/05/04/ji-suan-ji-tu-xing-xue/games/games101-11-1-geometry-curves/"/>
      <url>/2022/05/04/ji-suan-ji-tu-xing-xue/games/games101-11-1-geometry-curves/</url>
      
        <content type="html"><![CDATA[<h1 id="Explicit-Representations"><a href="#Explicit-Representations" class="headerlink" title="Explicit Representations"></a>Explicit Representations</h1><h2 id="Point-Cloud"><a href="#Point-Cloud" class="headerlink" title="Point Cloud"></a>Point Cloud</h2><ul><li>Easiest representation: list of points $(x,y,z)$<ul><li>不直接对几何表面进行表示，而是对构成图形的点的集合进行表示；</li></ul></li><li>Easily represent any kind of geometry<ul><li>只要点足够多和密集，就能够表示任意的几何物体；</li></ul></li><li>Useful for LARGE datasets (&gt;&gt;1 point/pixel)</li><li>Often converted into polygon mesh</li><li>Difficult to draw in undersampled regions<ul><li>当点不够密集时，则无法构成平面；</li></ul></li></ul><p><img src="/images/games101/11/1/cloud.png" alt="Point Cloud"></p><h2 id="Polygon-Mesh"><a href="#Polygon-Mesh" class="headerlink" title="Polygon Mesh"></a>Polygon Mesh</h2><ul><li>Perhaps most common representation in graphics<ul><li>最广泛的应用</li></ul></li><li>Store vertices &amp; polygons (often triangles or quads)</li><li>Easier to do processing / simulation, adaptive sampling</li><li>More complicated data structures</li></ul><p><img src="/images/games101/11/1/mesh.png" alt="Polygon Mesh"></p><h2 id="The-Wavefront-Object-File-obj-Format"><a href="#The-Wavefront-Object-File-obj-Format" class="headerlink" title="The Wavefront Object File (.obj) Format"></a>The Wavefront Object File (.obj) Format</h2><ul><li>该文件格式用于表示三角形面形成的物体</li><li>Just a text file that specifies vertices, normals, texture coordinates and their connectivities</li><li>其中：<ul><li>v：表示顶点向量；</li><li>vt：表示纹理坐标；</li><li>vn：表示顶点的法线向量；</li><li>f：表示三角形的各个面，以及它们之间的连接关系，其中三个序号依次为：顶点向量、纹理坐标、法线向量；<ul><li>例如：5/1/1    1/2/1    4/3/1 表示第5、1、4个顶点构成三角形，每个顶点对应的纹理坐标对应第1、2、3个，法线向量对应1、1、1个。</li></ul></li></ul></li></ul><p><img src="/images/games101/11/1/obj.png" alt="The Wavefront Object File"></p><h1 id="Bezier-Curves"><a href="#Bezier-Curves" class="headerlink" title="Bézier Curves"></a>Bézier Curves</h1><p>这是一种对于曲线显式表示的方法。</p><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><p>用一系列的控制点来表示曲线，以满足其特定的性质。</p><p>其中：</p><ul><li>控制点能唯一确定一条曲线；</li><li>但是不要求曲线能经过控制点，曲线只需要经过起点和终点；</li></ul><p><img src="/images/games101/11/1/bc.png" alt="Bézier Curves"></p><h2 id="绘制Bezier-Curves"><a href="#绘制Bezier-Curves" class="headerlink" title="绘制Bézier Curves"></a>绘制Bézier Curves</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果利用任意多个控制点，绘制一条Bézier Curves？</p><h3 id="解决方法：de-Casteljau-Algorithm"><a href="#解决方法：de-Casteljau-Algorithm" class="headerlink" title="解决方法：de Casteljau Algorithm"></a>解决方法：de Casteljau Algorithm</h3><p>该算法可以利用控制点生成曲线，其本质是在不同的线段上进行插值，然后将所有的插值点视为基础点，不断递归，直到最终的结果中只有一个插值点，该插值点即在生成的曲线上。</p><p>为了理解这个算法的过程，下边从：</p><ul><li>几何角度；</li><li>代数角度；</li></ul><p>两个方面理解这个算法。</p><h3 id="几何角度"><a href="#几何角度" class="headerlink" title="几何角度"></a>几何角度</h3><p>为了说明，考虑有三个控制点的情况（这种情况下生成的曲线称为quadratic Bezier）。</p><p>在如下3个控制点中，$\bf{b}_0$、$\bf{b}_2$ 分别为起点和终点，$\bf{b}_1$ 确定曲线的弯曲方向。那么如何控制曲线的生成呢？</p><p>一种方式是，为了从 $\bf{b}_0$ 到 $\bf{b}_2$ 绘制曲线，将从 $\bf{b}_0$ 开始的时间定为0，到 $\bf{b}_2$ 的时间定为1，那么曲线的绘制过程，其实就是找到在 $[0, 1]$ 时间范围内，曲线上的点的位置。因此，将绘制曲线的算法转换为定位一个点的位置的方法。</p><p>具体过程如下：</p><ol><li>Insert a point using linear interpolation 具体来说，即在$\bf{b}_0$、$\bf{b}_1$之间插值一个点 $\mathbf{b}_0^1$ ，使得： $$<br> \mathbf{b}_0^1 = (1 - t) \mathbf{b}_0 + t \bf{b}_1<br> $$</li><li>Insert on both edges 使用同样的方式在$\bf{b}_1$、$\bf{b}_2$之间插值一个点 $\mathbf{b}_1^1$ ，使得： $$<br> \mathbf{b}_1^1 = (1 - t) \mathbf{b}_1 + t \bf{b}_2<br> $$</li><li>Repeat recursively 按照上述方式进行递归计算，在$\mathbf{b}_0^1$ 和 $\mathbf{b}_1^1$两个插值点之间再进行插值得到新的插值点 $\mathbf{b}_0^2$ ，使得： $$<br> \mathbf{b}_0^2 = (1 - t) \mathbf{b}_0^1 + t \mathbf{b}_1^1<br> $$ 问题是：递归的结束条件是什么？当插值点只有一个时，即完成了递归过程。如利用3个控制点生成曲线的过程中：<ul><li>第1次插值：得到2个插值点 $\mathbf{b}_0^1$ 和 $\mathbf{b}_1^1$；</li><li>第2次插值：得到1个插值点 $\mathbf{b}_0^2$ ；</li></ul></li><li>Run the same algorithm for every t in $[0,1]$ 对于范围$[0,1]$ 中的每个 $t_i$，均进行上述过程，即完成了曲线的绘制。</li></ol><p><img src="/images/games101/11/1/casteljau.png" alt="de Casteljau Algorithm"></p><p>对于4个控制点生成曲线，过程如下：</p><p><img src="/images/games101/11/1/cubic_bc.png" alt="Cubic Bézier Curve"></p><p><strong>动画效果如下：</strong></p><blockquote><p>参考资料：Animation: Steven Wittens, Making Things with Maths, <a href="http://acko.net/">http://acko.net</a></p></blockquote><p><img src="/images/games101/11/1/bc_animation.gif" alt="贝塞尔曲线动画"></p><h3 id="代数角度"><a href="#代数角度" class="headerlink" title="代数角度"></a>代数角度</h3><p>在该算法中，通过对控制之间的线段不断进行插值，得以得到如下的金字塔形状。</p><p><img src="/images/games101/11/1/coef.png" alt="de Casteljau Algorithm系数计算"></p><ul><li>Every rightward arrow is multiplication by $t$ ;</li><li>Every leftward arrow by $(1–t)$ ;</li></ul><p>对于<strong>3个控制点</strong>形成的贝塞尔曲线，可以得到：</p><p>$$<br>\begin{array}{l}<br>\mathbf{b}_0^1 (t)= (1-t) \mathbf{b}_0+t \mathbf{b}_1 \\<br>\mathbf{b}_1^1 (t)= (1-t) \mathbf{b}_1+t \mathbf{b}_2<br>\end{array}<br>$$</p><p>$$<br>\begin{array}{l}<br>\mathbf{b}_0^2(t) = (1 - t) \mathbf{b}_0^1 + t \mathbf{b}_1^1<br>\\<br>\mathbf{b}_0^2(t)=(1-t)^2 \mathbf{b}_0+2 t(1-t) \mathbf{b}_1+t^2 \mathbf{b}_2<br>\end{array}<br>$$</p><h3 id="系数展开式"><a href="#系数展开式" class="headerlink" title="系数展开式"></a>系数展开式</h3><p>对于 $n+1$ 个控制点，可以进行 $n$ 次插值计算，其中生成的贝塞尔曲线上的任意一点均是控制点向量的线性组合，如下所示：</p><p>$$<br>\mathbf{b}^{n}(t)=\mathbf{b}_{0}^{n}(t)= \sum_{j=0}^n \mathbf{b}_j B_j^n (t)<br>$$</p><!-- $$\mathbf{b}^{n}(t)=\mathbf{b}_{0}^{n}(t)=\sum_{j=0}^{n} \mathbf{b}_{j} B_{j}^{n}(t)$$ --><p>其中：</p><ul><li>$\mathbf{b}^{n}(t)$ : Bézier curve order $n$ (vector polynomial of degree $n$);</li><li>$\mathbf{b}_{j}$ : Bézier control points (vector in $\mathbf{R}^N$);</li><li>$B_{j}^{n}(t)$ : Bernstein polynomial (scalar polynomial of degree $n$);</li></ul><p>该线性组合的系数 $B_{j}^{n}(t)$ 是一个与时间 $t$ 有关的多项式，称之为Bernstein polynomial，如下：</p><p>$$<br>B_{i}^{n}(t)=\left(\begin{array}{l}n \\ i\end{array}\right) t^{i}(1-t)^{n-i}<br>$$</p><p>整个Bernstein polynomial其实是一个二项分布，因此对于任意的n次展开式，其所有对应的系数之和为1。</p><p><img src="/images/games101/11/1/bp1.png" alt="Bernstein polynomial系数和为１"></p><p>其中，控制点不一定是2D的，也可以是3D空间中的，例如对于4个3D的控制点如下：</p><p>$$<br>\mathbf{b}_0=(0,2,3), \mathbf{b}_1=(2,3,5), \mathbf{b}_2=(6,7,9), \mathbf{b}_3=(3,4,5)<br>$$</p><p>可以得知任意时间 t 下，对应的曲线上的点为：</p><p>$$<br>\mathbf{b}^n (t)=\mathbf{b}_0 (1-t)^3 +\mathbf{b}_1 3 t(1-t)^2 +\mathbf{b}_2 3 t^2 (1-t)+\mathbf{b}_3 t^3<br>$$</p><h2 id="Bezier-Curves的性质"><a href="#Bezier-Curves的性质" class="headerlink" title="Bézier Curves的性质"></a>Bézier Curves的性质</h2><ol><li>Interpolates endpoints 对于4个控制点（cubic Bézier），则有： $$<br> \mathbf{b}(0)=\mathbf{b}_0 ; \quad \mathbf{b}(1)=\mathbf{b}_3<br> $$</li><li>Tangent to end segments 对于4个控制点（cubic Bézier），则有： $$<br> \mathbf{b}^{\prime}(0)=3\left(\mathbf{b}_1 -\mathbf{b}_0 \right) ; \quad \mathbf{b}^{\prime}(1)=3\left(\mathbf{b}_3 -\mathbf{b}_2 \right)<br> $$</li><li>Affine transformation property<blockquote><p>Transform curve by transforming control points.</p></blockquote> 对于贝塞尔曲线中的每个点进行仿射变换得到的贝塞尔曲线，与对贝塞尔曲线的控制点进行仿射变换然后再生成的贝塞尔曲线一致。因此，若要对贝塞尔曲线进行仿射变换，只需要对其控制点进行变换即可，然后再生成曲线。 这个性质只针对仿射变换，在投影等变换下不成立。</li><li>Convex hull property <a href="https://zh.wikipedia.org/zh-hans/%E5%87%B8%E5%8C%85">凸包</a>性质<blockquote><p>Curve is within convex hull of control points.</p></blockquote></li></ol><h1 id="Piecewise-Bezier-Curves"><a href="#Piecewise-Bezier-Curves" class="headerlink" title="Piecewise Bézier Curves"></a>Piecewise Bézier Curves</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>Higher-Order Bézier Curves会导致一些问题：</p><ul><li>当控制点很多时，很难针对特定控制点操作，以控制整体曲线的形状；</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><ul><li>不用控制点生成一条完整的曲线；</li><li>代替，使用少量的控制点生成一段曲线，然后将所有的曲线拼接起来；<blockquote><p>chain many low-order Bézier curve</p></blockquote></li></ul><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><blockquote><p>Piecewise cubic Bézier the most common technique</p></blockquote><p>即，实践中常用4个控制点生成一段曲线。</p><p><img src="/images/games101/11/1/pbc.png" alt="Piecewise Bézier Curves"></p><blockquote><p>参考资料：<a href="https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html">Bezier Curve Demos</a></p></blockquote><h3 id="问题：如何保证曲线光滑连接"><a href="#问题：如何保证曲线光滑连接" class="headerlink" title="问题：如何保证曲线光滑连接"></a>问题：如何保证曲线光滑连接</h3><p>保证上一条曲线终点的导数与下一条曲线起点的导数相同，包括方向和大小。</p><p>在这个问题上，可以有两种类型的连续（Continuity）：</p><ul><li>$C^0$ continuity：只要保证几何图形上连接即可；  $$<br>  \mathbf{a}_n = \mathbf{b}_0<br>  $$  <img src="/images/games101/11/1/c0.png" alt="$C^0$ continuity"></li><li>$C^1$ continuity：不仅几何上连接，导数也要相同；  $$<br>  \mathbf{a}_n = \mathbf{b}_0 = \frac{1}{2} (\mathbf{a}_{n-1} + \mathbf{b}_1)<br>  $$  <img src="/images/games101/11/1/c1.png" alt="$C^1$ continuity"></li></ul><p>在一些更严格的场合中，还有要求 $C^2$ continuity，即二阶导数相同。</p><h1 id="Splines"><a href="#Splines" class="headerlink" title="Splines"></a>Splines</h1><blockquote><p>a continuous curve constructed so as to pass through a given set of points and have a certain number of continuous derivatives.</p></blockquote><blockquote><p>In short, a curve under control.</p></blockquote><h2 id="B-splines"><a href="#B-splines" class="headerlink" title="B-splines"></a>B-splines</h2><ul><li>Short for basis splines</li><li>Require more information than Bezier curves</li><li>Satisfy all important properties that Bézier curves have (i.e. superset)</li></ul><p>本课中未详述样条内容，具体内容可以进一步参考以下资料。</p><p><a href="https://www.bilibili.com/video/av66548502?from=search&seid=65256805876131485">清华大学-计算机图形学基础（国家级精品课）_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geometry </tag>
            
            <tag> Curves </tag>
            
            <tag> Bézier Curves </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-10：Geometry - Implicit Representations</title>
      <link href="/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-10-geometry-implicit-representations/"/>
      <url>/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-10-geometry-implicit-representations/</url>
      
        <content type="html"><![CDATA[<h1 id="Ways-to-Represent-Geometry"><a href="#Ways-to-Represent-Geometry" class="headerlink" title="Ways to Represent Geometry"></a>Ways to Represent Geometry</h1><h2 id="Implicit-Representations"><a href="#Implicit-Representations" class="headerlink" title="Implicit Representations"></a>Implicit Representations</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>这种方法不会具体描述集几何物体上的每个点，而是描述所有的点满足的数学关系。</p><blockquote><p>Based on classifying points: Points satisfy some specified relationship.</p></blockquote><p>$$<br>f(x, y, z) = 0<br>$$</p><p>例如球体：</p><p>$$<br>f(x) = x^2 + y^2 + z^2 - 1<br>$$</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>Inside/Outside Tests Easy  <img src="/images/games101/10/im_io_easy.png" alt="容易判断内外"></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>Sampling Can Be Hard：可能很难看到该表示对应的具体几何形状是什么；  $$<br>  f(x, y, z)=\left(2-\sqrt{x^{2}+y^{2}}\right)^{2}+z^{2}-1<br>  $$  <img src="/images/games101/10/im_sample_hard.png" alt="难以判断几何形状"></li></ul><h2 id="Explicit-Representations"><a href="#Explicit-Representations" class="headerlink" title="Explicit Representations"></a>Explicit Representations</h2><blockquote><p>All points are <strong>given directly</strong> or via <strong>parameter mapping</strong></p></blockquote><p><img src="/images/games101/10/param_map.png" alt="Explicit: Parameter mapping"></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>Sampling Is Easy  <img src="/images/games101/10/ex_sample_easy.png" alt="容易采样"></li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>Inside/Outside Test Hard  <img src="/images/games101/10/ex_io_hard.png" alt="难以判断几何内外"></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>No “Best” Representation</li><li>Best Representation Depends on the Task!</li></ul><h1 id="不同类型的Implicit-Representations"><a href="#不同类型的Implicit-Representations" class="headerlink" title="不同类型的Implicit Representations"></a>不同类型的Implicit Representations</h1><h2 id="Algebraic-Surfaces"><a href="#Algebraic-Surfaces" class="headerlink" title="Algebraic Surfaces"></a>Algebraic Surfaces</h2><blockquote><p>Surface is zero set of a polynomial in $x, y, z$ .</p></blockquote><p>使用数学公式表示：</p><ul><li>不直观，无法判断具体形状；</li></ul><p><img src="/images/games101/10/alge.png" alt="Algebraic Surfaces"></p><h2 id="Constructive-Solid-Geometry-CSG"><a href="#Constructive-Solid-Geometry-CSG" class="headerlink" title="Constructive Solid Geometry (CSG)"></a>Constructive Solid Geometry (CSG)</h2><blockquote><p>Combine implicit geometry via <strong>Boolean operations</strong>.</p></blockquote><p><img src="/images/games101/10/csg.png" alt="Constructive Solid Geometry"></p><h2 id="Distance-Functions"><a href="#Distance-Functions" class="headerlink" title="Distance Functions"></a>Distance Functions</h2><blockquote><p>Instead of Booleans, gradually blend surfaces together using <strong>Distance function</strong>s.</p></blockquote><blockquote><p>Distance function giving <strong>minimum distance</strong> (could be signed distance) from anywhere to object.</p></blockquote><p>对任何几何物体，不直接描述其表面，而是描述空间上任意一点到这个集合物体表面的最小距离。</p><p>这个最小距离是有符号的：</p><ul><li>当空间上的点在物体内部，则到该物体表明的距离为负值；</li><li>当空间上的点在物体外部，则到该物体表明的距离为正值；</li></ul><p><img src="/images/games101/10/blending.png" alt="Blending"></p><p>对于每个几何物体都可以计算出其对应的距离函数，这种函数一般将任意一点当做参数，同时定义对应的几何物体表面（这个表面只是一种泛化的说法，其可以是球体的球心，圆的圆心），例如定义球的距离函数如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">float</span> <span class="token function">sdf_sphere</span> <span class="token punctuation">(</span>float3 p<span class="token punctuation">,</span> float3 c<span class="token punctuation">,</span> <span class="token keyword">float</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">distance</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token operator">-</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>参考资料：</p><ul><li><p><a href="https://www.alanzucconi.com/2016/07/01/signed-distance-functions/">Volumetric Rendering: Signed Distance Functions - Alan Zucconi</a></p></li><li><p><a href="https://iquilezles.org/articles/distfunctions2d/">Inigo Quilez - 2D distance functions</a></p></li></ul><h3 id="例子：Blending-a-moving-boundary"><a href="#例子：Blending-a-moving-boundary" class="headerlink" title="例子：Blending a moving boundary"></a>例子：Blending a moving boundary</h3><p><img src="/images/games101/10/example_blend.png" alt="Blending a moving boundary"></p><p>上图中，将A中阴影部分的右边界定义为物体表面，则得到其对应的距离函数在其下方所示。通过对A和B两个物体的距离函数进行融合，可以得到融合后的物体的拓扑结构。</p><p>对于任意两个几何物体的blending的操作示意图如下：</p><p><img src="/images/games101/10/blend_any.png" alt="利用距离函数对任意物体融合"></p><h2 id="Level-Set-Methods"><a href="#Level-Set-Methods" class="headerlink" title="Level Set Methods"></a>Level Set Methods</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>Closed-form equations are hard to describe complex shapes.</p></blockquote><p>这种方法针对的问题是：不是任何几何图形都有对应的数学解析形式，面对这种情况，可以通过grid的方式将距离函数表示出来。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><blockquote><p>store a grid of values approximating function.</p></blockquote><p><img src="/images/games101/10/level_set.png" alt="Level Set Methods"></p><blockquote><p>Surface is found where <strong>interpolated values</strong> equal zero.</p></blockquote><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><blockquote><p>Provides much more explicit control over shape (like a texture).</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>与texture结合：Level sets encode, e.g., constant tissue density. 将相同密度的部分连接起来形成平面结构；  <img src="/images/games101/10/medical_image.png" alt="医学图像"></li><li>Level set encodes distance to air-liquid boundary：将不同的水珠连接起来；  <img src="/images/games101/10/air.png" alt="水珠效果"></li></ul><h2 id="Fractals"><a href="#Fractals" class="headerlink" title="Fractals"></a>Fractals</h2><blockquote><p>Exhibit self-similarity, detail at all scales.</p></blockquote><p>类似编程中的递归过程，是同一图形在不同scale上的展示。</p><p><img src="/images/games101/10/fractals.png" alt="Fractals例子"></p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><blockquote><p>Hard to control shape.</p></blockquote><p>因为频率很高，因此很容易造成走样。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="Implicit-Representations的优点"><a href="#Implicit-Representations的优点" class="headerlink" title="Implicit Representations的优点"></a>Implicit Representations的优点</h3><ul><li>compact description (e.g., a function)</li><li>certain queries easy (inside object, distance to surface)</li><li>good for ray-to-surface intersection</li><li>for simple shapes, exact description / no sampling error</li><li>easy to handle changes in topology (e.g., fluid)</li></ul><h3 id="Implicit-Representations的缺点"><a href="#Implicit-Representations的缺点" class="headerlink" title="Implicit Representations的缺点"></a>Implicit Representations的缺点</h3><ul><li>difficult to model complex shapes</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geometry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-09-3：Shading - Texture Mapping - Applications of Textures</title>
      <link href="/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-3-shading-texture-mapping-applications-of-textures/"/>
      <url>/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-3-shading-texture-mapping-applications-of-textures/</url>
      
        <content type="html"><![CDATA[<h1 id="Texture的泛化理解"><a href="#Texture的泛化理解" class="headerlink" title="Texture的泛化理解"></a>Texture的泛化理解</h1><blockquote><p>泛化理解texture：<strong>In modern GPUs, texture = memory + range query (filtering)</strong></p></blockquote><p>即，纹理不仅仅用在图像上，可以是任意的内存数据和对应的范围查询方法。</p><p>基于这种理解，texture其实是：</p><blockquote><p><strong>General method to bring data to fragment calculations.</strong></p></blockquote><p>可以在很多的场景中使用：</p><ul><li>Environment lighting</li><li>Store microgeometry</li><li>Procedural textures</li><li>Solid modeling</li><li>Volume rendering</li></ul><h1 id="Environment-lighting"><a href="#Environment-lighting" class="headerlink" title="Environment lighting"></a>Environment lighting</h1><p>对于在着色模型中，将环境光视为常数，与其他两项相加共同完成着色过程。通过纹理可以记录环境光，然后应用到任意的渲染物体上，这种方法比之前应用点光源的效果要好很多。</p><h2 id="例子：Environment-Map"><a href="#例子：Environment-Map" class="headerlink" title="例子：Environment Map"></a>例子：Environment Map</h2><p><img src="/images/games101/09/3/environment_map.png" alt="Environment Map"></p><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>用纹理描述环境光时，假设所有光照均来自无限远处。这种假设使得光照均来自同一个方向，即光照方向的不同不会对环境光的记录产生影响。</p><h2 id="记录环境光"><a href="#记录环境光" class="headerlink" title="记录环境光"></a>记录环境光</h2><h3 id="Spherical-Environment-Map"><a href="#Spherical-Environment-Map" class="headerlink" title="Spherical Environment Map"></a><strong>Spherical Environment Map</strong></h3><p>将环境光照存储在球面上，然后将其展开，之后贴到不同的物体上。但是这种方法在靠近球的极点的位置上，会出现扭曲的现象。</p><p><img src="/images/games101/09/3/spherical_map.png" alt="Spherical Environment Map"></p><p><img src="/images/games101/09/3/distortion.png" alt="球面展开后的扭曲现象"></p><h3 id="解决方法：Cube-Map"><a href="#解决方法：Cube-Map" class="headerlink" title="解决方法：Cube Map"></a><strong>解决方法：Cube Map</strong></h3><p><img src="/images/games101/09/3/cube_map.png" alt="Cube Map"></p><blockquote><p>A vector maps to cube point along that direction.<br>The cube is textured with 6 square texture maps.</p></blockquote><p>简单来说，在球体外切一个立方体，然后将通过球体记录的信息映射到该立方体中。</p><p>这种方法：</p><ul><li>使得扭曲现象得到缓解；</li><li>但是需要增加计算：需要找到球面上的方向信息映射到立方体的哪个面上；</li></ul><p><img src="/images/games101/09/3/tt6.png" alt="Cube Map各个面上图片展开"></p><h1 id="Store-microgeometry"><a href="#Store-microgeometry" class="headerlink" title="Store microgeometry"></a>Store microgeometry</h1><p>纹理不仅可以存储颜色信息，还可以用于存储几何信息。</p><h2 id="Bump-Normal-mapping"><a href="#Bump-Normal-mapping" class="headerlink" title="Bump / Normal mapping"></a>Bump / Normal mapping</h2><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><p>用于定义shading surface中的shading point的相对高度，从而实现“凹凸不平”的效果，但是这种实现并没有改变原本的几何形状，而是<strong>Fake the detailed geometry</strong>。</p><p>这种方法的好处在于：</p><ul><li>没有改变几何物体形状，但是通过复杂的纹理可以实现相同的目标。<blockquote><p>Adding surface detail without adding more triangles</p></blockquote></li></ul><p>其核心idea在于：</p><ul><li>Perturb surface normal per pixel (for shading computations only)</li><li>“Height shift” per texel defined by a texture</li></ul><h3 id="如何计算新的法线"><a href="#如何计算新的法线" class="headerlink" title="如何计算新的法线"></a>如何计算新的法线</h3><p>基于这种想法，一个点的高度通过纹理信息被“修改”了，从而也修改了对应的法线信息。那么一个问题是：How to modify normal vector?</p><p><img src="/images/games101/09/3/normal_compute.png" alt="如何计算新的法线"></p><p>根据不同的应用场景，可以分为：</p><ul><li>in flatland (1D)<ul><li>假设原始着色平面的法线向量沿着y轴方向 $n(p) = (0, 1)$；</li><li>对于加入纹理信息后，一个点p的相对高度发生变化，其导数方向为：每移动1，则高度变化为 $dp = c \cdot [h(p+1) - h(p)]$，因此导数方向为 $(1, -\text{dp})$，其中 $c$ 是放缩因子。</li><li>根据旋转变换，对应该点的法线向量为 $n(p) = (-dp, 1).\text{normalized}()$；</li></ul>  <img src="/images/games101/09/3/flat_normal.png" alt="Normal Compute in Flatland"></li><li>in 3D  在真实的纹理中计算导数时，需要同时在纹理坐标的 $u,v$ 方向同时计算。  同样的过程：<ul><li>假设原始着色平面的法线向量 $n(p) = (0,0, 1)$；</li><li>p点在纹理上的导数方向：  $$<br>  \begin{array}{l}<br>  dp / du= c_1 \cdot [h(\mathbf{u}+1)-h(\mathbf{u})] \\<br>  dp / dv=c_2 \cdot [h(\mathbf{v}+1)-h(\mathbf{v})]\end{array}<br>  $$</li><li>最终新的法线方向为：$n = (-dp/du, -dp/dv, 1).\text{normalized}()$</li></ul></li></ul><p>在该过程中所有的向量计算均针对的是local coordinate，因此为了应用需要将该坐标变换到真实世界中的坐标中。</p><h2 id="Displacement-mapping"><a href="#Displacement-mapping" class="headerlink" title="Displacement mapping"></a>Displacement mapping</h2><h3 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea"></a>Idea</h3><ul><li>a more advanced approach</li><li>Uses the same texture as in bumping mapping</li><li>Actually moves the vertices：相比于bumping mapping不改变几何形状，这里的方法是将shading point进行移动，而不是虚拟操作。两种方法的效果对比如下：  <img src="/images/games101/09/3/map_compare.png" alt="Bump vs Displacement mapping"></li></ul><h3 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h3><ul><li>要求几何形状中的三角形足够密集、细致：这样对于不同的纹理图片中调整的高度，待渲染对象中的三角形不会因为过大出现走样问题；</li></ul><h3 id="一种优化方法"><a href="#一种优化方法" class="headerlink" title="一种优化方法"></a>一种优化方法</h3><ul><li>当三角形不够细致时，可以动态检测三角形是否应该更小和细致？在Direct X中可以动态调整三角形的细致程度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
            <tag> Texture Mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-09-2：Shading - Texture Mapping - Applying Textures</title>
      <link href="/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-2-shading-texture-mapping-applying-textures/"/>
      <url>/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-2-shading-texture-mapping-applying-textures/</url>
      
        <content type="html"><![CDATA[<h1 id="应用例子：Diffuse-Color"><a href="#应用例子：Diffuse-Color" class="headerlink" title="应用例子：Diffuse Color"></a>应用例子：Diffuse Color</h1><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token function">each_rasterized_screen_sample</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token operator">:</span>          <span class="token comment" spellcheck="true">// Usually a pixel’s center</span>    <span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">evaluate_texture_coordinate_at</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// Using barycentric coordinates</span>    texcolor <span class="token operator">=</span> texture<span class="token punctuation">.</span><span class="token function">sample</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_sample_color_to_texcolor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// Usually the diffuse albedo Kd</span></code></pre><p>简单来说，这个过程可以总结为：</p><ol><li>对于每个经过光栅化的像素，首先计算其重心坐标；</li><li>根据光栅化后的三角形中顶点与纹理坐标的映射关系（视为已知），利用三角形中任意一点的重心坐标，插值得到其对应的纹理坐标；</li><li>利用得到的纹理坐标得到纹理信息 texcolor；</li><li>将该纹理信息设置到光栅后的三角形内部，即实现将纹理“贴到”物体上，上例中是将纹理信息视为漫反射系数。</li></ol><p>这个过程比较简单，但是会产生问题。</p><h1 id="问题：Texture-Magnification-纹理太小"><a href="#问题：Texture-Magnification-纹理太小" class="headerlink" title="问题：Texture Magnification 纹理太小"></a>问题：Texture Magnification 纹理太小</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>纹理的分辨率很小，但是待渲染的物体分辨率很高，这会产生什么问题？在物体上的多个像素点可以对应纹理上的同一个texel（A pixel on a texture — a texel），例如通过对得到的纹理坐标四舍五入，取最临近的纹理坐标，因此可能会出现问题。</p><p><img src="/images/games101/09/2/problem.png" alt="问题描述"></p><h2 id="Nearest"><a href="#Nearest" class="headerlink" title="Nearest"></a>Nearest</h2><p>最直接的方法：直接四舍五入取最近的纹理坐标。</p><h2 id="Bilinear"><a href="#Bilinear" class="headerlink" title="Bilinear"></a>Bilinear</h2><p><img src="/images/games101/09/2/bilinear.png" alt="Bilinear插值过程"></p><p>考虑最终的效果和计算复杂度，bilinear得到了很好的平衡。</p><h2 id="Bicubic"><a href="#Bicubic" class="headerlink" title="Bicubic"></a>Bicubic</h2><p>使用周围的16个texel进行插值，效果更好，但是计算量更大。</p><h1 id="问题：Texture-Magnification-纹理太大"><a href="#问题：Texture-Magnification-纹理太大" class="headerlink" title="问题：Texture Magnification 纹理太大"></a>问题：Texture Magnification 纹理太大</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>在应用texture时，采用上例Diffuse Color中使用的方法，很简单，但是由于只是对纹理中的一个点进行采样。当纹理过大时会出现问题，如下图中在近处出现锯齿，在远处出现摩尔纹。</p><p><img src="/images/games101/09/2/tt_big_problem.png" alt="问题描述"></p><h2 id="原因剖析"><a href="#原因剖析" class="headerlink" title="原因剖析"></a>原因剖析</h2><p>如上图所示，从左到右对应上图中从近到远：</p><ul><li>在近处：一个像素对应纹理中的texel较少；</li><li>在远处时，一个像素对应纹理中的很多texel；</li></ul><p>基于这种情况：</p><ul><li>在近处，使用point sampling时，可以在纹理中直接采样对应的纹理信息，由于覆盖的纹理区域较小，因此直接采用对应的纹理信息，问题不大；</li><li>在远处时，由于覆盖的纹理区域较大，因此直接采用对应的一个点的纹理信息，会产生以偏概全的问题；</li></ul><p><img src="/images/games101/09/2/reason.png" alt="纹理太大造成问题的原因剖析"></p><h2 id="解决方案1：Supersampling-Do-Antialiasing"><a href="#解决方案1：Supersampling-Do-Antialiasing" class="headerlink" title="解决方案1：Supersampling Do Antialiasing"></a>解决方案1：Supersampling Do Antialiasing</h2><p>使用MSAA进行反走样可以解决问题。</p><p><img src="/images/games101/09/2/msaa_tt.png" alt="使用MSAA解决纹理过大的问题"></p><h3 id="为什么有效？"><a href="#为什么有效？" class="headerlink" title="为什么有效？"></a>为什么有效？</h3><p>对于远处区域来说，由于覆盖的纹理区域较大，可以视为用像素中的低频信号采样纹理中的高频信号，因为很小的一块像素区域对应很大的纹理区域。</p><p>基于这种情况，MSAA的策略是将像素点划分为更小的单元，从而提高了采样频率，以实现反走样，能够解决该问题。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然这种方法能够解决问题，但是存在代价太大的问题，尤其是当远处的像素和近处的像素覆盖纹理区域的范围很悬殊时，对于像素的进一步划分，在近处的效果很好，但是在远处可能提升有限。同时，当远处的像素区域很小时，若要提升效果，可能需要划分更多的单元，但是在近处则带来计算代价的上升。</p><h2 id="解决方案2：Range-Query-Mipmap"><a href="#解决方案2：Range-Query-Mipmap" class="headerlink" title="解决方案2：Range Query - Mipmap"></a>解决方案2：Range Query - Mipmap</h2><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><p>代替进行采样，直接获得像素覆盖的纹理区域的平均值，这相当于把之前的针对一个像素点的纹理信息的查询转换为特定区域内的范围查询，以便实现平滑的效果。</p><blockquote><p>get the average value within a range.</p></blockquote><h3 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h3><blockquote><p>Allowing (fast, approx., square) range queries.</p></blockquote><p>该方法只能进行近似的、正方形区域的快速范围查询。</p><p><img src="/images/games101/09/2/mipmap.png" alt="Mipmap"></p><p>对于一个纹理图片来说，所谓mipmap指的是不断缩小图片的分辨率从而得到对应区域的纹理信息，上图中虽然所有的图片都是相同尺寸，这是为了展示效果，实际中每次缩小，尺寸均变为原来的0.25。</p><p><img src="/images/games101/09/2/hierarchy.png" alt="Mip Hierarchy"></p><p>考虑到一个正方形的纹理图片 $n \times n$，当缩小分辨率时，其增加的存储空间有多少？估算一下：</p><p>$$<br>n \times n + \frac{1}{2}n \times \frac{1}{2}n + \frac{1}{2^2}n \times \frac{1}{2^2}n + \frac{1}{2^3}n \times \frac{1}{2^3}n + \cdots = \frac{1 \times (1 - \frac{1}{4^{\infty}})}{1 - \frac{1}{4}} n \times n = \frac{4}{3} n \times n<br>$$</p><p>即，存储空间仅增加了原来的33%。</p><h3 id="应用Mipmap"><a href="#应用Mipmap" class="headerlink" title="应用Mipmap"></a>应用Mipmap</h3><p>在应用Mipmop的过程中，需要两个步骤：</p><ol><li>首先要估算一个像素在纹理上的覆盖的区域大小；<blockquote><p>Estimate texture footprint using texture coordinates of neighboring screen samples.</p></blockquote> <img src="/images/games101/09/2/estimate_area.png" alt="估算像素在纹理上的覆盖面积"> $$<br> L=\max \left(\sqrt{\left(\frac{d u}{d x}\right)^{2}+\left(\frac{d v}{d x}\right)^{2}}, \sqrt{\left(\frac{d u}{d y}\right)^{2}+\left(\frac{d v}{d y}\right)^{2}}\right)<br> $$ 实际计算中，也可以利用别的方法进行估计，如：直接利用像素点边界上的4个顶点进行估算。</li><li>计算该纹理区域大小对应的纹理信息的平均值； 根据得到的覆盖范围 $L$，确定了正方形的大致范围。然后查询该覆盖范围对应的平均纹理信息： $$<br> D = \log_2 L<br> $$<blockquote><p>D rounded to nearest integer level.</p></blockquote> 其中 D对应的是mipmap中的不同层中经过分辨率缩小的纹理图片。</li></ol><h3 id="Mipmap分层带来的不连续问题"><a href="#Mipmap分层带来的不连续问题" class="headerlink" title="Mipmap分层带来的不连续问题"></a>Mipmap分层带来的不连续问题</h3><p>利用该方法发现，不同层之间是离散的，因此当“贴”到物体上时，会出现明显的界限，</p><p><img src="/images/games101/09/2/mipmap_discrete.png" alt="Mipmap分层带来的问题和改进"></p><p>为了平滑过度，需要将不同层的纹理图片之间建立连续的关系——插值。</p><p>复用之前的bilinear方法，相比于之前，这些还需要在不同层之间进行插值，因此称之为——Trilinear Interpolation。</p><p><img src="/images/games101/09/2/trilinear.png" alt="Trilinear Interpolation"></p><h3 id="Mipmap的缺陷"><a href="#Mipmap的缺陷" class="headerlink" title="Mipmap的缺陷"></a>Mipmap的缺陷</h3><p>Mipmap方法的效果如下：</p><p><img src="/images/games101/09/2/mipmap_effect.png" alt="Mipmap方法的效果"></p><p>发现Mipmap相比于Point sampling能够解决部分问题，但是相比于利用MSAA方法，在远处出现了overblur。主要的原因在于mipmop只能处理正方向区域的近似范围查询，但是在上图中显然在远处，会有一些矩形出现，因此用一个正方形覆盖矩形，难免会出现平滑过度的问题，因此远处连成一片了。</p><p><img src="/images/games101/09/2/mipmap_issue.png" alt="Mipmap的缺陷：无法应对不规则图形"></p><p>针对不规则区域映射的问题：</p><ul><li>mipmop只能解决正方形区域近似范围计算的问题；</li><li>Anisotropic Filtering则同时能够对矩形进行范围计算；</li><li>EWA filtering能进一步对不规则放置的四边形进行范围计算；</li></ul><h2 id="解决方案3：Range-Query-Anisotropic-Filtering"><a href="#解决方案3：Range-Query-Anisotropic-Filtering" class="headerlink" title="解决方案3：Range Query - Anisotropic Filtering"></a>解决方案3：Range Query - Anisotropic Filtering</h2><p><img src="/images/games101/09/2/anisotropic.png" alt="Anisotropic Filtering"></p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><blockquote><p>Can look up axis-aligned rectangular zones.</p></blockquote><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><blockquote><p>Diagonal footprints still a problem.</p></blockquote><p>该方法将存储空间提高了3倍：</p><p>$$<br>n \times n + 2 \times \left( \frac{1}{2}n \times n + \frac{1}{2^2}n \times n +  \frac{1}{2^3}n \times n + \cdots \right) = n \times n + 2 \times \frac{\frac{1}{2} \times (1 - \frac{1}{2^{\infty}})}{1 - \frac{1}{2}} n \times n  = 3 n \times n<br>$$</p><h2 id="解决方案4：Range-Query-EWA-filtering"><a href="#解决方案4：Range-Query-EWA-filtering" class="headerlink" title="解决方案4：Range Query - EWA filtering"></a>解决方案4：Range Query - EWA filtering</h2><p><img src="/images/games101/09/2/ewa.png" alt="EWA filtering"></p><h3 id="idea-1"><a href="#idea-1" class="headerlink" title="idea"></a>idea</h3><ul><li>Use multiple lookups：同时使用多个图形近似计算不规则区域；</li><li>Weighted average：对多个图形进行加权计算；</li><li>Mipmap hierarchy still helps</li></ul><h3 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>Can handle irregular footprints</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
            <tag> Texture Mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-09-1：Shading - Texture Mapping - Barycentric coordinates</title>
      <link href="/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-1-shading-texture-mapping-barycentric-coordinates/"/>
      <url>/2022/05/03/ji-suan-ji-tu-xing-xue/games/games101-09-1-shading-texture-mapping-barycentric-coordinates/</url>
      
        <content type="html"><![CDATA[<h1 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一个物体的不同区域使用了相同的着色模型，但是不同区域的漫反射系数 $k_d$ 不同，该系数的不同会导致出现不同的纹理 texture。</p><p>之前提到的着色模型未过多考虑shading point本身的性质，只提到了漫反射系数、镜面反射系数等，但是着色区域本身存在很多不同的性质，这些性质均会影响shading的效果。因此，本质上纹理是逐shading point改变其自身的性质，使得即便在相同的着色模型下，其着色的效果也会有差异。</p><p>那么如何定义着色区域的不同性质呢？引入纹理映射。</p><h2 id="定义shading-point的基本属性"><a href="#定义shading-point的基本属性" class="headerlink" title="定义shading point的基本属性"></a>定义shading point的基本属性</h2><h3 id="Idea-Surfaces-are-2D"><a href="#Idea-Surfaces-are-2D" class="headerlink" title="Idea: Surfaces are 2D"></a>Idea: Surfaces are 2D</h3><ul><li>Surface lives in 3D world space</li><li>Every 3D surface point also has a place where it goes in the 2D image (<strong>texture</strong>).</li></ul><p><img src="/images/games101/09/1/tt_map.png" alt="Texture Mapping"></p><h2 id="纹理如何应用：Texture-Applied-to-Surface"><a href="#纹理如何应用：Texture-Applied-to-Surface" class="headerlink" title="纹理如何应用：Texture Applied to Surface"></a>纹理如何应用：Texture Applied to Surface</h2><p>需要建立三维物体中的三角形与纹理中的三角形的映射关系，保证两者一一对应，同时尽可能少地出现拉伸等情况。</p><p>这种对应关系可以由艺术家完成创造，或者自动化实现。本课中，默认两者已经建立了映射关系，即物体上的每一点均在纹理上有对应的坐标，只需利用这个关系即可。</p><p><img src="/images/games101/09/1/tt_apply.png" alt="Texture Applied to Surface"></p><h2 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h2><p>Each triangle vertex is assigned a texture coordinate $(u,v)$，两个方向的坐标均在$(0,1)$内，以便处理，不考虑其真实像素是多少。</p><p><img src="/images/games101/09/1/tt_location.png" alt="纹理坐标"></p><h2 id="Textures-can-be-used-multiple-times"><a href="#Textures-can-be-used-multiple-times" class="headerlink" title="Textures can be used multiple times"></a>Textures can be used multiple times</h2><p>在纹理映射中，物体上的多个区域可能对应相同的纹理区域，即纹理可以使用多次，当多次使用时，会在相同纹理之间出现不必要的界限，因此如何在多次使用中使相同的纹理之间的过度比较平滑是一个问题。</p><h1 id="Interpolation-Across-Triangles"><a href="#Interpolation-Across-Triangles" class="headerlink" title="Interpolation Across Triangles"></a>Interpolation Across Triangles</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>到目前为止，有两个应用场景需要进行插值：</p><ul><li>Specify values at vertices  shading frequencies 中的 Gouraud shading和Phong shading分别需要对顶点和像素计算法线向量，然后在三角形内部计算相应的颜色等属性；</li><li>Obtain smoothly varying values across triangles  在三维物体与纹理映射中，三角形的顶点在纹理中有相应的纹理坐标，但是三角形内的区域需要通过插值计算相应的纹理坐标，以实现纹理覆盖到物体表面时，能够自然平滑的过度。</li></ul><h2 id="插值针对的对象"><a href="#插值针对的对象" class="headerlink" title="插值针对的对象"></a>插值针对的对象</h2><blockquote><p>Texture coordinates, colors, normal vectors, …</p></blockquote><p>实际上可以对任意属性进行插值。</p><h2 id="如何插值：Barycentric-coordinates"><a href="#如何插值：Barycentric-coordinates" class="headerlink" title="如何插值：Barycentric coordinates"></a>如何插值：Barycentric coordinates</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>首先明确的是，重心坐标是定义在三角形上的，意思是每个三角形都有一个重心坐标系，当三角形不同时，其重心坐标也不同；</li><li>三角形内的任意一点 $(x, y)$ 均可以表示成三角形顶点的线性组合；  $$<br>  (x, y) = \alpha A + \beta B + \gamma C<br>  $$</li><li>其中，称 $(\alpha, \beta, \gamma)$ 为 $(x,y)$ 的重心坐标，其中三者需要满足两个条件：<ul><li>三者相加为1：保证点 $(x,y)$ 在三角形所在的平面上；  $$<br>  \alpha + \beta + \gamma = 1<br>  $$</li><li>三者均为非负值：保证点 $(x,y)$ 在三角形内部；  $$<br>  \alpha \ge 0 \wedge  \beta \ge 0 \wedge \gamma \ge 0<br>  $$</li></ul></li></ul><h3 id="Geometric-viewpoint-—-proportional-areas"><a href="#Geometric-viewpoint-—-proportional-areas" class="headerlink" title="Geometric viewpoint — proportional areas"></a>Geometric viewpoint — proportional areas</h3><p>计算三角形内任意一点的重心坐标，可以从几何面积的角度考虑。</p><p><img src="/images/games101/09/1/area_compute.png" alt="计算任意一点重心坐标"></p><p>三角形的重心的重心坐标：</p><p><img src="/images/games101/09/1/centroid.png" alt="三角形的重心的重心坐标"></p><h3 id="一般化计算公式"><a href="#一般化计算公式" class="headerlink" title="一般化计算公式"></a>一般化计算公式</h3><p><img src="/images/games101/09/1/general_compute.png" alt="重心坐标的一般化计算公式"></p><h3 id="Using-Barycentric-Coordinates"><a href="#Using-Barycentric-Coordinates" class="headerlink" title="Using Barycentric Coordinates"></a>Using Barycentric Coordinates</h3><p>当针对三角形内任意一点计算得到对应的重心坐标后，可以利用该重心坐标对任意的属性进行插值，所谓的插值，在这里指的就是通过对三角形顶点属性的线性组合得到自身的属性。</p><p><img src="/images/games101/09/1/bc_compute.png" alt="重心坐标的应用"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>However, barycentric coordinates are not invariant under projection!</p></blockquote><p>在三角形完成投影后，三角形内任意一点的重心坐标可能发生变化。因此针对3D中的三角形进行插值时，需要利用3D坐标进行插值，而不是利用投影后的2D坐标进行插值，例如：在对3D物体的深度信息时进行插值时。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
            <tag> Texture Mapping </tag>
            
            <tag> Barycentric coordinates </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-08-2：Shading - Graphics Pipeline</title>
      <link href="/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-08-2-shading-graphics-pipeline/"/>
      <url>/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-08-2-shading-graphics-pipeline/</url>
      
        <content type="html"><![CDATA[<h1 id="Graphics-Pipeline"><a href="#Graphics-Pipeline" class="headerlink" title="Graphics Pipeline"></a>Graphics Pipeline</h1><p>从真实世界场景中的物体到最终的一张图的整个过程，其中涉及不同的操作。</p><p><img src="/images/games101/08/2/pipeline.png" alt="Graphics Pipeline"></p><ul><li>Vertex Processing：其实就是MVP变换对应的过程；</li><li>Triangle Processing：是将三维物体中的点全部完成投影后，根据存储的点之间的连接信息，形成三角形，这只是不同的处理方法而已，也可以在投影过程中直接连接。</li></ul><h1 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h1><p><img src="/images/games101/08/2/details.png" alt="Graphics Pipeline各个步骤"></p><p>所有这些过程均已经在GPU硬件上实现，其中对于具体的shading方法可以通过对硬件编程实现，这个编程是判断如何对三角形的顶点和像素进行着色，可以通过代码实现不同的着色结果，这部分代码称之为shader。</p><h1 id="Shader-Programs"><a href="#Shader-Programs" class="headerlink" title="Shader Programs"></a>Shader Programs</h1><ul><li>Program vertex and fragment processing stages</li><li>Describe operation on a single vertex (or fragment)  只需要针对一个顶点或者像素写shader即可；</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>openGL中实现漫反射shader。</p><pre class=" language-cpp"><code class="language-cpp">uniform sampler2D myTexture<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// program parameter</span>uniform vec3 lightDir<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// program parameter</span>varying vec2 uv<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// per fragment value (interp. by rasterizer)</span>varying vec3 norm<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// per fragment value (interp. by rasterizer)</span><span class="token keyword">void</span> <span class="token function">diffuseShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vec3 kd<span class="token punctuation">;</span>    kd <span class="token operator">=</span> <span class="token function">texture2d</span><span class="token punctuation">(</span>myTexture<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// material color from texture</span>    kd <span class="token operator">*</span><span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>–lightDir<span class="token punctuation">,</span> norm<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Lambertian shading model</span>    gl_FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>kd<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// output fragment color</span><span class="token punctuation">}</span></code></pre><ul><li>Shader function executes once per fragment.</li><li>Outputs color of surface at the current fragment’s screen sample position.</li><li>This shader performs a texture lookup to obtain the surface’s material color at this point, then performs a diffuse lighting calculation.</li></ul><h1 id="Graphics-Pipeline-Implementation-GPUs"><a href="#Graphics-Pipeline-Implementation-GPUs" class="headerlink" title="Graphics Pipeline Implementation: GPUs"></a>Graphics Pipeline Implementation: GPUs</h1><p>Specialized processors for executing graphics pipeline computations:</p><ul><li>Discrete GPU Card</li><li>Integrated GPU (Part of Intel CPU die)</li></ul><p><img src="/images/games101/08/2/gpu.png" alt="GPUs"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
            <tag> Graphics Pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-08-1：Shading - Shading Frequencies</title>
      <link href="/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-08-1-shading-shading-frequencies/"/>
      <url>/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-08-1-shading-shading-frequencies/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>前面的Blinn-Phong Model是针对单个shading point进行着色，下一步是针对具体的物体进行着色。</p><p>对于同样的几何物体，不同的着色频率会导致不同的结果，如下图：</p><p><img src="/images/games101/08/1/problem.png" alt="对真实物理对象着色时的问题"></p><ul><li>图1是针对一个面进行着色，即在一个面上只着色一次；</li><li>图2是针对三角形的顶点进行着色，然后三角形内部通过插值补全其他的着色区域；</li><li>图3是针对每个像素进行着色，通过计算三角形顶点的法线方向，然后对每个像素的法线方向进行插值，然后进行着色；</li></ul><p>这三种方法，效果是越来越好，但是计算量也是越来越大。</p><h1 id="Flat-shading-shade-each-triangle"><a href="#Flat-shading-shade-each-triangle" class="headerlink" title="Flat shading: shade each triangle"></a>Flat shading: shade each triangle</h1><ul><li>Triangle face is flat — one normal vector</li><li>Not good for smooth surfaces</li></ul><p><img src="/images/games101/08/1/flat.png" alt="Flat shading的效果"></p><h1 id="Gouraud-shading-shade-each-vertex"><a href="#Gouraud-shading-shade-each-vertex" class="headerlink" title="Gouraud shading: shade each vertex"></a>Gouraud shading: shade each vertex</h1><ul><li>Interpolate colors from vertices across triangle<ul><li>插值的内容在后续的课程中提供；</li></ul></li><li>Each vertex has a normal vector</li></ul><p><img src="/images/games101/08/1/gouraud.png" alt="Gouraud shading的效果"></p><h2 id="Defining-Per-Vertex-Normal-Vectors"><a href="#Defining-Per-Vertex-Normal-Vectors" class="headerlink" title="Defining Per-Vertex Normal Vectors"></a>Defining Per-Vertex Normal Vectors</h2><h3 id="From-the-underlying-geometry"><a href="#From-the-underlying-geometry" class="headerlink" title="From the underlying geometry"></a>From the underlying geometry</h3><p>Best to get vertex normals from the underlying geometry：过于理想；</p><ul><li>e.g. consider a sphere</li></ul><p><img src="/images/games101/08/1/geometry_normal.png" alt="利用平面所覆盖的图形计算法线向量"></p><h3 id="利用邻居进行平均"><a href="#利用邻居进行平均" class="headerlink" title="利用邻居进行平均"></a>利用邻居进行平均</h3><p>一般化的方法： infer vertex normals from triangle faces</p><ul><li>简单方法: average surrounding face normals；  其中 N_v是顶点的法线向量，$N_i$ 是该顶点相邻的三角形的法线向量。计算完成后，需要将得到的法线向量归一化，因为只关心方向。</li></ul><p>$$<br>N_v = \frac{\sum_{i}{}N_i}{\Vert \sum_{i}{}N_i \Vert}<br>$$</p><p><img src="/images/games101/08/1/vertex_normal.png" alt="计算Vertex的法线向量"></p><ul><li>加权平均：按照三角形面积进行法线向量的平均；</li></ul><h1 id="Phong-shading-shade-each-pixel"><a href="#Phong-shading-shade-each-pixel" class="headerlink" title="Phong shading: shade each pixel"></a>Phong shading: shade each pixel</h1><ul><li>Interpolate normal vectors across each triangle</li><li>Compute full shading model at each pixel</li><li>Not the Blinn-Phong Reflectance Model：与Phong shading均为同一个人提出的；</li></ul><p><img src="/images/games101/08/1/phong.png" alt="Phong shading的效果"></p><h2 id="Defining-Per-Pixel-Normal-Vectors"><a href="#Defining-Per-Pixel-Normal-Vectors" class="headerlink" title="Defining Per-Pixel Normal Vectors"></a>Defining Per-Pixel Normal Vectors</h2><p>根据之前得到了三角形顶点的法线向量，可以利用顶点的法线向量进一步得到每个像素的向量，这里需要利用 Barycentric interpolation of vertex normals 来完成，后续会介绍。</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>这三种方法不一定是哪种一定最好，如下图：当物体的顶点很多时，或者三角形很密集时，使用简单的Face shading效果也不错。</p><p><img src="/images/games101/08/1/compare.png" alt="三种着色频率效果的对比"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-07：Shading - Blinn-Phong Model</title>
      <link href="/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-07-shading-blinn-phong-model/"/>
      <url>/2022/05/01/ji-suan-ji-tu-xing-xue/games/games101-07-shading-blinn-phong-model/</url>
      
        <content type="html"><![CDATA[<h1 id="Shading含义"><a href="#Shading含义" class="headerlink" title="Shading含义"></a>Shading含义</h1><ul><li>Merriam-Webster Dictionary  The darkening or coloring of an illustration or diagram with parallel lines or a block of color</li><li>本课定义  The process of applying a material to an object.</li></ul><h1 id="Blinn-Phong-Reflectance-Model"><a href="#Blinn-Phong-Reflectance-Model" class="headerlink" title="Blinn-Phong Reflectance Model"></a>Blinn-Phong Reflectance Model</h1><h2 id="Perceptual-Observations"><a href="#Perceptual-Observations" class="headerlink" title="Perceptual Observations"></a>Perceptual Observations</h2><ul><li>Specular highlights 高光</li><li>Diffuse reflection: 漫反射</li><li>Ambient lighting：环境光照，未被光源照亮的地方应该是黑暗的，但是一些间接光照会使得该地方接收到部分光，在该模型中视为常量；</li></ul><p><img src="/images/games101/07/obser.png" alt="Blinn-Phong Model中的三种元素"></p><h2 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h2><h3 id="Shading-point"><a href="#Shading-point" class="headerlink" title="Shading point"></a>Shading point</h3><blockquote><p>Compute light reflected toward camera at a specific <strong>shading point</strong>.</p></blockquote><p>Inputs:</p><ul><li>Viewer direction, $v$</li><li>Surface normal, $n$</li><li>Light direction, $l$ (for each of many lights)</li><li>Surface parameters (color, shininess, …)：待着色物体的一些性质；</li></ul><p>所有的向量都是单位向量，因为只考虑方向，不考虑大小。</p><p><img src="/images/games101/07/shading_point.png" alt="Shading point"></p><h3 id="Shading-is-Local"><a href="#Shading-is-Local" class="headerlink" title="Shading is Local"></a>Shading is Local</h3><p>着色是局部，怎么理解？即着色是针对shading point来说的，不考虑其他因素，例如：遮挡、背影等，即不同的点的着色过程是彼此独立的，之间没有关系。不会因为一些物体遮挡另一些物体导致无法着色。</p><p><img src="/images/games101/07/local.png" alt="Shading不考虑阴影"></p><h1 id="Diffuse-Reflection"><a href="#Diffuse-Reflection" class="headerlink" title="Diffuse Reflection"></a>Diffuse Reflection</h1><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>Light is scattered uniformly in all directions</p><ul><li>Surface color is the same for all viewing directions</li></ul><p><img src="/images/games101/07/diffuse.png" alt="Diffuse Reflection"></p><h2 id="Lambertian-Shading"><a href="#Lambertian-Shading" class="headerlink" title="Lambertian Shading"></a><strong>Lambertian Shading</strong></h2><h3 id="Lambert’s-cosine-law"><a href="#Lambert’s-cosine-law" class="headerlink" title="Lambert’s cosine law"></a>Lambert’s cosine law</h3><p>在光的传播中，有多少光被shading point接收了？取决于shading point的法线角度和光的传输方向。</p><p><img src="/images/games101/07/lambert.png" alt="Lambert’s cosine law"></p><h3 id="光的能量传递"><a href="#光的能量传递" class="headerlink" title="光的能量传递"></a>光的能量传递</h3><blockquote><p>假设：光在真空中传递，没有能量损失，因此光的能量在不同的时间点，在不同的范围内是守恒的。</p></blockquote><p>设定距离光源长度为1的球面上，单位面积接收的光的能量为 $I$。在距离光源长度为 $r^2$ 的球面上单位面积上的光的能量是 $\frac{I}{r^2}$ 。</p><p><img src="/images/games101/07/intensity.png" alt="假设光的能量传递没有损失"></p><h3 id="漫发射的光"><a href="#漫发射的光" class="headerlink" title="漫发射的光"></a>漫发射的光</h3><p>考虑的因素：</p><ul><li>shading point距离光源的距离；</li><li>光源入射的角度：也就是光线方向与shading point法线的夹角，这里只考虑反射，不考虑折射；</li><li>shading point自身的特性：其可能吸收部分光，并不会将所有的光全部反射出去；</li><li>Shading independent of view direction：即观察者从任何方向看都会得到一致的结果；</li></ul><p><img src="/images/games101/07/diffuse_term.png" alt="Diffuse Term"></p><p>注意：</p><ul><li>该推导是一个经验公式，并不代表它在数学上是正确的（所有模型都是错的，但有一些有用）；</li><li>其中，$k_d$ 作为漫反射系数决定了亮度和颜色；  <img src="/images/games101/07/kd.png" alt="漫反射系数的影响"></li><li>$max(…)$ 决定了不考虑光从shading point底部射入的情况，即折射的情况；</li></ul><h1 id="Specular-Term"><a href="#Specular-Term" class="headerlink" title="Specular Term"></a>Specular Term</h1><h2 id="何时出现高光"><a href="#何时出现高光" class="headerlink" title="何时出现高光"></a>何时出现高光</h2><p>“高光”表示shading point所在的平面相对较光滑，因此可以近似为镜面反射。当观察方向与镜面反射的方向趋近时，可以看到高光，即：</p><ul><li>Intensity depends on view direction</li><li>Bright near mirror reflection direction</li></ul><p><img src="/images/games101/07/specular.png" alt="Specular highlights"></p><h2 id="如何对高光建模"><a href="#如何对高光建模" class="headerlink" title="如何对高光建模"></a>如何对高光建模</h2><p>想法转换：对于将<strong>观察方向与镜面反射的方向趋近，表示为入射和观察方向的半程向量与shading point的法线方向趋近。</strong>（因为之前的）</p><p><img src="/images/games101/07/specular_term.png" alt="Specular Term"></p><p>注意：</p><ul><li>衡量向量接近：使用dot product；</li><li>这里没有考虑有多少光被吸收，类似于漫反射中需要对 $l,n$ 进行dot product，做了简化；</li><li>$k_s$ 是surface的镜面反射系数，与漫反射中的 $k_d$ 含义相同；  <img src="/images/games101/07/ks_p.png" alt="镜面反射系数和p的影响"></li><li>指数 $p$ 的作用：increasing p narrows the reflection lobe 限制高光的范围，即高光只在特定的范围内出现，超过这个范围则看不到，该指数使得能够快速衰减高光的值。一般取100，200等。  <img src="/images/games101/07/p.png" alt="指数p能衰减高光"></li></ul><h1 id="Ambient-Term"><a href="#Ambient-Term" class="headerlink" title="Ambient Term"></a>Ambient Term</h1><p>Shading that does not depend on anything: </p><ul><li>Add constant color to account for disregarded<br>illumination and fill in black shadows</li><li>This is approximate / fake!</li></ul><p><img src="/images/games101/07/ambient_term.png" alt="Ambient Term"></p><p>注意，这里的环境光：</p><ul><li>与光的入射方向无关；</li><li>与观察方向也无关；</li><li>其根本作用是保证未被光照到的地方不会黑暗；</li></ul><h1 id="总结：Blinn-Phong-Reflection-Model"><a href="#总结：Blinn-Phong-Reflection-Model" class="headerlink" title="总结：Blinn-Phong Reflection Model"></a>总结：Blinn-Phong Reflection Model</h1><p>$$<br>\begin{aligned}L &amp;=L_{a}+L_{d}+L_{s} \\ &amp;=<br>k_{a} I_{a}+k_{d}\left( \frac{I}{r^{2}} \right) \max (0, \mathbf{n} \cdot \mathbf{l})+k_{s}\left(\frac{I}{r^2} \right) \max (0, \mathbf{n} \cdot \mathbf{h})^{p}\end{aligned}<br>$$</p><p><img src="/images/games101/07/summary.png" alt="Blinn-Phong Reflection Model中不同项对应的效果"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shading </tag>
            
            <tag> Blinn-Phong Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-06-2：Rasterization - Z-Buffering</title>
      <link href="/2022/04/30/ji-suan-ji-tu-xing-xue/games/games101-06-2-rasterization-z-buffering/"/>
      <url>/2022/04/30/ji-suan-ji-tu-xing-xue/games/games101-06-2-rasterization-z-buffering/</url>
      
        <content type="html"><![CDATA[<h1 id="问题：Visibility-occlusion"><a href="#问题：Visibility-occlusion" class="headerlink" title="问题：Visibility / occlusion"></a>问题：Visibility / occlusion</h1><p>很多不同的三角形彼此重叠，与相机之间也存在不同的距离，</p><h1 id="Painter’s-Algorithm"><a href="#Painter’s-Algorithm" class="headerlink" title="Painter’s Algorithm"></a>Painter’s Algorithm</h1><ul><li>Inspired by how painters paint</li><li>Paint from back to front, overwrite in the framebuffer</li></ul><h2 id="朴素想法"><a href="#朴素想法" class="headerlink" title="朴素想法"></a>朴素想法</h2><ul><li>Requires sorting in depth $(O(n \log n)$ for n triangles)</li></ul><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ul><li>Can have unresolvable depth order：有时无法得到深度排序；</li><li>因此实际中不会使用该算法；</li></ul><p><img src="/images/games101/06/2/un_do.png" alt="无法对深度进行排序"></p><h1 id="Z-Buffer"><a href="#Z-Buffer" class="headerlink" title="Z-Buffer"></a>Z-Buffer</h1><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><ul><li>Store <strong>current min. z-value for each sample</strong> (pixel)  所有操作都是针对像素来说的；</li><li>Needs an additional buffer for depth values<ul><li>frame buffer stores color values：对应最后的结果；</li><li>depth buffer (z-buffer) stores depth：对应深度缓存的图；</li></ul></li></ul><blockquote><p>备注：For simplicity we suppose $z$ is always positive (smaller $z$ -&gt; closer, larger $z$ -&gt; further)。</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="/images/games101/06/2/frame_depth_buffer.png" alt="Frame &amp; Depth Buffer"></p><p>深度值小，对应的是黑色。</p><h2 id="Z-Buffer-Algorithm"><a href="#Z-Buffer-Algorithm" class="headerlink" title="Z-Buffer Algorithm"></a>Z-Buffer Algorithm</h2><pre class=" language-cpp"><code class="language-cpp">Initialize depth buffer to <span class="token operator">+</span>infDuring rasterization<span class="token operator">:</span><span class="token keyword">for</span> <span class="token punctuation">(</span>each triangle T<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>each <span class="token function">sample</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span> in T<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">&lt;</span> zbuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// closest sample so far</span>            framebuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> rgb<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// update color</span>            zbuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> z<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// update depth</span>        <span class="token keyword">else</span>            <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// do nothing, this sample is occluded</span></code></pre><p><img src="/images/games101/06/2/zbuffer.png" alt="Z buffering"></p><h2 id="Z-Buffer-Complexity"><a href="#Z-Buffer-Complexity" class="headerlink" title="Z-Buffer Complexity"></a>Z-Buffer Complexity</h2><p>Complexity</p><ul><li>$O(n)$ for n triangles (assuming constant coverage)</li></ul><p>How is it possible to sort n triangles in linear time?</p><ul><li>这里并没有对深度信息进行排序；</li></ul><p>Drawing triangles in different orders?</p><ul><li>结果仍然相同，绘制三角形的顺序不影响最终的结果（不同三角形之间的深度值不存在重复）。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Most important visibility algorithm</li><li>Implemented in hardware for all GPUs</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光栅化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-06-1：Rasterization - Antialiasing</title>
      <link href="/2022/04/30/ji-suan-ji-tu-xing-xue/games/games101-06-1-rasterization-antialiasing/"/>
      <url>/2022/04/30/ji-suan-ji-tu-xing-xue/games/games101-06-1-rasterization-antialiasing/</url>
      
        <content type="html"><![CDATA[<h1 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h1><h2 id="常见的采样"><a href="#常见的采样" class="headerlink" title="常见的采样"></a>常见的采样</h2><ul><li>Rasterization = Sample 2D Positions</li><li>Photograph = Sample Image Sensor Plane</li><li>Video = Sample Time</li></ul><p><img src="/images/games101/06/1/sample_ex.png" alt="Sampling Examples"></p><h2 id="采样会产生问题——Aliasing"><a href="#采样会产生问题——Aliasing" class="headerlink" title="采样会产生问题——Aliasing"></a>采样会产生问题——Aliasing</h2><p>Sampling Artifacts (Errors / Mistakes / Inaccuracies) in Computer Graphics：</p><ul><li>Jaggies (Staircase Pattern)：This is also an example of “aliasing” – a sampling error；  <img src="/images/games101/06/1/jaggies.png" alt="Jaggies"></li><li>Moiré Patterns in Imaging：Skip odd rows and columns  <img src="/images/games101/06/1/mp.png" alt="Moiré Patterns"></li><li>Wagon Wheel Illusion (False Motion)：人眼对时间的采样无法跟上运动的速度。  <img src="/images/games101/06/1/wwi.png" alt="Wagon Wheel Illusion"></li></ul><p>Behind the Aliasing Artifacts: Signals are changing too fast (high frequency), but sampled too slowly.</p><h2 id="如何Antialiasing"><a href="#如何Antialiasing" class="headerlink" title="如何Antialiasing"></a>如何Antialiasing</h2><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><p>Blurring (Pre-Filtering) Before Sampling. 采样之前进行模糊（滤波）。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在Rasterization的过程中，反走样方法的效果：</p><ul><li>只采样：Note jaggies in rasterized triangle where pixel values are pure red or white;</li><li>模糊再采样：Note antialiased edges in rasterized triangle where pixel values take intermediate values;</li></ul><p><img src="/images/games101/06/1/only_sample.png" alt="只采样"></p><p><img src="/images/games101/06/1/blur.png" alt="模糊再采样"></p><h3 id="Blurred-Aliasing-先采样再模糊行吗？"><a href="#Blurred-Aliasing-先采样再模糊行吗？" class="headerlink" title="Blurred Aliasing: 先采样再模糊行吗？"></a>Blurred Aliasing: 先采样再模糊行吗？</h3><p>不可以，下图中左上是原始图形，右上和右下均为先模糊再采样，左下则为先采样再模糊，发现仍然有走样现象。</p><p><img src="/images/games101/06/1/blur_sample.png" alt="先模糊再采样"></p><p><img src="/images/games101/06/1/sample_blur.png" alt="先采样再模糊"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>Why undersampling introduces aliasing?</li><li>Why pre-filtering then sampling can do antialiasing?</li></ol><h1 id="Fourier-Transform"><a href="#Fourier-Transform" class="headerlink" title="Fourier Transform"></a>Fourier Transform</h1><h2 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h2><p><img src="/images/games101/06/1/freq.png" alt="频率定义"></p><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><blockquote><p>Represent a function as a weighted sum of sines and cosines.</p></blockquote><p>注意：这里的函数不一定是传统的周期函数，也可以是非周期函数，只是将非周期函数的周期视为无穷大而已。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>Fourier Transform Decomposes A Signal Into Frequencies.</p></blockquote><p><img src="/images/games101/06/1/ft.png" alt="Fourier Transform"></p><h2 id="解释Aliasing"><a href="#解释Aliasing" class="headerlink" title="解释Aliasing"></a>解释Aliasing</h2><h3 id="Higher-Frequencies-Need-Faster-Sampling"><a href="#Higher-Frequencies-Need-Faster-Sampling" class="headerlink" title="Higher Frequencies Need Faster Sampling"></a>Higher Frequencies Need Faster Sampling</h3><ul><li>对低频信号的采样，采样率与信号频率相差不多，也能够大致重建原始信号；</li><li>对高频信号的采样，当采样率过低时，重建原始信号时会出现错误；</li></ul><p><img src="/images/games101/06/1/sample_freq.png" alt="对不同频率信号采样和重建"></p><h3 id="Undersampling-Creates-Frequency-Aliases"><a href="#Undersampling-Creates-Frequency-Aliases" class="headerlink" title="Undersampling Creates Frequency Aliases"></a>Undersampling Creates Frequency Aliases</h3><p>使用同样的采样率对两个不同频率的函数采样，发现得到的结果相同，也就是说，利用该采样得到的结果重建信号时，无法区分原始信号是哪个。</p><p><img src="/images/games101/06/1/undersampling.png" alt="用相同采样率采样不同信号"></p><ul><li>High-frequency signal is insufficiently sampled: samples erroneously appear to be from a low-frequency signal</li><li>Two frequencies that are indistinguishable at a given sampling rate are called “aliases”</li></ul><h1 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>Filtering = Getting rid of certain frequency contents.</p></blockquote><p><img src="/images/games101/06/1/freq_cont.png" alt="傅里叶变换后的频域信息"></p><p>傅里叶变换的频域信息如何理解？</p><ul><li>中心是最低频，周围是高频内容；</li><li>频域的信息通过通过右图中的亮度表示，信息越多，则越亮；<ul><li>图中每一点的灰度值描述的是正弦或者余弦函数的振幅；</li></ul></li><li>中间有两个交叉的亮十字如何理解？<ul><li>因为将分析的信号视为周期重复性信号，但是对于不重复的信号，例如图片，则将其视为水平方向重复很多，竖直方向也重复很多；</li></ul></li></ul><p><img src="/images/games101/06/1/repeat.png" alt="二维图像重复"></p><h3 id="Filtering可得到特定频域信息"><a href="#Filtering可得到特定频域信息" class="headerlink" title="Filtering可得到特定频域信息"></a>Filtering可得到特定频域信息</h3><ul><li>High-pass filter</li><li>Low-pass filter</li><li>Filter Out Low and High Frequencies</li></ul><h2 id="Filtering-Convolution-Averaging"><a href="#Filtering-Convolution-Averaging" class="headerlink" title="Filtering = Convolution (= Averaging)"></a>Filtering = Convolution (= Averaging)</h2><h3 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h3><blockquote><p>Point-wise local averaging in a “sliding window”.</p></blockquote><p>这里的操作与数学上的定义不同，如果严格按照数学定义需要旋转卷积核。</p><p><img src="/images/games101/06/1/conv.png" alt="卷积操作"></p><h3 id="Convolution-Theorem"><a href="#Convolution-Theorem" class="headerlink" title="Convolution Theorem"></a>Convolution Theorem</h3><blockquote><p>Convolution in the spatial domain is equal to multiplication in the frequency domain, and vice versa.</p></blockquote><p>根据卷积定理，以下两种操作是等价的：</p><ul><li>Option 1<ul><li>Filter by convolution in the spatial domain</li></ul></li><li>Option 2<ul><li>Transform to frequency domain (Fourier transform)</li><li>Multiply by Fourier transform of convolution kernel</li><li>Transform back to spatial domain (inverse Fourier)</li></ul></li></ul><p><img src="/images/games101/06/1/conv_theorem.png" alt="卷积定理"></p><h3 id="Box-Filter"><a href="#Box-Filter" class="headerlink" title="Box Filter"></a>Box Filter</h3><p>$$<br>\frac{1}{9}<br>\left(<br>\begin{array}{lll}<br>1 &amp; 1 &amp; 1 \\<br>1 &amp; 1 &amp; 1 \\<br>1 &amp; 1 &amp; 1<br>\end{array}<br>\right)<br>$$</p><p>归一化操作是为了不会影响亮度的剧烈变化。</p><ul><li>Box Function = “Low Pass” Filter  左侧是时域信息，右侧是频域信息。  <img src="/images/games101/06/1/box_f.png" alt="Box Function"></li><li>Wider Filter Kernel = Lower Frequencies  <img src="/images/games101/06/1/wfk.png" alt="Wider Filter Kernel">  理解方式：当卷积核变大，说明移动的窗口覆盖的范围变大，因为有更多的区域被“平滑”了，因此高频信息都消失了。从极端的角度理解，当卷积核与图像相同时，整个图像都被“平滑”了，对应到频域信息中的区域会更小。当卷积核的大小与一个像素相同时，说明图像没有被“平滑”，因此频域信息不变。</li></ul><h1 id="回顾Sampling"><a href="#回顾Sampling" class="headerlink" title="回顾Sampling"></a>回顾Sampling</h1><h2 id="Sampling-Repeating-Frequency-Contents"><a href="#Sampling-Repeating-Frequency-Contents" class="headerlink" title="Sampling=Repeating Frequency Contents"></a>Sampling=Repeating Frequency Contents</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p><img src="/images/games101/06/1/repeat_freq.png" alt="Repeating Frequency Contents"></p><h2 id="解释Aliasing-1"><a href="#解释Aliasing-1" class="headerlink" title="解释Aliasing"></a>解释Aliasing</h2><blockquote><p>Aliasing = Mixed Frequency Contents</p></blockquote><p><img src="/images/games101/06/1/mfc.png" alt="Mixed Frequency Contents"></p><h1 id="Antialiasing"><a href="#Antialiasing" class="headerlink" title="Antialiasing"></a>Antialiasing</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>How Can We Reduce Aliasing Error?</p><ul><li>Increase sampling rate：适用不同设备，成本太高；<ul><li>Essentially increasing the distance between replicas in the Fourier domain</li><li>Higher resolution displays, sensors, framebuffers…</li><li>But: costly &amp; may need very high resolution</li></ul></li><li><strong>Antialiasing：可以应用在同一设备上，主要策略</strong>；<ul><li>Making Fourier contents “narrower” before repeating</li><li>i.e. Filtering out high frequencies before sampling</li></ul></li></ul><h2 id="idea-limiting-then-repeating"><a href="#idea-limiting-then-repeating" class="headerlink" title="idea: limiting, then repeating"></a>idea: limiting, then repeating</h2><p><img src="/images/games101/06/1/ltr.png" alt="Limiting, then repeating"></p><p>既然通过先模糊再采样的方法可以有效反走样，采样的方法已知，<strong>需要解决的是如何进行模糊的问题？</strong></p><h2 id="A-Practical-Pre-Filter"><a href="#A-Practical-Pre-Filter" class="headerlink" title="A Practical Pre-Filter"></a>A Practical Pre-Filter</h2><blockquote><p>Antialiasing By Averaging Values in Pixel Area.</p></blockquote><p>A 1 pixel-width box filter (low pass, blurring)</p><p><img src="/images/games101/06/1/pre_filter.png" alt="Practical Pre-Filter"></p><p>具体操作过程：</p><ol><li>Convolve $f(x,y)$ by a 1-pixel box-blur</li><li>Then sample at every pixel’s center</li></ol><p>In rasterizing one triangle, the average value inside a pixel area of $f(x,y) = \text{inside}(\text{triangle},x,y)$ is equal to the area of the pixel covered by the triangle.</p><p><img src="/images/games101/06/1/pre_filtering.png" alt="Pre-Filtering"></p><h2 id="如何实现1-pixel-width-box-filter"><a href="#如何实现1-pixel-width-box-filter" class="headerlink" title="如何实现1 pixel-width box filter"></a>如何实现1 pixel-width box filter</h2><blockquote><p>对反走样解决方案的近似，不能严格解决反走样的问题。</p></blockquote><h3 id="Supersampling-MSAA"><a href="#Supersampling-MSAA" class="headerlink" title="Supersampling (MSAA)"></a>Supersampling (MSAA)</h3><p>Approximate the effect of the 1-pixel box filter by sampling multiple locations within a pixel and averaging their values.</p><p>将一个像素分成若干个小像素，然后再执行具体的操作。之前的方法，只需要针对一个像素本身判断是否在三角形内，现在需要针对一个像素中划分的更小的单元判断是否在三角形内，然后对整个像素进行平均。</p><p><img src="/images/games101/06/1/msaa.png" alt="MSAA"></p><h3 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h3><p>MSAA增加了计算量，依赖将一个像素分割的方法。例如：如果是$4 \times 4$ ，则计算量增加了16倍，每个更小的像素中的点均要判断是否在三角形内。</p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p>MSAA中将一个像素进行了均匀的划分，但是在实际中更多的是采用不太规则的划分，这样一个更小的单元可以被多个像素点进行共享，使得在判断该单元在三角形内的操作并不是严格是之前的16倍（在$4 \times 4$ 的划分下），因此效率会有提升。</p><h3 id="工业界广泛使用的方法"><a href="#工业界广泛使用的方法" class="headerlink" title="工业界广泛使用的方法"></a>工业界广泛使用的方法</h3><ul><li>FXAA (Fast Approximate AA)：与采样无关的方法，在图像操作上的抗锯齿，基本思路是先模糊，然后将模糊后的图像中的锯齿去掉；</li><li>TAA (Temporal AA)：复用上一帧的结果；</li></ul><h2 id="区别概念-Super-resolution"><a href="#区别概念-Super-resolution" class="headerlink" title="区别概念 Super resolution"></a>区别概念 Super resolution</h2><ul><li>From low resolution to high resolution</li><li>Essentially still “not enough samples” problem</li><li>DLSS (Deep Learning Super Sampling): 使用深度学习来“猜测”图像放大后缺失的信息，这些缺失后的信息如果没有补全则会出现“锯齿”问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光栅化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-05：Rasterization - Triangles</title>
      <link href="/2022/04/29/ji-suan-ji-tu-xing-xue/games/games101-05-rasterization-triangles/"/>
      <url>/2022/04/29/ji-suan-ji-tu-xing-xue/games/games101-05-rasterization-triangles/</url>
      
        <content type="html"><![CDATA[<h1 id="Viewing之后"><a href="#Viewing之后" class="headerlink" title="Viewing之后"></a>Viewing之后</h1><ul><li>Model transformation (placing objects)</li><li>View transformation (placing camera)</li><li>Projection transformation<ul><li>Orthographic projection (cuboid to “canonical” cube $[-1, 1]^3$)</li><li>Perspective projection (frustum to “canonical” cube)</li></ul></li><li>Canonical cube to?</li></ul><p>继续：将之前得到的立方体绘制到屏幕上。</p><h1 id="Canonical-Cube-to-Screen"><a href="#Canonical-Cube-to-Screen" class="headerlink" title="Canonical Cube to Screen"></a>Canonical Cube to Screen</h1><h2 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h2><ul><li>What is a screen<ul><li>An array of pixels</li><li>Size of the array: resolution 表示像素的多少。</li><li>A typical kind of raster display</li></ul></li><li>Raster == screen in German<ul><li>Rasterize == drawing onto the screen</li></ul></li><li>Pixel (FYI, short for “picture element”)<ul><li>For now: A pixel is a little square with uniform color  简化表示</li><li>Color is a mixture of (red, green, blue)</li></ul></li></ul><h2 id="Screen-space"><a href="#Screen-space" class="headerlink" title="Screen space"></a>Screen space</h2><p><img src="/images/games101/05/screen_space.png" alt="Screen space"></p><p>规则：</p><ul><li>Pixels’ indices are in the form of $(x, y)$, where both x and y are integers.</li><li>Pixels’ indices are from $(0, 0)$ to (width - 1, height - 1).</li><li>Pixel $(x, y)$ is centered at $(x + 0.5, y + 0.5)$ . 坐标实际中心</li><li>The screen covers range $(0, 0)$ to (width, height).</li></ul><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p><img src="/images/games101/05/vp_trans.png" alt="Viewport transform"></p><ul><li>Irrelevant to z</li><li>Transform in xy plane: $[-1, 1]^2$ to [0, width] x [0, height]</li><li>Viewport transform matrix: 视口变换</li></ul><p>$$<br>M_{\text {viewport}}=\left(\begin{array}{cccc}\frac{w i d t h}{2} &amp; 0 &amp; 0 &amp; \frac{\text { width }}{2} \\<br>0 &amp; \frac{\text { height }}{2} &amp; 0 &amp; \frac{\text { height }}{2} \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>$$</p><p>到此为止得到了2D上的图片。</p><h1 id="Rasterizing-Triangles-into-Pixels"><a href="#Rasterizing-Triangles-into-Pixels" class="headerlink" title="Rasterizing Triangles into Pixels"></a>Rasterizing Triangles into Pixels</h1><p>接下来，将图片分解为像素，也就是光栅化的过程。</p><h2 id="Drawing-Machines"><a href="#Drawing-Machines" class="headerlink" title="Drawing Machines"></a>Drawing Machines</h2><ul><li>CNC Sharpie Drawing Machine</li><li>Laser Cutters</li></ul><h2 id="Different-Raster-Displays"><a href="#Different-Raster-Displays" class="headerlink" title="Different Raster Displays"></a>Different Raster Displays</h2><ul><li>Oscilloscope 示波器</li><li>Cathode Ray Tube 阴极射线管<ul><li>Television - Raster Display CRT</li></ul></li><li>Frame Buffer: Memory for a Raster Display</li><li>Flat Panel Displays<ul><li>LCD (Liquid Crystal Display)</li><li>LED Array Display</li></ul></li><li>Electrophoretic (Electronic Ink) Display</li></ul><h1 id="Rasterization-Drawing-to-Raster-Displays"><a href="#Rasterization-Drawing-to-Raster-Displays" class="headerlink" title="Rasterization: Drawing to Raster Displays"></a>Rasterization: Drawing to Raster Displays</h1><h2 id="Triangles-Fundamental-Shape-Primitives"><a href="#Triangles-Fundamental-Shape-Primitives" class="headerlink" title="Triangles - Fundamental Shape Primitives"></a>Triangles - Fundamental Shape Primitives</h2><h3 id="Why-triangles"><a href="#Why-triangles" class="headerlink" title="Why triangles?"></a>Why triangles?</h3><ul><li>Most basic polygon<ul><li>Break up other polygons</li></ul></li><li>Unique properties<ul><li>Guaranteed to be planar  三角形一定是平面图形</li><li>Well-defined interior 内外容易区分</li><li>Well-defined method for interpolating values at vertices over triangle (barycentric interpolation) 根据顶点的信息可以对其中其中任意一点进行插值。</li></ul></li></ul><h2 id="问题：What-Pixel-Values-Approximate-a-Triangle"><a href="#问题：What-Pixel-Values-Approximate-a-Triangle" class="headerlink" title="问题：What Pixel Values Approximate a Triangle?"></a>问题：What Pixel Values Approximate a Triangle?</h2><p><img src="/images/games101/05/pv_appro.png" alt="Pixel Values Approximate"></p><h2 id="解决方法：Sampling"><a href="#解决方法：Sampling" class="headerlink" title="解决方法：Sampling"></a>解决方法：Sampling</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li>Evaluating a function at a point is sampling.</li><li>We can discretize a function by sampling.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> xmax<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span>    output<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li>Sampling is a core idea in graphics.<ul><li>We sample time (1D), area (2D), direction (2D), volume (3D)</li></ul></li></ul><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><ul><li>Sample If Each Pixel Center Is Inside Triangle</li><li>Define Binary Function: $\text{inside}(t, x, y)$<ul><li>x, y: not necessarily integers</li></ul></li></ul><!-- $$f=\left\\{\begin{array}{l}1\\\\0\end{array}\right.$$ --><p>  $$<br>  \text{inside}(t, x, y)=<br>  \left\{<br>  \begin{array}{ll}<br>  1 &amp; \begin{array}{l} \text{Point (x, y) in triangle } t\end{array} \\<br>  0 &amp; \text {otherwise}<br>  \end{array}<br>  \right.<br>  $$</p><p>整体过程表示如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> xmax<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> ymax<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span>        image<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">inside</span><span class="token punctuation">(</span>tri<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述过程中要解决的一个问题是：如何判断点 $(x,y)$ 在三角形内。使用之前cross product中提到的方法。</p><p>最后的结果：</p><p><img src="/images/games101/05/tri_compare.png" alt="光栅化前后三角形的对比"></p><p>存在锯齿问题！</p><h3 id="Edge-Cases"><a href="#Edge-Cases" class="headerlink" title="Edge Cases"></a>Edge Cases</h3><p>Is this sample point covered by triangle 1, triangle 2, or both? 自己决定，不作要求。</p><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><ul><li>普遍策略：Checking All Pixels on the Screen?  Use a Bounding Box!</li></ul><p><img src="/images/games101/05/box.png" alt="基本优化策略 - Use a Bounding Box"></p><ul><li>进一步优化：Incremental Triangle Traversal，每一行都找边界，suitable for thin and rotated triangles，但是实践起来不太容易。  <img src="/images/games101/05/itt.png" alt="Incremental Triangle Traversal"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光栅化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-04：Viewing Transformation</title>
      <link href="/2022/04/28/ji-suan-ji-tu-xing-xue/games/games101-04-viewing-transformation/"/>
      <url>/2022/04/28/ji-suan-ji-tu-xing-xue/games/games101-04-viewing-transformation/</url>
      
        <content type="html"><![CDATA[<p>Viewing Transformation指的是将3D中的物体映射到2D中的图像的过程。</p><h1 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h1><p>Think about how to take a photo？</p><ul><li>Find a good place and arrange people (<strong>model transformation</strong>)</li><li>Find a good “angle” to put the camera (<strong>view transformation</strong>)</li><li>Cheese! (<strong>projection transformation</strong>)</li></ul><h1 id="View-Camera-Transformation"><a href="#View-Camera-Transformation" class="headerlink" title="View / Camera Transformation"></a>View / Camera Transformation</h1><h2 id="确定相机位置"><a href="#确定相机位置" class="headerlink" title="确定相机位置"></a>确定相机位置</h2><p>Define the camera first</p><ul><li>Position: $\vec{e}$</li><li>Look-at / gaze direction $\hat{g}$</li><li>Up direction (assuming perp. to look-at): $\hat{t}$</li></ul><p><img src="/images/games101/04/camera.png" alt="确定相机位置"></p><h2 id="永久固定相机位置"><a href="#永久固定相机位置" class="headerlink" title="永久固定相机位置"></a>永久固定相机位置</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>If the camera and all objects move together, the “photo” will be the same.</p><p><img src="/images/games101/04/fixed.png" alt="同时变换相机和物体"></p><h3 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h3><p>How about that we always transform the camera to</p><ul><li>The origin, up at $Y$, look at $-Z$</li><li>And transform the objects along with the camera</li></ul><p><img src="/images/games101/04/fixed_camera.png" alt="永久固定相机位置"></p><h3 id="具体变换"><a href="#具体变换" class="headerlink" title="具体变换"></a>具体变换</h3><p>Transform the camera by $M_{view}$.</p><ul><li>So it’s located at the origin, up at Y, look at -Z</li></ul><p>$M_{view}$ in math? </p><p>$$<br>\mathbf{M_{view}} = \mathbf{R_{view}} \mathbf{T_{view}}<br>$$</p><ul><li>Translates $\vec{e}$ to origin.  $$<br>  \mathbf{T}_{view} =<br>  \left(\begin{array}{lll}<br>  1 &amp; 0 &amp; 0 &amp; -x_e \\<br>  0 &amp; 1 &amp; 0 &amp; -y_e \\<br>  0 &amp; 0 &amp; 1 &amp; -z_e \\<br>  0 &amp; 0 &amp; 0 &amp; 1<br>  \end{array}\right)<br>  $$</li><li>Rotates $g$ to $-Z$, Rotates $t$ to $Y$, Rotates $(g \times t)$ To $X$.<ul><li>Consider its inverse rotation: $X$ to $(g \times t)$, $Y$ to $t$, $Z$ to $-g$</li></ul>  $$<br>  \mathbf{R_{view}}^{-1}=<br>  \left(\begin{array}{cccc}x_{\hat{g} \times \hat{t}} &amp; x_{t} &amp; x_{-g} &amp; 0 \\<br>  y_{\hat{g} \times \hat{t}} &amp; y_{t} &amp; y_{-g} &amp; 0 \\<br>  z_{\hat{g} \times \hat{t}} &amp; z_{t} &amp; z_{-g} &amp; 0 \\<br>  0 &amp; 0 &amp; 0 &amp; 1<br>  \end{array}\right)<br>  \\<br>  \mathbf{R_{view}}=<br>  \left(\begin{array}{cccc}x_{\hat{g} \times \hat{t}} &amp; y_{\hat{g} \times \hat{t}} &amp; z_{\hat{g} \times \hat{t}} &amp; 0 \\<br>  x_{t} &amp; y_{t} &amp; z_{t} &amp; 0 \\<br>  x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \\<br>  0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)<br>  $$  利用了旋转矩阵为正交矩阵的性质。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>上述整个过程也可以称为ModelView Transformation，因为相机和物体可以同时变化。</li><li>该过程为投影变换奠定基础。</li></ul><h1 id="Projection-transformation"><a href="#Projection-transformation" class="headerlink" title="Projection transformation"></a>Projection transformation</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Projection in Computer Graphics</p><ul><li>Orthographic projection：相机无限远，平行线仍平行</li><li>Perspective projection：相机有限远，近大远小，平行线会相交，更符合现实；</li></ul><p><img src="/images/games101/04/project1.png" alt="两种类型的投影变换1"></p><p><img src="/images/games101/04/project2.png" alt="两种类型的投影变换2"></p><p><a href="https://stackoverflow.com/questions/36573283/from-perspective-picture-to-orthographic-picture">From perspective picture to orthographic picture</a></p><h2 id="Orthographic-Projection"><a href="#Orthographic-Projection" class="headerlink" title="Orthographic Projection"></a>Orthographic Projection</h2><h3 id="例子理解"><a href="#例子理解" class="headerlink" title="例子理解"></a>例子理解</h3><ul><li>Camera located at origin, looking at $-Z$, up at $Y$ .</li><li>Drop $Z$ coordinate. 将$z$坐标去掉。</li><li>Translate and scale the resulting rectangle to $[-1, 1]^2$.</li></ul><p><img src="/images/games101/04/project_example.png" alt="投影例子理解"></p><p>问题：如何区分前后，在去掉$z$坐标后？</p><h3 id="真实操作"><a href="#真实操作" class="headerlink" title="真实操作"></a>真实操作</h3><p>We want to map a cuboid $[l, r]\times [b, t]\times [f, n]$ to the “canonical (正则、规范、标准)” cube $[-1, 1]^3$.</p><ul><li>Center cuboid by translating.</li><li>Scale into “canonical” cube.</li></ul><p>Translate (center to origin) first, then scale (length/width/height to 2).</p><p>$$<br>M_{\text {ortho }}=<br>\left(\begin{array}{cccc}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>\left(\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\<br>0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\<br>0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2} \\<br>0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)<br>$$</p><p><img src="/images/games101/04/orth.png" alt="正交投影具体操作"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>Looking at / along $-Z$ is making near and far not intuitive ($n &gt; f$)<ul><li>That’s why OpenGL (a Graphics API) uses left hand coords.</li></ul></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>不考虑旋转？</li><li>变换到立方体中会造成拉伸？之后会有视口变换解决这个问题。</li></ul><h2 id="Perspective-Projection"><a href="#Perspective-Projection" class="headerlink" title="Perspective Projection"></a>Perspective Projection</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>Most common in Computer Graphics, art, visual system</li><li>Further objects are smaller</li><li>Parallel lines not parallel; converge to single point</li></ul><p><img src="/images/games101/04/pers_overview.png" alt="透视投影"></p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul><li>$(x, y, z, 1)$, $(kx, ky, kz, k \ne 0)$, $(xz, yz, z^2, z \ne 0)$ all represent<br>the same point $(x, y, z)$ in 3D</li><li>e.g. $(1, 0, 0, 1)$ and $(2, 0, 0, 2)$ both represent $(1, 0, 0)$</li></ul><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul><li>First “squish” the <strong>frustum</strong> into a <strong>cuboid</strong>: $n \rightarrow n, f \rightarrow f$, ($M_{persp \rightarrow ortho}$).</li><li>Do orthographic projection:  $M_{ortho}$ already known</li></ul><p>在“挤压“的过程中，有几个原则需要遵守：</p><ul><li>近平面 $n$ 上点的坐标不变；</li><li>远平面 $f$ 上的z坐标不变；</li><li>远平面 $f$ 上的中心点仍然是中心点；</li></ul><p><img src="/images/games101/04/pers_idea.png" alt="透视投影方法"></p><h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><p>Find the relationship between transformed points $(x^{\prime}, y^{\prime}, z^{\prime})$ and the original points $(x, y, z)$.</p><p><img src="/images/games101/04/pers_operation.png" alt="透视投影过程"></p><p>在图中，Z/Y交点为相机位置，即原点。$n$为近平面的z坐标，$z$为远平面对应z轴的坐标。</p><p>对应则有经过变换后，</p><p>$$<br>y^{\prime} = \frac{n}{z}y<br>$$</p><p>$$<br>x^{\prime} = \frac{n}{z}x<br>$$</p><p>对应到齐次坐标下：</p><p>$$<br>\left(\begin{array}{l}x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)<br>\Rightarrow<br>\left(\begin{array}{c} nx/z \\<br>ny/z \\<br>\text{unknown} \\<br>1<br>\end{array}\right)<br>\overset{\times z}{==}<br>\left(<br>\begin{array}{c} nx \\<br>ny \\<br>\text{ still unknown } \\<br>z<br>\end{array}<br>\right)<br>$$</p><p>到此为止可以得到部分变换矩阵中的值：</p><p>$$<br>M_{persp \rightarrow ortho}^{4 \times 4}<br>\left(\begin{array}{l}x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)<br>=<br>\left(<br>\begin{array}{c} nx \\<br>ny \\<br>\text{ still unknown } \\<br>z<br>\end{array}<br>\right)<br>$$</p><p>$$<br>M_{persp \rightarrow ortho}^{4 \times 4}<br>=<br>\mathbf{T}_{view} =<br>\left(\begin{array}{lll}<br>n &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; n &amp; 0 &amp; 0 \\<br>? &amp; ? &amp; ? &amp; ? \\<br>0 &amp; 0 &amp; 1 &amp; 0<br>\end{array}\right)<br>$$</p><p>How to figure out the third row of $M_{persp \rightarrow ortho}$? The third row is responsible for $z^{\prime}$: </p><ul><li>Any point on the near plane will not change.</li></ul><p>$$<br>\mathbf{M_{persp \rightarrow ortho}}^{4 \times 4}<br>\left(<br>\begin{array}{l} x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)<br>=<br>\left(<br>\begin{array}{c} nx \\<br>ny \\<br>\text{unknown} \\<br>z<br>\end{array}<br>\right)<br>\overset{\text{replace z with n}}{\longrightarrow}<br>\left(\begin{array}{l}x \\<br>y \\<br>n \\<br>1<br>\end{array}\right)<br>\Rightarrow<br>\left(\begin{array}{l}x \\<br>y \\<br>n \\<br>1<br>\end{array}\right)==<br>\left(\begin{array}{l} nx \\<br>ny \\<br>n^{2} \\<br>n<br>\end{array}\right)<br>$$</p><p>所以得到：the third row must be of the form $(0 \ 0 \ A \ B)$, $n^2$ has nothing to do with $x$ and $y$.</p><p>$$<br> \left(\begin{array}{lll}0 &amp; 0 &amp; A\end{array}\right.  B)\left(\begin{array}{l}x \ y \ n \ 1\end{array}\right)=n^{2} <br>$$</p><p>$$<br>An + B = n^2<br>$$</p><ul><li>Any point’s z on the far plane will not change：这里取远平面的中心点。</li></ul><p>$$<br>\left(\begin{array}{l}0 \\<br>0 \\<br>f \\<br>1<br>\end{array}\right)<br>\Rightarrow<br>\left(\begin{array}{l}0 \\<br>0 \\<br>f \\<br>1<br>\end{array}\right)<br>==<br>\left(\begin{array}{c}0 \\<br>0 \\<br>f^{2} \\<br>f\end{array}\right)<br>$$</p><p>$$<br>Af + B = f^2<br>$$</p><p>综合上述两者，</p><p>$$<br>\begin{array}{ll}<br>An+B=n^{2} \\<br>Af+B=f^{2}<br>\end{array}<br>\Rightarrow<br>\begin{array}{ll}<br>A=n+f \\<br>B=-nf<br>\end{array}<br>$$</p><p>之后做orthographic projection即可：</p><p>$$<br>M_{persp} = M_{ortho} M_{persp \rightarrow ortho}<br>$$</p><h3 id="透视投影中Frustum的另一种表示"><a href="#透视投影中Frustum的另一种表示" class="headerlink" title="透视投影中Frustum的另一种表示"></a>透视投影中Frustum的另一种表示</h3><p>当得到<strong>近平面的坐标信息</strong>后，有时人们用另外一种方式表示Frustum视锥。</p><p>People prefer: vertical field-of-view (fovY) and aspect ratio (assume symmetry $l = -r, b = -t$).</p><p>该表示方法可以与cuboid中的 $l,r,b,t,n,f$ 相转化。</p><p><img src="/images/games101/04/fov_aspect.png" alt="用FoV和Aspect表示Frustum"></p><p>注意：上述平面只是frustum的近平面。</p><p><img src="/images/games101/04/fov_aspect_compute.png" alt="FoV和Aspect与之前表示的转换"></p><h1 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h1><p>对于任意一个frustum内部的点，经过透视投影映射到cuboid， 其 $z$ 坐标相对于之前有什么变化？</p><p>$$<br>\mathbf{M}_{persp \rightarrow ortho} =<br>\left(\begin{array}{lll}<br>n &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; n &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; n+f &amp; -nf \\<br>0 &amp; 0 &amp; 1 &amp; 0<br>\end{array}\right)<br>$$</p><p>对于任意一点经过该变换可得：</p><p>$$<br>\mathbf{M}_{persp \rightarrow ortho}<br>\left(<br>\begin{array}{l}x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)<br>=<br>\left(<br>\begin{array}{c} nx \\<br>ny \\<br>(n+f)z - nf \\<br>z<br>\end{array}<br>\right)<br>\Rightarrow<br>\left(<br>\begin{array}{c} nx/z \\<br>ny/z \\<br>(n+f) - nf/z \\<br>1<br>\end{array}<br>\right)<br>$$</p><p>为了判断 $z$ 坐标的变化，定义函数 $f(z)$:</p><p>$$<br>\begin{aligned}<br>f(z) &amp;= \frac{(n+f)z - nf}{z} - z \\<br> &amp; \overset{\times z}{=} -z^2 + (n+f)z -nf \\<br>&amp;= (z-n)(f-z)<br>\end{aligned}<br>$$</p><p>由于：$f \le z \le n$，因此$f(z) \ge 0$，因此得到在乘以 $z$ 坐标之前的 $f(z) \le 0$，因为看向的是-z方向，因此 $z$ 坐标均为负数。由此得到，当完成“挤压”后，frustum内部的点均向远平面方向移动，即离相机更远了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视图变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-03-02：3D Transformation</title>
      <link href="/2022/04/28/ji-suan-ji-tu-xing-xue/games/games101-03-02-3d-transformation/"/>
      <url>/2022/04/28/ji-suan-ji-tu-xing-xue/games/games101-03-02-3d-transformation/</url>
      
        <content type="html"><![CDATA[<h1 id="Homogeneous-coordinates"><a href="#Homogeneous-coordinates" class="headerlink" title="Homogeneous coordinates"></a>Homogeneous coordinates</h1><ul><li>3D point = $(x, y, z, 1)^T$</li><li>3D vector = $(x, y, z, 0)^T$</li></ul><p>对应的，坐标 $(x,y,z,w)(w \ne 0)$ 表示三维空间中的点$(x/w, y/w, z/w)$。</p><h1 id="Affine-Transform仿射变换"><a href="#Affine-Transform仿射变换" class="headerlink" title="Affine Transform仿射变换"></a>Affine Transform仿射变换</h1><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime} \\<br>z^{\prime} \\<br>1<br>\end{array}\right)=<br>\left(\begin{array}{lll}<br>a &amp; b &amp; c &amp; t_x \\<br>d &amp; e &amp; f &amp; t_y \\<br>g &amp; h &amp; i &amp; t_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right) \cdot<br>\left(\begin{array}{l}<br>x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)<br>$$</p><p>What’s the order? Linear Transform first or Translation first.</p><p>在操作变换时，首先进行线性变换，之后才进行平移变换。</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)<br>=<br>\left(\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right)<br>\left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right)<br>+<br>\left(\begin{array}{l}<br>t_x \\<br>t_y<br>\end{array}\right)<br>$$</p><h1 id="3D-transformations统一表示"><a href="#3D-transformations统一表示" class="headerlink" title="3D transformations统一表示"></a>3D transformations统一表示</h1><h2 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h2><p>$$<br>\mathbf{S}(s_x, s_y, s_z) =<br>\left(\begin{array}{ll}<br>s_x &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; s_y &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; s_z &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>$$</p><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>$$<br>\mathbf{T}(t_x, t_y) =<br>\left(\begin{array}{lll}<br>1 &amp; 0 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; 0 &amp; t_y \\<br>0 &amp; 0 &amp; 1 &amp; t_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>$$</p><h2 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h2><p>Rotation around x-, y-, or z-axis.</p><p>$$<br>\begin{array}{l}<br>\mathbf{R_x}(\alpha)=<br>\left(\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; \cos \alpha &amp; -\sin \alpha &amp; 0 \\<br>0 &amp; \sin \alpha &amp; \cos \alpha &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>\\<br>\mathbf{R_y}(\alpha)=<br>\left(\begin{array}{cccc}\cos \alpha &amp; 0 &amp; \sin \alpha &amp; 0 \\<br>0 &amp; 1 &amp; 0 &amp; 0 \\<br>-\sin \alpha &amp; 0 &amp; \cos \alpha &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)<br>\\<br>\mathbf{R_z}(\alpha)=\left(\begin{array}{cccc}\cos \alpha &amp; -\sin \alpha &amp; 0 &amp; 0 \\<br>\sin \alpha &amp; \cos \alpha &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>\end{array}<br>$$</p><p>其中$\mathbf{R}_{y}(\alpha)$会有一些奇怪，因为根据右手螺旋定则，$z$ 与 $x$ 叉乘得到 $y$，$x$ 与 $z$ 叉乘得到 $-y$，这是其在$\sin \alpha$上符号与其他两个相反的原因。（使用左手螺旋也会存在特殊的轴）</p><h2 id="3D-Rotations"><a href="#3D-Rotations" class="headerlink" title="3D Rotations"></a>3D Rotations</h2><p>Compose any 3D rotation from $R_x, R_y, R_z$?</p><p>$$<br>\mathbf{R_{xyz}}(\alpha, \beta, \gamma) = \mathbf{R_x}(\alpha)\mathbf{R_y}(\beta)\mathbf{R_z}(\gamma)<br>$$</p><p>其中，三个角度$\alpha, \beta, \gamma$ 称为Euler angles。</p><p>一个典型的应用场景：Often used in flight simulators: roll, pitch, yaw。</p><p><img src="/images/games101/03/2/3d-rot.png" alt="3D Rotations"></p><h2 id="Rodrigues’-Rotation-Formula"><a href="#Rodrigues’-Rotation-Formula" class="headerlink" title="Rodrigues’ Rotation Formula"></a>Rodrigues’ Rotation Formula</h2><p>Rotation by angle $\alpha$ around axis $\mathbf{n}$.</p><p>$$<br>\mathbf{R}(\mathbf{n}, \alpha)=<br>\cos (\alpha) \mathbf{I}+(1-\cos (\alpha)) \mathbf{n} \mathbf{n}^{T}+\sin (\alpha) \underbrace{\left(\begin{array}{ccc}0 &amp; -n_{z} &amp; n_{y} \\<br>n_{z} &amp; 0 &amp; -n_{x} \\<br>-n_{y} &amp; n_{x} &amp; 0<br>\end{array}\right)}_{\mathbf{N}}<br>$$</p><ul><li>其中axis默认是过原点的；</li><li>当轴不过原点可以利用之前的方法：将所有的东西移动到原点，再旋转，然后再移回去；</li><li>其中$\mathbf{N}$是向量的叉乘，只是表示成矩阵形式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-03-01：2D Transformation</title>
      <link href="/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-03-01-2d-transformation/"/>
      <url>/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-03-01-2d-transformation/</url>
      
        <content type="html"><![CDATA[<h1 id="Linear-Transforms-Matrices"><a href="#Linear-Transforms-Matrices" class="headerlink" title="Linear Transforms = Matrices"></a>Linear Transforms = Matrices</h1><h2 id="Scale-Transform"><a href="#Scale-Transform" class="headerlink" title="Scale Transform"></a>Scale Transform</h2><p>变换操作为：</p><p>$$<br>\text{scale}(s_x, s_y) = \left(\begin{array}{ll}s_x &amp; 0 \\ 0 &amp; s_y \end{array}\right)<br>$$</p><p>在点$(x, y)$经过变换后变为$(x^{\prime}, y^{\prime})$，如下：</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>s_x &amp; 0 \\<br>0 &amp; s_y<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>s_xx \\<br>s_yy<br>\end{array}\right)<br>$$</p><h2 id="Reflection-Transform"><a href="#Reflection-Transform" class="headerlink" title="Reflection Transform"></a>Reflection Transform</h2><p>在水平方向上，其实是沿y轴翻转。</p><p>$$<br>x^{\prime} = -x \\<br>y^{\prime} = y<br>$$</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>-1 &amp; 0 \\<br>0 &amp; 1<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>-x \\<br>y<br>\end{array}\right)<br>$$</p><p>在竖直方向上，其实是沿x轴翻转。</p><p>$$<br>x^{\prime} = x \\<br>y^{\prime} = -y<br>$$</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>1 &amp; 0 \\<br>0 &amp; -1<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>x \\<br>-y<br>\end{array}\right)<br>$$</p><h2 id="Shear-Transform"><a href="#Shear-Transform" class="headerlink" title="Shear Transform"></a>Shear Transform</h2><p><img src="/images/games101/03/shear.png" alt="Shear Transform"></p><p>在水平方向上，纵坐标不变化。</p><p>$$<br>x^{\prime} = x + ay \\<br>y^{\prime} = y<br>$$</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>1 &amp; a \\<br>0 &amp; 1<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>x + ay \\<br>y<br>\end{array}\right)<br>$$</p><p>在竖直方向上，横坐标不变化。</p><p>$$<br>x^{\prime} = x \\<br>y^{\prime} = y + ax<br>$$</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=<br>\left(\begin{array}{ll}<br>1 &amp; 0 \\<br>a &amp; 1<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>x \\<br>y + ax<br>\end{array}\right)<br>$$</p><h2 id="Rotate-Transform"><a href="#Rotate-Transform" class="headerlink" title="Rotate Transform"></a>Rotate Transform</h2><h3 id="默认规则"><a href="#默认规则" class="headerlink" title="默认规则"></a>默认规则</h3><ul><li>about the origin (0, 0)：围绕原点旋转；</li><li>CCW by default：默认是逆时针旋转；</li></ul><p><img src="/images/games101/03/rotate.png" alt="Rotate Transform"></p><p>取图中两个特殊点计算旋转矩阵，得到：</p><p>$$<br>\mathbf{R}_{\theta} = \left(\begin{array}{ll}<br>\cos\theta &amp; -\sin\theta \\<br>\sin\theta &amp; \cos\theta<br>\end{array}\right)<br>$$</p><h3 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h3><p>$$<br>\mathbf{R_{-\theta}} =<br>\left(\begin{array}{cc}<br>\cos \theta &amp; \sin \theta \\<br>-\sin \theta &amp; \cos \theta<br>\end{array}\right) = \mathbf{R_{\theta}^{\top}}<br>$$</p><p>根据定义：</p><p>$$<br>\mathbf{R_{-\theta}}=\mathbf{R_{\theta}^{-1}}<br>$$</p><p>因此得到：</p><p>$$<br>\mathbf{R_{\theta}^{\top}}=\mathbf{R_{\theta}^{-1}}<br>$$</p><p>这一性质表明旋转矩阵是正交矩阵。</p><h2 id="Linear-Transform总结"><a href="#Linear-Transform总结" class="headerlink" title="Linear Transform总结"></a>Linear Transform总结</h2><p>其中对应矩阵的维度与点的维度保持一致。</p><p>$$<br>x^{\prime} = ax + by \\<br>y^{\prime} = cx + dy<br>$$</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right) = \left(\begin{array}{l}<br>ax + by \\<br>cx + dy<br>\end{array}\right)<br>$$</p><p>$$<br>x^{\prime} = Mx<br>$$</p><h1 id="Homogeneous-coordinates"><a href="#Homogeneous-coordinates" class="headerlink" title="Homogeneous coordinates"></a>Homogeneous coordinates</h1><h2 id="为啥要用齐次坐标？"><a href="#为啥要用齐次坐标？" class="headerlink" title="为啥要用齐次坐标？"></a>为啥要用齐次坐标？</h2><p>要解决平移变换的问题，将之与之前的变换统一表示，因为不能将平移变换写成矩阵乘法的形式。</p><h2 id="Translation-Transform"><a href="#Translation-Transform" class="headerlink" title="Translation Transform"></a>Translation Transform</h2><p><img src="/images/games101/03/translation.png" alt="Translation Transform"></p><p>$$<br>x^{\prime} = x + t_x \\<br>y^{\prime} = y + t_y<br>$$</p><p>Translation cannot be represented in matrix form. 不是线性变换。</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=<br>\left(\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right)<br>\left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right)<br>+<br>\left(\begin{array}{l}<br>t_x \\<br>t_y<br>\end{array}\right)<br>$$</p><p>由于不想将该变换特殊处理，为了统一表示，因此需要齐次坐标。</p><h2 id="Solution-Homogenous-Coordinates"><a href="#Solution-Homogenous-Coordinates" class="headerlink" title="Solution: Homogenous Coordinates"></a>Solution: Homogenous Coordinates</h2><p>Add a third coordinate (w-coordinate)</p><ul><li>2D point = $(x, y, 1)^T$</li><li>2D vector = $(x, y, 0)^T$</li></ul><blockquote><p>为啥点和向量在增加的坐标上的表示分别为1和0，而不是相同呢？因为向量具有平移不变性，而点经过平移则会发生变化。</p></blockquote><p>Valid operation if w-coordinate of result is 1 or 0：</p><ul><li>vector + vector = vector</li><li>point – point = vector</li><li>point + vector = point</li><li>point + point = ??</li></ul><p>In homogeneous coordinates,</p><p>$$<br>\left(\begin{array}{l}<br>x \\<br>y \\<br>w<br>\end{array}\right)<br>$$<br>is the 2D point<br>$$<br>\left(\begin{array}{l}<br>x/w \\<br>y/w \\<br>1<br>\end{array}\right)<br>$$</p><p>$$w \ne 0. $$</p><p>在该扩充定义下，齐次坐标中，两点之间的加和结果是两个点的中点，还是一个点。</p><blockquote><p>齐次坐标的代价：引入了多余的数字，理论上会增加存储，但是实际中可以不管。</p></blockquote><h2 id="Translation在齐次坐标下的表示"><a href="#Translation在齐次坐标下的表示" class="headerlink" title="Translation在齐次坐标下的表示"></a>Translation在齐次坐标下的表示</h2><p>使用该方法表示Translation得到：</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime} \\<br>w^{\prime}<br>\end{array}\right)=<br>\left(\begin{array}{lll}<br>1 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right) \left(\begin{array}{l}<br>x \\<br>y \\<br>1<br>\end{array}\right)<br>= \left(\begin{array}{l}<br>x + t_x \\<br>y + t_y \\<br>1<br>\end{array}\right)<br>$$</p><p>从而实现转化为矩阵乘法的形式。</p><h2 id="Affine-Transform仿射变换"><a href="#Affine-Transform仿射变换" class="headerlink" title="Affine Transform仿射变换"></a>Affine Transform仿射变换</h2><p>Affine map = linear map + translation</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)<br>=<br>\left(\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right)<br>\left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right)<br>+<br>\left(\begin{array}{l}<br>t_x \\<br>t_y<br>\end{array}\right)<br>$$</p><p>在齐次坐标下表示如下：</p><p>$$<br>\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime} \\<br>1<br>\end{array}\right)<br>=<br>\left(\begin{array}{lll}<br>a &amp; b &amp; t_x \\<br>c &amp; d &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right) \cdot<br>\left(\begin{array}{l}<br>x \\<br>y \\<br>1<br>\end{array}\right)<br>$$</p><h2 id="齐次坐标下统一表示"><a href="#齐次坐标下统一表示" class="headerlink" title="齐次坐标下统一表示"></a>齐次坐标下统一表示</h2><h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><p>$$<br>\mathbf{S}(s_x, s_y) =<br>\left(\begin{array}{ll}<br>s_x &amp; 0 &amp; 0 \\<br>0 &amp; s_y &amp; 0 \\<br>0&amp;0&amp; 1<br>\end{array}\right)<br>$$</p><h3 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h3><p>$$<br>\mathbf{R}(\theta) = \left(\begin{array}{ll}<br>\cos\theta &amp; -\sin\theta &amp; 0 \\<br>\sin\theta &amp; \cos\theta &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right)<br>$$</p><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>$$<br>\mathbf{T}(t_x, t_y) =<br>\left(\begin{array}{lll}<br>1 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right)<br>$$</p><h1 id="Inverse-Transform"><a href="#Inverse-Transform" class="headerlink" title="Inverse Transform"></a>Inverse Transform</h1><p>逆变换 $M$ 在数学上等价于乘上逆矩阵。$M^{-1}$ is the inverse of transform in both a matrix and geometric sense。</p><p><img src="/images/games101/03/inverse.png" alt="Inverse Transform"></p><h1 id="Composite-Transform"><a href="#Composite-Transform" class="headerlink" title="Composite Transform"></a>Composite Transform</h1><h2 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h2><p>在组合不同的变换时，注意：Transform Ordering Matters。</p><p><img src="/images/games101/03/compose_ex.png" alt="Composite Example"></p><p>如何理解？</p><p>Matrix multiplication is not commutative.</p><p>$$<br>R_{45} \cdot T_{(1,0)} \ne T_{(1,0)} \cdot  R_{45}<br>$$</p><p>Note that matrices are applied right to left:</p><p>$$<br>T_{(1,0)} \cdot R_{45}<br>\left(\begin{array}{l}x \\ y<br>\\<br>1<br>\end{array}<br>\right)<br>=<br>\left(\begin{array}{lll}1 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{array}<br>\right)<br>\left(<br>\begin{array}{ccc}\cos 45^{\circ} &amp; -\sin 45^{\circ} &amp; 0<br>\\<br>\sin 45^{\circ} &amp; \cos 45^{\circ} &amp; 0 \\<br>0 &amp; 0 &amp; 1\end{array}<br>\right)<br>\left(\begin{array}{l}x \\ y \\ 1<br>\end{array}\right)<br>$$</p><p>对于矩阵乘法来说，当考虑到变换时，是<strong>从右到左</strong>依次起作用的。</p><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>Sequence of affine transforms $A_1, A_2, A_3,$ </p><p>Compose by matrix multiplication将所有的变换结合起来形成一个变换矩阵然后再统一与原始点相乘。</p><p><img src="/images/games101/03/compose.png" alt="Compose Transform"></p><p>这一技巧对于性能计算很重要，Very important for performance。</p><h1 id="Decomposing-Complex-Transforms"><a href="#Decomposing-Complex-Transforms" class="headerlink" title="Decomposing Complex Transforms"></a>Decomposing Complex Transforms</h1><h2 id="例子：沿着特定点旋转"><a href="#例子：沿着特定点旋转" class="headerlink" title="例子：沿着特定点旋转"></a>例子：沿着特定点旋转</h2><p>How to rotate around a given point c?</p><ol><li>Translate center to origin</li><li>Rotate</li><li>Translate back</li></ol><p><img src="/images/games101/03/decompose.png" alt="Decompose Transforms"></p><p>矩阵形式如下：（从右到左依次写）</p><p>$$<br>\mathbf{T}(c) \cdot \mathbf{R}(\alpha) \cdot \mathbf{T}(-c)<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-02：Review of Linear Algebra</title>
      <link href="/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-02-review-of-linear-algebra/"/>
      <url>/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-02-review-of-linear-algebra/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学的预备知识"><a href="#计算机图形学的预备知识" class="headerlink" title="计算机图形学的预备知识"></a>计算机图形学的预备知识</h1><p>本节主要是复习了计算机图形学中可能用到的线性代数知识，其实CG中也会用到其他一些知识，包括但不限于：</p><h2 id="Basic-mathematics"><a href="#Basic-mathematics" class="headerlink" title="Basic mathematics"></a>Basic mathematics</h2><ul><li>Linear algebra</li><li>Calculus</li><li>Statistics</li></ul><h2 id="Basic-physics"><a href="#Basic-physics" class="headerlink" title="Basic physics"></a>Basic physics</h2><ul><li>Optics</li><li>Mechanics</li></ul><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><ul><li>Signal processing</li><li>Numerical analysis</li></ul><h2 id="And-a-bit-of-aesthetics"><a href="#And-a-bit-of-aesthetics" class="headerlink" title="And a bit of aesthetics"></a>And a bit of aesthetics</h2><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Usually written as $\vec{a}$ or in bold $\textbf{a}$</li><li>Or using start and end points</li><li>Direction and length</li><li>No absolute starting position</li></ul><h2 id="Vector-Normalization"><a href="#Vector-Normalization" class="headerlink" title="Vector Normalization"></a>Vector Normalization</h2><ul><li>Magnitude (length) of a vector written as $|\vec{a}|$</li><li>Unit vector<ul><li>A vector with magnitude of 1</li><li>Finding the unit vector of a vector (normalization): $\hat{a}=\vec{a} /|\vec{a}|$</li><li>Used to represent directions</li></ul></li></ul><h2 id="Vector-Addition"><a href="#Vector-Addition" class="headerlink" title="Vector Addition"></a>Vector Addition</h2><ul><li>Geometrically: Parallelogram law &amp; Triangle law</li><li>Algebraically: Simply add coordinates</li></ul><h2 id="Cartesian-Coordinates"><a href="#Cartesian-Coordinates" class="headerlink" title="Cartesian Coordinates"></a>Cartesian Coordinates</h2><ul><li>X and Y can be any (usually orthogonal unit) vectors  $$<br>  \mathbf{A}=\left(\begin{array}{l}x \\ y \end{array}\right) \quad \mathbf{A}^{T}=(x, y) \quad|\mathbf{A}|=\sqrt{x^{2}+y^{2}}<br>  $$  默认向量是列向量。  <img src="/images/games101/02/cc.png" alt="Cartesian Coordinates"></li></ul><h2 id="Vector-Multiplication"><a href="#Vector-Multiplication" class="headerlink" title="Vector Multiplication"></a>Vector Multiplication</h2><h3 id="Dot-scalar-Product"><a href="#Dot-scalar-Product" class="headerlink" title="Dot (scalar) Product"></a>Dot (scalar) Product</h3><p><img src="/images/games101/02/dp.png" alt="Dot Product"></p><ul><li>定义  $$<br>  \vec{a} \cdot \vec{b}=|\vec{a}||\vec{b}| \cos \theta<br>  $$  $$<br>  \cos \theta=\frac{\vec{a} \cdot \vec{b}}{|\vec{a}||\vec{b}|}<br>  $$</li><li>运算法则：  $$<br>  \begin{array}{l} \vec{a} \cdot \vec{b} = \vec{b} \cdot \vec{a} \\<br>  \vec{a} \cdot(\vec{b}+\vec{c})=\vec{a} \cdot \vec{b}+\vec{a} \cdot \vec{c} \\  (k \vec{a}) \cdot \vec{b}=\vec{a} \cdot(k \vec{b})=k(\vec{a} \cdot \vec{b})\end{array}<br>  $$</li><li>Dot Product in Cartesian Coordinates  Component-wise multiplication, then adding up<ul><li>In 2D  $$<br>  \vec{a} \cdot \vec{b}=\left(\begin{array}{l}x_{a} \\ y_{a}\end{array}\right) \cdot\left(\begin{array}{l}x_{b} \\ y_{b}\end{array}\right)=x_{a} x_{b}+y_{a} y_{b}<br>  $$</li><li>In 3D  $$<br>  \vec{a} \cdot \vec{b}=\left(\begin{array}{c}x_{a} \\ y_{a} \\ z_{a}\end{array}\right) \cdot\left(\begin{array}{c}x_{b} \\ y_{b} \\ z_{b}\end{array}\right)=x_{a} x_{b}+y_{a} y_{b}+z_{a} z_{b}<br>  $$</li></ul></li></ul><h3 id="Dot-Product-in-Graphics"><a href="#Dot-Product-in-Graphics" class="headerlink" title="Dot Product in Graphics"></a>Dot Product in Graphics</h3><ul><li>Find angle between two vectors, (e.g. cosine of angle between light source and surface)</li><li>Finding projection of one vector on another  <img src="/images/games101/02/project.png" alt="投影">  $\vec{b}_{\perp}$:  projection of  $\vec{b}$  onto  $\vec{a}$<ul><li>$\vec{b}_{\perp}$ must be along $\vec{a}$ (or along $\hat{a}$ )</li><li>$\vec{b}_{\perp}=k \hat{a}$</li><li>What’s its magnitude $k$?</li><li>$k=|\vec{b}_{\perp}|=|\vec{b}| \cos \theta$</li></ul></li><li>投影可以用来：<ul><li>Measure how close two directions are</li><li>Decompose a vector</li><li>Determine forward / backward：明确两个向量的方向性，同向、反向、垂直；  <img src="/images/games101/02/fb.png" alt="判断forward/backward"></li></ul></li></ul><h3 id="Cross-vector-Product"><a href="#Cross-vector-Product" class="headerlink" title="Cross (vector) Product"></a>Cross (vector) Product</h3><p><img src="/images/games101/02/cp.png" alt="Cross Product"></p><ul><li>Cross product is orthogonal to two initial vectors：结果为向量，不是数字；</li><li>Direction determined by right-hand rule</li><li>Useful in constructing coordinate systems：构建的称为右手坐标系；</li></ul><p>$$<br>\begin{array}{l}\vec{x} \times \vec{y}=+\vec{z} \\<br>\vec{y} \times \vec{x}=-\vec{z} \\<br>\vec{y} \times \vec{z}=+\vec{x} \\<br>\vec{z} \times \vec{y}=-\vec{x} \\<br>\vec{z} \times \vec{x}=+\vec{y} \\<br>\vec{x} \times \vec{z}=-\vec{y}\end{array}<br>$$</p><ul><li>运算性质  $$<br>  \begin{array}{c}\vec{a} \times \vec{b}=-\vec{b} \times \vec{a} \\<br>  \vec{a} \times \vec{a}=\overrightarrow{0} \\<br>  \vec{a} \times(\vec{b}+\vec{c})=\vec{a} \times \vec{b}+\vec{a} \times \vec{c} \\<br>  \vec{a} \times(k \vec{b})=k(\vec{a} \times \vec{b})\end{array}<br>  $$</li><li>Cross Product: Cartesian Formula  $$<br>  \vec{a} \times \vec{b}=\left(\begin{array}{l}y_{a} z_{b}-y_{b} z_{a} \\<br>  z_{a} x_{b}-x_{a} z_{b} \\<br>  x_{a} y_{b}-y_{a} x_{b}\end{array}\right)<br>  $$</li></ul><h3 id="Cross-Product-in-Graphics"><a href="#Cross-Product-in-Graphics" class="headerlink" title="Cross Product in Graphics"></a>Cross Product in Graphics</h3><ul><li>Determine left / right：$\vec{a} \times \vec{b} &gt; 0$，说明 $\vec{b}$ 在 $\vec{a}$ 的左边；反之在右边；  <img src="/images/games101/02/lr.png" alt="判断左/右"></li><li>Determine inside / outside：当$p$点，与三角形各个顶点的连线，$\overrightarrow{AP}$、$\overrightarrow{BP}$、$\overrightarrow{CP}$分别与$\overrightarrow{AB}$、$\overrightarrow{BC}$、$\overrightarrow{CA}$计算Cross Product，如果p点均在三个向量的左侧或者右侧，则该点在三角形内部，若落在边界上可自由处理。  <img src="/images/games101/02/io.png" alt="判断内/外"></li></ul><h3 id="Orthonormal-bases-and-coordinate-frames"><a href="#Orthonormal-bases-and-coordinate-frames" class="headerlink" title="Orthonormal bases and coordinate frames"></a>Orthonormal bases and coordinate frames</h3><ul><li>Important for representing points, positions, locations</li><li>Often, many sets of coordinate systems<ul><li>Global, local, world, model, parts of model (head, hands, …)</li></ul></li><li>Critical issue is transforming between these systems/bases</li></ul><p>有助于将向量进行分解，例如对于右手坐标系：</p><p>Any set of 3 vectors (in 3D) that</p><p>$$<br>\begin{array}{l}|\vec{u}|=|\vec{v}|=|\vec{w}|=1 \\<br>\vec{u} \cdot \vec{v}=\vec{v} \cdot \vec{w}=\vec{u} \cdot \vec{w}=0 \\<br>\vec{w}=\vec{u} \times \vec{v} \quad \text { (right-handed) } \\<br>\vec{p}=(\vec{p} \cdot \vec{u}) \vec{u}+(\vec{p} \cdot \vec{v}) \vec{v}+(\vec{p} \cdot \vec{w}) \vec{w} \\<br>\text { (projection) }\end{array}<br>$$</p><h1 id="Matrices"><a href="#Matrices" class="headerlink" title="Matrices"></a>Matrices</h1><ul><li>In Graphics, pervasively used to represent transformations</li><li>Array of numbers (m × n = m rows, n columns)  $$<br>  \left(\begin{array}{ll}1 &amp; 3 \\ 5 &amp; 2 \\ 0 &amp; 4 \end{array}\right)<br>  $$</li><li>Addition and multiplication by a scalar are trivial: element by element</li></ul><h2 id="Matrix-Matrix-Multiplication"><a href="#Matrix-Matrix-Multiplication" class="headerlink" title="Matrix-Matrix Multiplication"></a>Matrix-Matrix Multiplication</h2><ul><li>(number of) columns in A must = # rows in B</li><li>(M x N) (N x P) = (M x P)  $$<br>  \left(\begin{array}{ll}1 &amp; 3 \\ 5 &amp; 2 \\ 0 &amp; 4\end{array}\right)\left(\begin{array}{llll}3 &amp; 6 &amp; 9 &amp; 4 \\ 2 &amp; 7 &amp; 8 &amp; 3\end{array}\right)<br>  $$</li><li>Element (i, j) in the product is the dot product of row i from A and column j from B</li><li>运算规则<ul><li>Non-commutative: (AB and BA are different in general)</li><li>Associative and distributive<ul><li>(AB)C=A(BC)</li><li>A(B+C) = AB + AC</li><li>(A+B)C = AC + BC</li></ul></li></ul></li></ul><h2 id="Matrix-Vector-Multiplication"><a href="#Matrix-Vector-Multiplication" class="headerlink" title="Matrix-Vector Multiplication"></a>Matrix-Vector Multiplication</h2><p>Treat vector as a column matrix (m×1)</p><p>$$<br>\left(\begin{array}{cc}-1 &amp; 0 \\ 0 &amp; 1\end{array}\right)\left(\begin{array}{l}x \\ y \end{array}\right)=\left(\begin{array}{c}-x \\ y \end{array}\right)<br>$$</p><h2 id="Transpose-of-a-Matrix"><a href="#Transpose-of-a-Matrix" class="headerlink" title="Transpose of a Matrix"></a>Transpose of a Matrix</h2><p>Switch rows and columns (ij -&gt; ji)</p><p>$$<br>\left(\begin{array}{ll}1 &amp; 2 \\ 3 &amp; 4 \\ 5 &amp; 6\end{array}\right)^{T}=\left(\begin{array}{lll}1 &amp; 3 &amp; 5 \\ 2 &amp; 4 &amp; 6\end{array}\right)<br>$$</p><p>运算性质：</p><p>$$<br>(A B)^{T}=B^{T} A^{T}<br>$$</p><h2 id="Identity-Matrix-and-Inverses"><a href="#Identity-Matrix-and-Inverses" class="headerlink" title="Identity Matrix and Inverses"></a>Identity Matrix and Inverses</h2><p>$$<br>I_{3 \times 3}=\left(\begin{array}{ccc}1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{array}\right)<br>$$</p><p>$$<br>\begin{array}{l}A A^{-1}=A^{-1} A=I \\ (A B)^{-1}=B^{-1} A^{-1}\end{array}<br>$$</p><h2 id="Vector-multiplication-in-Matrix-form"><a href="#Vector-multiplication-in-Matrix-form" class="headerlink" title="Vector multiplication in Matrix form"></a>Vector multiplication in Matrix form</h2><h3 id="Dot-product"><a href="#Dot-product" class="headerlink" title="Dot product"></a>Dot product</h3><p>$$<br>\begin{aligned}\vec{a} \cdot \vec{b} \\ =&amp;\vec{a}^{T} \vec{b} \\ =&amp;\left(\begin{array}{lll}x_{a} &amp; y_{a} &amp; z_{a}\end{array}\right)\left(\begin{array}{c}x_{b} \\ y_{b} \\ z_{b}\end{array}\right)=\left(x_{a} x_{b}+y_{a} y_{b}+z_{a} z_{b}\right)\end{aligned}<br>$$</p><h3 id="Cross-product"><a href="#Cross-product" class="headerlink" title="Cross product"></a>Cross product</h3><p>$$<br>\vec{a} \times \vec{b}=A^{*} b=\left(\begin{array}{ccc}0 &amp; -z_{a} &amp; y_{a} \\ z_{a} &amp; 0 &amp; -x_{a} \\ -y_{a} &amp; x_{a} &amp; 0\end{array}\right)\left(\begin{array}{l}x_{b} \\ y_{b} \\ z_{b}\end{array}\right)<br>$$</p><p>A: dual matrix of vector a</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-01：Overview of Computer Graphics</title>
      <link href="/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-01-overview-of-computer-graphics/"/>
      <url>/2022/04/24/ji-suan-ji-tu-xing-xue/games/games101-01-overview-of-computer-graphics/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Computer-Graphics"><a href="#What-is-Computer-Graphics" class="headerlink" title="What is Computer Graphics"></a>What is Computer Graphics</h2><blockquote><p>The use of computers to <strong>synthesize</strong> and <strong>manipulate</strong> visual information.</p></blockquote><p>计算机图形学不等于openGL，openGL只是实现计算机图形学操作的API。</p><h2 id="与Computer-Vision的区别"><a href="#与Computer-Vision的区别" class="headerlink" title="与Computer Vision的区别"></a>与Computer Vision的区别</h2><p>一切涉及需要<strong>猜测</strong>的研究都属于计算机视觉的范畴，需要分析和理解。</p><p><img src="/images/games101/01/diff.png" alt="计算机图形学与计算机视觉的区别"></p><p>参考资料：</p><ul><li><a href="https://www.tutorialspoint.com/dip/computer_vision_and_graphics.htm">Computer Vision and Computer Graphics</a></li><li><a href="https://www.quora.com/What-is-the-difference-between-the-fields-of-Computer-Graphics-and-Computer-Vision">What is the difference between the fields of Computer Graphics and Computer Vision?</a></li></ul><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><h3 id="Video-Games"><a href="#Video-Games" class="headerlink" title="Video Games"></a>Video Games</h3><ul><li>从技术角度来说，什么是好画面？<ul><li>画面是否足够亮——全局光照；</li></ul></li></ul><h3 id="Movies"><a href="#Movies" class="headerlink" title="Movies"></a>Movies</h3><ul><li>特效：special effects</li><li>特效是最简单的图形学应用，因为少见，或者缺乏直接的体验；</li><li>最难的是模拟真实的东西；</li></ul><h3 id="Animations"><a href="#Animations" class="headerlink" title="Animations"></a>Animations</h3><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><ul><li>CAD: Computer-aided Design，宜家家居设计；</li></ul><h3 id="Visualization"><a href="#Visualization" class="headerlink" title="Visualization"></a>Visualization</h3><h3 id="Virtual-Reality"><a href="#Virtual-Reality" class="headerlink" title="Virtual Reality"></a>Virtual Reality</h3><p>经常与增强现实 Augmented Reality共同出现。</p><ul><li>两者的区别<ul><li>VR：看不到现实；</li><li>AR：看到现实东西，但是还有一些新东西加入；</li></ul></li></ul><h3 id="Digital-illustration"><a href="#Digital-illustration" class="headerlink" title="Digital illustration"></a>Digital illustration</h3><h3 id="Simulation"><a href="#Simulation" class="headerlink" title="Simulation"></a>Simulation</h3><h3 id="Graphical-User-Interfaces"><a href="#Graphical-User-Interfaces" class="headerlink" title="Graphical User Interfaces"></a>Graphical User Interfaces</h3><h3 id="Typography"><a href="#Typography" class="headerlink" title="Typography"></a>Typography</h3><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><h3 id="Fundamental-intellectual-challenges"><a href="#Fundamental-intellectual-challenges" class="headerlink" title="Fundamental intellectual challenges"></a>Fundamental intellectual challenges</h3><ol><li>Creates and interacts with realistic virtual world;</li><li>Requires understanding of all aspects of physical world;</li><li>New computing methods, displays, technologies;</li></ol><h3 id="Technical-challenges"><a href="#Technical-challenges" class="headerlink" title="Technical challenges"></a>Technical challenges</h3><ol><li>Math of (perspective) projections, curves, surfaces;</li><li>Physics of lighting and shading;</li><li>Representing / operating shapes in 3D;</li><li>Animation / simulation;</li><li>3D graphics software programming and hardware;</li></ol><h2 id="主要研究内容"><a href="#主要研究内容" class="headerlink" title="主要研究内容"></a>主要研究内容</h2><h3 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h3><ul><li>Project geometry primitives (3D triangles / polygons) onto the screen;</li><li>Break projected primitives into fragments (pixels);</li><li>Gold standard in Video Games (Real-time Applications)  将3D形体显示在屏幕上，是所有游戏，即<strong>实时（每秒 30帧图片，30fps，否则叫离线）计算机图形学</strong>的主要应用。</li></ul><h3 id="Curves-and-Meshes"><a href="#Curves-and-Meshes" class="headerlink" title="Curves and Meshes"></a>Curves and Meshes</h3><p>How to represent geometry in Computer Graphics.</p><h3 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h3><ul><li>Shoot rays from the camera though each pixel<ul><li>Calculate intersection and shading;</li><li>Continue to bounce the rays till they hit light sources;</li></ul></li><li>Gold standard in Animations / Movies (Offline Applications)</li></ul><h3 id="Animation-Simulation"><a href="#Animation-Simulation" class="headerlink" title="Animation / Simulation"></a>Animation / Simulation</h3><ul><li>Key frame Animation</li><li>Mass-spring System</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 光栅化 </tag>
            
            <tag> 光线追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何入门计算机图形学：一份checklist</title>
      <link href="/2022/04/24/ji-suan-ji-tu-xing-xue/ru-he-ru-men-ji-suan-ji-tu-xing-xue-yi-fen-checklist/"/>
      <url>/2022/04/24/ji-suan-ji-tu-xing-xue/ru-he-ru-men-ji-suan-ji-tu-xing-xue-yi-fen-checklist/</url>
      
        <content type="html"><![CDATA[<h1 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h1><h2 id="不要"><a href="#不要" class="headerlink" title="不要"></a>不要</h2><ul><li>不要关注图形API：OpenGL、DirectX、Vulkan等只是API，而原理相同；</li><li>不要关注GPU还是CPU：它们只是效率不同；</li><li>不要关注游戏编程类：比如UE引擎等，这些只是上层的应用；</li><li>不要关注没有代码的论文：CG偏应用，单纯入门没必要；</li></ul><h2 id="要"><a href="#要" class="headerlink" title="要"></a>要</h2><ul><li>上课以建立理论脉络：CG一般包含Rendering/Geometry/Simulation</li><li>多写代码：CG偏应用，代码蕴含细节；</li><li>要边理论边实践编程；</li></ul><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>从头造轮子：便于了解细节；</li><li>拆解小项目：明白工业级项目，学习其他人的经验；</li></ul><h1 id="技能要求"><a href="#技能要求" class="headerlink" title="技能要求"></a>技能要求</h1><h2 id="编程技能"><a href="#编程技能" class="headerlink" title="编程技能"></a>编程技能</h2><ul><li>C/C++：参考C++ Primer这本书，没有plus；</li></ul><h2 id="理论技能"><a href="#理论技能" class="headerlink" title="理论技能"></a>理论技能</h2><ul><li>微积分</li><li>线性代数<ul><li><a href="https://math.mit.edu/~gs/linearalgebra/">Introduction to Linear Algebra, 5th Edition</a></li><li><a href="http://immersivemath.com/ila/index.html">Immersive Math</a></li></ul></li></ul><h1 id="领域内容"><a href="#领域内容" class="headerlink" title="领域内容"></a>领域内容</h1><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>主要是建立对CG的整体认识，不要求多么深入，要求结构清晰，方便快速入门。</p><ul><li>书籍<ul><li>Fundamentals of Computer Graphics, Fourth Edition</li></ul></li><li>课程<ul><li><a href="http://games-cn.org/intro-graphics/">GAMES101:现代计算机图形学入门</a></li></ul></li></ul><h2 id="实时渲染"><a href="#实时渲染" class="headerlink" title="实时渲染"></a>实时渲染</h2><ul><li>书籍：Real-Time Rendering, Fourth Edition</li><li>课程<ul><li><a href="http://games-cn.org/games202/">Games202:高质量实时渲染 - 计算机图形学与混合现实研讨会</a></li></ul></li></ul><h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><ul><li><a href="https://www.bilibili.com/video/BV1B54y1B7Uc">数字几何处理-中国科学技术大学-傅孝明_哔哩哔哩_bilibili</a></li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul><li><a href="https://www.bilibili.com/video/BV1ZK411H7Hc?from=search&seid=5195290021208890151">GAMES201：高级物理引擎实战指南2020_哔哩哔哩_bilibili</a></li></ul><h1 id="拆解项目"><a href="#拆解项目" class="headerlink" title="拆解项目"></a>拆解项目</h1><p>这些项目可用于拆解练习。</p><ul><li><a href="https://github.com/ssloy/tinyrenderer">软件光栅化渲染器——tinyrenderer</a></li><li><a href="https://github.com/skywind3000/mini3d">软件光栅化渲染器——mini3d</a></li><li><a href="https://github.com/topics/box2d-lite">物理引擎——box2d-lite</a></li><li><a href="https://github.com/mitsuba-renderer/mitsuba2">渲染系统——mitsuba2渲染器</a></li></ul><h1 id="其他技术资源"><a href="#其他技术资源" class="headerlink" title="其他技术资源"></a>其他技术资源</h1><h2 id="光栅技术"><a href="#光栅技术" class="headerlink" title="光栅技术"></a>光栅技术</h2><p>Peter Shirley（Fundamentals of Computer Graphics作者）的一系列关于光线追踪的文章<a href="https://raytracing.github.io/">Ray Tracing in One Weekend Series</a>。</p><ul><li><strong>Ray Tracing in One Weekend</strong></li><li><strong>Ray Tracing: The Next Week</strong></li><li><strong>Ray Tracing: The Rest of Your Life</strong></li></ul><h2 id="参考百科全书——PBR"><a href="#参考百科全书——PBR" class="headerlink" title="参考百科全书——PBR"></a>参考百科全书——PBR</h2><p><a href="https://www.pbrt.org/">Physically Based Rendering: From Theory to Implementation</a></p><p>该参考书还配有开源的<a href="https://github.com/mmp/pbrt-v3">工业级渲染器</a>以供使用和学习。</p><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><ol><li>学习GAMES-101，并学习C++实践+做作业；</li><li>利用Fundamentals of Computer Graphic作为补充内容；</li><li>在对应章节中，通过拆解项目和资源来深度理解知识；<ol><li>光追技术；</li><li>光栅化渲染；</li></ol></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/41468803">零基础如何学习计算机图形学？</a></p><p><a href="https://www.scratchapixel.com/">Scratchapixel</a></p><p><a href="https://www.zhihu.com/column/game-programming">浅墨的游戏编程</a></p><p><a href="https://developer.nvidia.com/gpugems/gpugems/contributors">Contributors</a></p><p><a href="https://learnopengl.com/Introduction">Introduction</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年开年返校被隔离了</title>
      <link href="/2022/02/09/si-kao-nei-sheng/2022-nian-kai-nian-fan-xiao-bei-ge-chi-liao/"/>
      <url>/2022/02/09/si-kao-nei-sheng/2022-nian-kai-nian-fan-xiao-bei-ge-chi-liao/</url>
      
        <content type="html"><![CDATA[<p>昨天返校了，本来有一个论文意见需要回复一下，今天一上午在回复论文的意见，准备今天完成意见回复后，就继续自己的毕业论文撰写，但是，天有不测风云，生活总是会跟你开一个玩笑。总是怕你太无聊，给你加入一些调味品，让你的生活充满丰富的色彩。</p><h1 id="诧异"><a href="#诧异" class="headerlink" title="诧异"></a>诧异</h1><p>中午收到一个短信，说我的杭州健康码变成了黄色，当时我一度有点懵，觉得是不是出现错误了，但是又是确实的信息，</p><p><img src="/images/%E9%9A%94%E7%A6%BB/message.png" alt="收到短信。。。"></p><p>虽然看到这个信息，但是仍然觉得不相信，此时想到的后果是：</p><ul><li>完了，可能要隔离；</li><li>信息要求报告，因此想能不能不报告，但是好像不行，会带来风险；</li></ul><p>总之，此时，就是上述两种心理的博弈，但是理性占据了上风，必须地报告，不然后果可能很大，不出事则已，一出事就是大事。</p><h1 id="懊悔"><a href="#懊悔" class="headerlink" title="懊悔"></a>懊悔</h1><p>想到上述的结果，第一时间就跟学校的负责人联系了，但是没有得到立即的反馈，可能他们也需要确定一下信息，于是我就等着。</p><p>但是，怎么想自己也不会是黄码，虽然从北京丰台区回来，但是不是中高风险的街道，想来也不会有问题，因此我还申诉了一下，结果还成功了，下午的时候，绿码回来了，但是行程码仍然有北京的痕迹，我后来想了一下，可能是因为在北京等车的时间超过了4个小时，有了痕迹，所以才被打上了黄码标签，真是充满了偶然性。</p><p>本来，我以为健康码变成了绿码，应该不会隔离了吧，但是下午得到的回复是去隔离，而且是14天，我天。。。，突然有一种自己没法按时毕业了的感觉，学院的老师的催促可能，在我看来就是让我延期毕业，那种对抗的心理很强烈，但是我忍住了，想用一个拖字诀。慢慢地，我觉得这样可能不对，因为无法解决问题，而且是躲避问题。要么立即隔离，要么承担后果，可能是无法活动，甚至学院可能有相应的惩罚措施等等，不管躲多久，迟早要面对这两个结果。</p><p>但是，我仍然不明白的是，国家已经公布了中低风险区，已经具体到街道，我觉得国家做的很好了，为什么地方仍要以严格管控为理由，扩大中高险地区范围呢？</p><p>同时也有一种懊悔的心情，如果自己不马上告诉老师，自己的健康码情况，等到健康码变绿，可能就不用报告和隔离了。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>今天面对的问题是个决策问题，其实是要找出一个最优的决策。</p><p>决策的目标是什么？通俗的说，早回来是为了抓紧时间赶论文毕业，这是我的目标。</p><p>本来一切顺利的话，就按照预定计划执行即可，但是突然有了意外情况——健康码变黄了，这个时候如何调整计划以适应预定的目标，有两个解决方案：</p><ul><li>瞒报<ul><li>最优的结果是谁都不知道，按照预定计划执行；</li><li>最坏的结果是，自己出现问题，被发现，然后被追溯信息，按原计划毕业时不可能了，甚至还会有额外的麻烦，甚至会影响为了的职业发展和规划。</li></ul></li><li>主动报告<ul><li>马上报告<ul><li>最坏的结果是集中隔离14天，在隔离场所写论文；</li><li>最好的结果，不用隔离，按照原计划执行；</li></ul></li><li>延迟报告<ul><li>最坏的结果，集中隔离14天，在隔离场所写论文；</li><li>最好的结果，不用隔离，按照原计划执行；</li></ul></li></ul></li></ul><p>从上述的分析中，发现瞒报肯定是不行的，最坏的结果是我无法承受的（在没有足够信息支撑的情况下做出这种决策）。</p><p>在主动报告中，马上和延迟报告的最好结果和最坏结果都是一样的，既然如此，但是延迟报告中，其发现最好结果的权重肯定要比马上报告大一些，因此这种情况下，目前信息的支撑下，延迟报告可能要好一些，因为得到的结果都是相同的。</p><p>总结来看，<strong>从决策角度来看，延迟报告更好一些，因为事态是在不断变化的，但是这种变化，并没有改变结果，只是改变了结果的分布。</strong></p><p>因此，应了那句话，</p><ul><li><strong>好事晚说不如早说</strong></li><li><strong>坏事早说不如晚说</strong></li></ul><h1 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h1><p>面对这种情况，可能有各种“如果”：</p><ul><li>如果，我当初没有从北京南回来。。。</li><li>如果，我当初没有停留超过4个小时。。。</li><li>如果，学校不是一刀切。。。</li><li>如果，我延迟报告。。。</li></ul><p><strong>没有那么多如果，事情已经发生了，原地懊悔3秒钟，就要想怎么应对的问题了，过去的事情永远无法改变。</strong></p><p><strong>你无法预测未来，就像你也无法预测股市一样，只能去应对。</strong>面对这种情况，可能需要：</p><ul><li>提前准备工作所需材料，做好准备；</li><li>合理安排自己的工作时间；</li><li>提前进行心理按摩，要在隔离点待14天；</li><li>保持身体健康，毕竟只在一个屋行动；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 思考内省 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年度总结：黎明前夜</title>
      <link href="/2022/02/01/si-kao-nei-sheng/2021-nian-du-zong-jie-li-ming-qian-ye/"/>
      <url>/2022/02/01/si-kao-nei-sheng/2021-nian-du-zong-jie-li-ming-qian-ye/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这些文字写在2021-2022年的除夕夜，2021年转眼间过去了。这一年感觉过得好快，疫情仍然影响着整个中国，甚至整个世界。所以，我将2021年的总结概括为：黎明前夜，不仅是对于我们生活的这个世界，也包括我们自己面对的情况，黎明前夜是怎样的状况？</p><ul><li>本质还是“夜”；</li><li>但是存在希望；</li><li>对于到达黎明的过程不会太长，但是这个过程中是最冷的；</li></ul><p>或许以后回看这些当时写下的文字时，也会体会到现在的心情吧。</p><h1 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h1><p>今年读了不少的闲书，不管是为了消遣时间还是提升认知，或者只是休息一下。虽然读了之后，发现好多东西都忘了，但是相比于没读，还是有意义的，不过今年学到了一个词“严肃学习”，其实用在读书上还是挺有用的，有些书可以在床上躺着读，有些只能在电脑边，边读边做笔记。这一点是我今年在读书时体会到的，还有一些听书的方式，我尝试了一下，发现并不适合我。</p><p>今年读的书好像有点杂，包括：</p><ul><li><p>《大空头》</p><p>  2020年投资市场的行情，实在是过于恐慌了，疫情的影响被极度放大了。之前看了《大空头》的电影，总有点觉得不过瘾，书确实能留出思考的时间，这本书对于08年那场风暴解释的很清楚，回头看，确是一个好的机会，如果子弹够的话。其中有很多专业术语，为了“专业”而专业，被包装成复杂的东西，显得“高大上”，其实全都是唬人的东西。回望今年，疫情引起的恐慌还在蔓延，但是仍然有一些机会，甚至有一些泡沫。</p></li><li><p>《我在美军航母上的8年》</p><p>  一个华裔士兵的美军服役记录，我觉得很真实，与其每天“厉害了，我的国”，不如老实了解一下，其他人都在干什么，整本书看完后，抛去华裔在海外的那些熟悉的经历，更多的是对于美军的专业性的认识。要像了解自己一样了解竞争者，不要走两个极端。</p></li><li><p>《周期》</p><p>  霍华德·马克斯对于周期的研究，投资中低买高卖是基本原则，但是实践起来是很困难的，如何识别当前位置的高低是一门艰深的学问，这本书尝试从不同角度回答这一问题，人类走极端的行为永远不会停止，而这些极端行为导致的结果总会回归正常，因此需要警惕“这次不一样的论调”，但是历史不会简单重复，但却遵从着类似的模式。这本书值得二刷。</p></li><li><p>《剧变：人类社会与国家危机的转折点》</p><p>  《枪炮、细菌与钢铁》同一作者——贾雷德·戴蒙德， 我挺喜欢这本书的，从国家历史的角度，分析个人的危机和国家危机的相似性，以及相应的处理策略，危机中永远蕴含着机会，像丘吉尔说的“永远不要浪费每一次危机”。总感觉作者和其他的人不太一样，看不出来他偏重哪个角度阐述，有融合了心理学、历史学、政治学还有自然科学等，不像枯燥的社科教材。</p></li><li><p>《创新者：一群技术狂人和鬼才程序员如何改变世界》</p><p>  这是写《乔布斯传》的作者写的，我觉得可以作为一个计算机专业学生的入门书籍，是极力推荐的，其中好多内容可以和大学学到的东西对应起来，当初学到的东西，全都是孤立的东西，现在这本书将所有内容都连起来了，从这一点上来看也是值得一读的。其中书中，没有如小标题所说那样，一定是技术推动，但无疑它扮演了主要的角色，还包括：家世、认知、文化、制度等。其中还充满着勾心斗角、官僚文化等等，总之，创新不是简单地完全由技术推动。</p></li><li><p>还有一本没有读完的《东京贫困女子》</p><p>  这本书看起来实在是太难受了，职场歧视、家庭破裂、性别歧视、性骚扰等等，困扰着女性们，但是这归根结底可能是多重因素导致的，一个发达国家中的高学历女性竟然沦落风尘，而且还不少，咋看咋觉得这个社会出现问题了，并不能全部如中国史家那样，只有有问题就归罪于女人。整本书，就不断将社会的黑暗面展现给你看，将负面情绪推到极点。后续，这本书会继续读下去。</p></li></ul><h1 id="财务规划"><a href="#财务规划" class="headerlink" title="财务规划"></a>财务规划</h1><p>今年也对自己的整个投资计划做了一个总结，因为也有帮老妈管理的部分。因为各种情况吧，今年的情况还算可以，但也是充满了魔幻，不管怎样这是第一次总结自己的投资成败，结果图表所示：</p><table><thead><tr><th>投资计划</th><th>收益率</th></tr></thead><tbody><tr><td>我的计划</td><td>14.87%</td></tr><tr><td>老妈的计划</td><td>5.75%</td></tr><tr><td>沪深300</td><td>-5.20%</td></tr><tr><td>中证500</td><td>15.58%</td></tr><tr><td>恒生指数</td><td>-14.08%</td></tr><tr><td>偏股混合基金</td><td>7.68%</td></tr></tbody></table><p>总的来说，结果还不错，其中第一次帮老妈管钱，之前也跟她明确了投资风格以稳健为主，因此投资了大量的债券和货币，所以基本没有回撤。虽然老妈说放心我，不在意投资啥，但是考虑到年纪和心理，还是以稳健为主，回家和老妈复盘了一下今年的成绩，得到认可，2022年可能需要加入一个增强的因素，来稍微提升一点收益率。</p><p>对于我自己，今年也在逐步建立自己的投资体系，目前已经有一个设计了，正在逐步实现，希望能够不断完善这个体系。而今年的成绩，有一些运气在里边，年初银行保险不太行，买了一些，所以收益还不错。在实践的过程中，逐步认识到投资是门技术+艺术的领域，很难完全从技术角度去理解，或者完全主观去看待，需要不断从实践中认识。</p><h1 id="自省和体会"><a href="#自省和体会" class="headerlink" title="自省和体会"></a>自省和体会</h1><p>今年的心情低落到极点，那种无力感，可能无法形容，我想极力挑出这种极端负面的情绪下，但是屡遭失败，这是自我调节的能力出现了问题，我想这种能力相比于技术能力、解决问题的问题更重要，因为学校里有些人，就是无法承受这种无力感，而选择了极端的行为，这是要避免的，现在我还不清楚如何锻炼这种能力，但是我意识到了这方面的缺乏，后续可能需要看一些书，或者相关材料学习，但是可能最好的还是自己从中体会并实践。</p><p>自我否定和怀疑，这几年来深深地陷入了自我否定的怪圈，觉得自己一文不值，什么都不会，什么都不行。后来反思，这与所在的环境密不可分，但是也有自己的原因，期望过高，并且没有对要做的事情进行量化，导致无法明确任务的结果，也就无法产生正反馈。但是今年通过参加了一些活动，觉得自己不是那么不堪，不管是从自己表现的结果来看，或者是他人的间接的评价来看。一个重要的原因，可能是做事的方法出现了问题，虽然做事有规划，但是没有明确的可量化的目标，或者阶段性的可以总结的成果，这是需要以后改正的。</p><p>今年的一个体会是，人们倾向于将一些表现突出的人神化为圣人，私以为这种倾向是有问题的，不管是专业领域还是日常生活，对于个人来说，这会让人迷信权威，没有独立思考的能力，对于被神化的人也没有好处，当人们把你捧得愈高，你会越焦虑，因为不敢丝毫出错误，只要有问题，你的所有之前的努力全都会被忽视，所有人都会背叛你，不管是娱乐明星还是专业人士。对于整个社会也存在隐患，人们不敢质疑，专业人士出一点问题就一棒子打死，那些当初最追捧你的，之后也是拆你墙最快的人。总之，对于我们自身来说，不要神化任何人，之前看到一个访问，一个诺贝尔经济学奖得主的投资成果，一塌糊涂，按理说没人比他更懂经济，但是结果就在那里。</p><h1 id="2022年目标"><a href="#2022年目标" class="headerlink" title="2022年目标"></a>2022年目标</h1><ul><li>很朴素和直接的一件事情——顺利毕业，拿到学位，这是今年的主要目标。</li><li>今年回家突然发现一件事情，老妈真的年纪大了，之前有意识到，但是没有几年这么明显，今年毕业回家后，要带老妈去至少两个地方游玩，并拍一些照片。</li><li>学习计算机图形学：完成闫令琪博士的<a href="http://games-cn.org/intro-graphics/">GAMES101:现代计算机图形学入门</a>课程和作业。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 思考内省 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RotatE - 建模复杂关系的利器</title>
      <link href="/2021/11/20/shu-ju-ke-xue/rotate-jian-mo-fu-za-guan-xi-de-li-qi/"/>
      <url>/2021/11/20/shu-ju-ke-xue/rotate-jian-mo-fu-za-guan-xi-de-li-qi/</url>
      
        <content type="html"><![CDATA[<p>文章来源: <a href="https://arxiv.org/abs/1902.10197v1">RotatE: Knowledge Graph Embedding by Relational Rotation in Complex Space</a></p><h1 id="之前研究中的问题"><a href="#之前研究中的问题" class="headerlink" title="之前研究中的问题"></a>之前研究中的问题</h1><p>不能对三种关系同时进行建模和推理。</p><blockquote><p>None of existing models is capable of modeling and inferring all the above patterns: symmetry/antisymmetry, inversion, and composition。</p></blockquote><h3 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h3><ul><li>symmetry：婚姻，双向关系；</li><li>antisymmetry：孝顺，单向关系；</li><li>inversion：上位词和下位词，正向和反向关系；</li><li>composition：我母亲的丈夫是我父亲，关系组合计算；</li></ul><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><blockquote><p>Motivation is from Euler’s identity: a unitary complex number can be regarded as a rotation in the complex plane.</p></blockquote><p>$$<br>e^{i\theta} = \text{cos}\theta + i\text{sin}\theta<br>$$</p><p>即，任何一个复数都可以看作复平面上的一个旋转向量。</p><p><strong>RotatE model maps the entities and relations to the complex vector space and deﬁnes each relation as a rotation from the source entity to the target entity.</strong></p><p>形式化表达：</p><p>Given a triplet $(h, r, t)$ , we expect that $t = h \circ r$ , where $h, r, t \in \mathbb{C}^k $ are the embeddings, the modulus $| r_i | = 1$ and $\circ$ denotes the <code>Hadamard (element-wise) product</code>. Speciﬁcally, for each dimension in the complex space, we expect that:</p><p>$$<br>t_i = h_i r_i , \text{where} \ h_i , r_i , t_i \in \mathbb{C}^k \text{and} \ | r_i | = 1.<br>$$</p><p>说明：</p><ul><li><p><code>symmetric</code></p><p>  a relation $r$ is symmetric if and only if each element of its embedding $r_i$ , satisﬁes $r_i= e^{0/i\pi}= \pm1$ ;</p></li><li><p><code>inverse</code></p><p>  Two relations $r_1$ and $r_2$ are inverse if and only if their embeddings are <code>conjugates</code>: $r_2= \overline{r}_1$ ;</p></li><li><p><code>composition</code></p><p>  a relation $r_3= e^{i\theta_3} $  is a combination of other two relations $r_1= e^{i\theta_1}$ and $r_2= e^{i\theta_2}$ if and only if $r_3 = r_1 \circ r_2$ (i.e. $\theta_3 = \theta_1 + \theta_2$ ).</p></li></ul><h1 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h1><h2 id="Relations-Formal-deﬁnition"><a href="#Relations-Formal-deﬁnition" class="headerlink" title="Relations Formal deﬁnition"></a>Relations Formal deﬁnition</h2><p><strong>Deﬁnition 1</strong>. A relation $r$ is <code>symmetric</code> (<code>antisymmetric</code>) if $\forall x, y$ </p><p>$$ r(x, y) ⇒ r(y, x) \ ( r(x, y) ⇒ ¬r(y, x) ) $$</p><p>A clause with such form is a <code>symmetry</code> (<code>antisymmetry</code>) pattern.</p><p><strong>Deﬁnition 2</strong>. Relation $r_1$ is <code>inverse</code> to relation $r_2$ if $\forall x, y$ </p><p>$$r_2 (x, y) ⇒ r_1(y, x)$$ </p><p>A clause with such form is a <code>inversion</code> pattern.</p><p><strong>Deﬁnition 3</strong>. Relation $r_1$ is <code>composed</code> of relation $r_2$ and relation $r_3$ . if $\forall x, y, z$</p><p>$$r_2 (x, y) ∧ r_3 (y, z) ⇒ r_1 (x, z)$$ </p><p>A clause with such form is a <code>composition</code> pattern.</p><h2 id="建模思考过程"><a href="#建模思考过程" class="headerlink" title="建模思考过程"></a>建模思考过程</h2><p>我们希望达成以下目标：</p><ul><li>(非)对称关系<br>$$ r(x, y) ⇒ r(y, x) \ ( r(x, y) ⇒ ¬r(y, x))$$</li><li>逆向关系<br>$$r_2 (x, y) ⇒ r_1(y, x)$$</li><li>组合关系<br>$$r_2 (x, y) ∧ r_3 (y, z) ⇒ r_1 (x, z)$$</li></ul><p>那就要找到一个函数能够实现这三种关系的表示。</p><p>TransE能够对这三种关系同时建模吗？稍稍分析一下：</p><ul><li><p>对于<code>symmetric</code></p><p>  需要找到满足条件的关系的embeddings</p><p>  $$ r(x, y) ⇒ r(y, x)$$</p><p>  $$x + r_i = y$$</p><p>  $$y + r_j = x$$</p><p>  $$r_i = r_j$$</p><p>  则，只能 $r_i = r_j = 0$ ，所以不能表示 <code>symmetric</code>。</p></li></ul><ul><li><p>对于<code>antisymmetry</code></p><p>  $$ r(x, y) ⇒ ¬r(y, x) $$</p><p>  要求：</p><p>  $$x + r_i = y$$</p><p>  $$y + r_j = x$$</p><p>  $$r_i \ne r_j$$</p><p>  模型是能够满足要求的，只要保证：</p><p>  $$r_i + r_j = 0$$</p><p>  $$r_i \ne r_j$$</p><p>  至于建模的效果好不好，那是另外一回事。</p></li><li><p>对于<code>inversion</code></p><p>  需要满足：</p><p>  $$r_2 (x, y) ⇒ r_1(y, x)$$ </p><p>  从上述<strong>反对称</strong>的角度进一步看，在满足<strong>反对称</strong>的同时，它也就满足了<code>inversion</code>关系的表达。</p><p>  $$x + r_2 = y$$</p><p>  $$y + r_1 = x$$</p><p>  $$r_i \ne r_j$$</p><p>  只要满足以下条件就行：<br>  $$r_1 = - r_2$$</p></li><li><p>对于<code>composition</code></p><p>  需要满足：</p><p>  $$r_2 (x, y) ∧ r_3 (y, z) ⇒ r_1 (x, z)$$</p><p>  对于使用TransE来表示如下：</p><p>  $$x + r_2 = y$$</p><p>  $$y + r_3 = z$$</p><p>  $$x + r_1 = z$$</p><p>  对<code>TransE</code>的表示进行变形：</p><p>  $$x + r_2 + r_3 = x + r_1$$</p><p>  自然得到：</p><p>  $$r_2 + r_3 = r_1$$</p></li></ul><p>总结来看，<code>TransE</code>除了<strong>对称关系</strong>无法表达，其余关系均能表达，<strong>现在的问题是如何在TransE的基础上对对称关系建模，使得关系的embedding不全为0.</strong></p><p>那么要明白的是<code>TransE</code>为啥不能建模对称关系？因为在使用<strong>平移</strong>建模关系时，对应的是<strong>加法运算</strong>。那么换一种想法，加法不行，那么乘法是不是可以？</p><p>为了满足对称关系的要求，有如下的关系：</p><p>$$hr_i = t$$</p><p>$$tr_j = h$$</p><p>$$r_i = r_j$$</p><p>能够推导出以下关系：</p><p>$$tr_jr_i = t$$</p><p>$$r_jr_i = 1$$</p><p>$$r_ir_i = 1 = r_jr_j$$</p><p>上述可以看成是一个维度上的情况，当换到所有embedding上的维度时，这就自然引出了 <code>Hadmard (or element-wise) product</code>。</p><p>这就是当时使用<code>Hadmard (or element-wise) product</code>需要满足的条件，为了建模对称关系，要保证:</p><p>$$r_ir_i = 1 = r_jr_j$$</p><p>其实，这就是上文中要保证 </p><p>$$| r_i | = 1$$</p><p>的原因。</p><p>We map the head and tail entities $h$ , $t$ to the complex embeddings, i.e., $\mathbf{h}, \mathbf{t} \in \mathbb{C}^ k$ , then we <code>deﬁne the functional mapping</code> induced by each relation $\mathbf{r}$ as an element-wise rotation from the head entity $\mathbf{h}$ to the tail entity $\mathbf{t}$ .</p><p>这里，开始时不明白为什么选择 <code>Hadmard (or element-wise) product</code>，这个与欧拉公式是啥关系？因为原文用了 <code>define</code>，我觉得逻辑可能并不充分，可能是一种启发式的选择，只要它满足三种关系的形式化建模就行。</p><blockquote><p>其实这种思考方法，我仔细想了一下，其实是两种方式的区别，我一开始不明白，是因为没有严格的逻辑推导出要用Hadmard，所以它出来时，我一头雾水，这是一种从因到果的思考方式。但是这里换一种方法去思考，Hadmard的结果满足我们开始时的假设，即能够建模对称关系，因此我们选了它，这是一种由果及因的方式，我的感觉，在ML领域这种方式好像更常见，也是被数学系的人吐槽的原因。</p></blockquote><h2 id="用Hadmard-product验证关系约束"><a href="#用Hadmard-product验证关系约束" class="headerlink" title="用Hadmard product验证关系约束"></a>用Hadmard product验证关系约束</h2><p>验证三种关系如下：</p><ul><li><p>对于<code>symmetric</code></p><p>  需要找到满足条件的关系的embeddings</p><p>  $$ r(x, y) ⇒ r(y, x)$$</p><p>  $$\mathbf{h} \circ \mathbf{r_i} = \mathbf{t}$$</p><p>  $$\mathbf{t} \circ \mathbf{r_j} = \mathbf{h} $$</p><p>  $$\mathbf{r_i} = \mathbf{r_j} $$</p><p>  推导出：<br>  $$\mathbf{r_i} \circ \mathbf{r_i} = 1 = \mathbf{r_j} \circ \mathbf{r_j} $$<br>  符合。</p></li><li><p>对于<code>antisymmetry</code></p><p>  类似的，<br>  $$ r(x, y) ⇒ ¬r(y, x) $$</p><p>  推导出，<br>  $$\mathbf{r_i} \circ \mathbf{r_i} \ne 1 $$<br>  符合。</p></li><li><p>对于<code>inversion</code></p><p>  需要满足：</p><p>  $$r_2 (x, y) ⇒ r_1(y, x)$$ </p><p>  $$\mathbf{h} \circ \mathbf{r_i} = \mathbf{t}$$</p><p>  $$\mathbf{t} \circ \mathbf{r_j} = \mathbf{h} $$</p>  <!-- $$\mathbf{r_i} = \mathbf{r_j} $$ --><p>  推导出：<br>  $$\mathbf{r_i} \circ \mathbf{r_j} = 1 $$</p><p>  $$\mathbf{r_i} = \mathbf{r_j}^{-1} $$</p><p>  符合。</p></li><li><p>对于<code>composition</code></p><p>  需要满足：</p><p>  $$r_2 (x, y) ∧ r_3 (y, z) ⇒ r_1 (x, z)$$</p><p>  根据：</p><p>  $$\mathbf{x} \circ \mathbf{r_2} = \mathbf{y}$$</p><p>  $$\mathbf{y} \circ \mathbf{r_3} = \mathbf{z} $$</p><p>  $$\mathbf{x} \circ \mathbf{r_1} = \mathbf{z} $$</p><p>  推导出：<br>  $$\mathbf{x} \circ \mathbf{r_2} \circ \mathbf{r_3} = \mathbf{x} \circ \mathbf{r_1} $$</p><p>  $$\mathbf{r_2} \circ \mathbf{r_3} = \mathbf{r_1}$$</p><p>  完美得出。</p></li></ul><p>总结来看，<code>Hadmard product</code>能够完美建模三种关系，到此，我们的假设成立。</p><h2 id="与欧拉公式的关系"><a href="#与欧拉公式的关系" class="headerlink" title="与欧拉公式的关系"></a>与欧拉公式的关系</h2><p>用类比的方法来看，<code>TransE</code>是将所有的实体和关系映射到embedding space中，也就是实平面，使用的是<strong>向量加法运算</strong>，三者之间的关系可以使用<strong>平移</strong>这种操作来建立关联。</p><p>那么<strong>Hadmard product</strong>实现的是<strong>向量元素乘法运算</strong>，如果放到实平面中，这没办法对应一个操作，不管是用矩阵乘法实现的线性变换，还是加上平移的仿射变换，都没办法对应将两个同样长度的向量经过元素相乘得到同样长度的向量，因此在理论上说不过去。</p><p>那么，换到复平面上，会怎么样？</p><p>我们知道复平面上一个复数的表示方法有好几种：</p><ul><li>代数：$a+ib$，以 $(1,i)$ 为基的线性组合；</li><li>指数形式</li><li>极坐标</li><li>向量形式</li><li>矩阵乘法</li></ul><p>具体的内容可以参看<a href="https://zhuanlan.zhihu.com/p/85321120">这里</a>。</p><p>通过欧拉公式可以将指数形式和极坐标建立关系。</p><p>此时，复数的相乘可以看做矩阵变换：</p><p>$$z_1z_2 =(a+ib)(c+id) = (ac-bd)+(bc+ad)i$$</p><p><img src="/images/rotate/5.png" alt="复数乘法视为矩阵变换"></p><p>我们只要把embedding拆成实部和虚部，然后再利用复数的乘法进行计算，就同样能得到实部和虚部，即形式不变。</p><p>到此为止，已经弄明白几件事情了：</p><ul><li><code>TransE</code>的缺陷</li><li><code>RoratE</code>的改进想法</li><li><code>Hadmard product</code>满足三种关系的表达需求</li><li><code>Hadmard product</code>的计算可以看成是复平面中embedding的相乘</li></ul><p>还有一件事情，复平面中embedding的相乘和欧拉公式有啥关系？</p><p>我们使用了<code>Hadmard product</code>将一个head实体变成了tail实体，其中的一个操作用来衡量关系，在复空间中将一个实体变成另一个实体，使用的是乘法的方式，那就是指数了，而指数与复空间建立关系的途径，就是欧拉公式。</p><p>$$<br>e^{i\theta} = \text{cos}\theta + i\text{sin}\theta<br>$$</p><p>复空间中的每个数有指数形式和极坐标形式，这两者之间的关系也是欧拉公式。</p><p>从指数形式来看，将一个复数的embedding变换成另一个复数的embedding如下：</p><p>$$e^{i{\Theta}_h} e^{i{\Theta}_r} = e^{i{\Theta}_t}$$</p><p>用极坐标表示，就是将$e^{i{\Theta}_h}$ 逆时针方向旋转了角度 $\Theta_r$，变成了 $e^{i{\Theta}_t}$ 。</p><p>当将关系写成极坐标形式时，</p><!--$$\begin{pmatrix}    \text{cos}\theta & -\text{sin}\theta \\  \text{sin}\theta & \text{cos}\theta \end{pmatrix} $$--><p><img src="/images/rotate/math_1.png"></p><p>也就是如下所示：</p><!--$$\begin{pmatrix}    a & -b \\    b & a \end{pmatrix}\begin{pmatrix}    \text{cos}\theta & -\text{sin}\theta \\    \text{sin}\theta & \text{cos}\theta \end{pmatrix}$$ --><p><img src="/images/rotate/math_2.png"></p><p>这不就是线性变换里的旋转吗，也就是本文的名称的由来！</p><p>不明白的可以回顾一下<a href="https://blog.csdn.net/huangguohui_123/article/details/106000355">以前的知识</a>。</p><p>因为我们之前约束了关系的模长固定，为1，即 $|r_i| = 1$ 。</p><p>因此，在旋转过程中，head实体的模长不会受到影响，只是每一个维度下的复数的相位受到了影响。</p><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>For each triple $(h, r, t)$ , we deﬁne the <code>distance function</code> of RotatE as:</p><p>$$d_r (\mathbf{h}, \mathbf{t}) = \Vert \mathbf{h} \circ \mathbf{r} − \mathbf{t} \Vert$$</p><h2 id="Loss函数"><a href="#Loss函数" class="headerlink" title="Loss函数"></a>Loss函数</h2><!--$$L=-\log \sigma \left( \gamma-d_r (\mathbf{h}, \mathbf{t}) \right) - \sum_{i=1}^{n} \frac{1}{k} \log \sigma\left (d_r \left( \mathbf{h}_{i}^{\prime}, \mathbf{t}_{i}^{\prime}\right)-\gamma\right)$$--><p><img src="/images/rotate/math_3.png"></p><ul><li>$\gamma$ : 和<code>TransE</code>中一样，是<code>margin</code>，视为超参数；</li><li>$\sigma$ : <code>sigmoid function</code></li><li>$(h_i , r, t_i )$ is the <code>i-th negative triplet</code>.</li><li>$k$ 为embedding dimension</li></ul><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>原来的采样方式是使用<strong>均匀的方式</strong>替换head和tail：</p><ul><li><p>低效</p><p>  suffers the problem of inefﬁciency since many samples are obviously false as training goes on</p></li><li><p>没有足够的信息</p><p>  not provide any meaningful information.</p></li></ul><p>文中提出<code>self-adversarial negative sampling</code>，具体而言就是按照以下方式进行采样，</p><!--$$p\left(h_{j}^{\prime}, r, t_{j}^{\prime} \mid\left\{\left(h_{i}, r_{i}, t_{i}\right)\right\}\right)=\frac{\exp \alpha f_{r}\left(\mathbf{h}_{j}^{\prime}, \mathbf{t}_{j}^{\prime}\right)}{\sum_{i} \exp \alpha f_{r}\left(\mathbf{h}_{i}^{\prime}, \mathbf{t}_{i}^{\prime}\right)}$$--><p><img src="/images/rotate/math_4.png"></p><ul><li><p>$\alpha$ : temperature of sampling. </p><blockquote><p>Moreover, since the sampling procedure <strong>may be costly</strong>, we treat the above probability as the <strong>weight of the negative sample</strong>. Therefore, the ﬁnal negative sampling loss with self-adversarial training takes the following form:</p></blockquote><p>  <img src="/images/rotate/math_5.png"></p></li></ul><!--$$L=-\log \sigma\left(\gamma-d_{r}(\mathbf{h}, \mathbf{t})\right)-\sum_{i=1}^{n} p\left(h_{i}^{\prime}, r, t_{i}^{\prime}\right) \log \sigma\left(d_{r}\left(\mathbf{h}_{i}^{\prime}, \mathbf{t}_{i}^{\prime}\right)-\gamma\right)$$--><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p><img src="/images/rotate/1.png" alt="数据集"></p><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><ul><li><p><code>Filtered setting</code>: we rank test triples against all other candidate triples not appearing in the training, validation, or test set, where candidates are generated by corrupting subjects or objects: $(h^{‘} , r, t)$ or $(h, r, t^{‘} )$. </p></li><li><p><code>Mean Rank (MR)</code>, <code>Mean Reciprocal Rank (MRR)</code> and <code>Hits at N (H@N)</code> are standard evaluation measures for these datasets and are evaluated in our experiments.</p></li></ul><h2 id="超参设置"><a href="#超参设置" class="headerlink" title="超参设置"></a>超参设置</h2><ul><li><code>optimizer</code>: <code>Adam</code></li><li><code>search strategy</code>: ﬁne-tune the hyperparameters on the validation dataset with <code>grid search</code></li><li><code>embedding dimension</code>: 125, 250, 500, 1000</li><li><code>batch size</code>: 512, 1024, 2048 </li><li>self-adversarial <code>sampling temperature</code>: 0.5, 1.0 </li><li><code>ﬁxed margin</code> $\gamma$ :3, 6, 9, 12, 18, 24, 30. we ﬁnd that the ﬁxed margin $\gamma$ could prevent our model from over-ﬁtting.</li></ul><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>这里主要体现了在3个来源，4个数据集上的评估效果。</p><p><img src="/images/rotate/2.png" alt="在FB15k和WN18的结果"><br><img src="/images/rotate/3.png" alt="在FB15k-237和WN18RR的结果"><br><img src="/images/rotate/4.png" alt="在Countries的结果"></p><h1 id="结果总结"><a href="#结果总结" class="headerlink" title="结果总结"></a>结果总结</h1><p>本论文主要达成了三项目的：</p><ul><li><p>able to <strong>model and infer various relation patterns</strong> including: symmetry/antisymmetry, inversion, and composition.</p></li><li><p>propose a <strong>novel self-adversarial negative sampling technique</strong> for efﬁciently and effectively training the RotatE model.</p></li><li><p>the RotatE model is <strong>scalable to large knowledge graphs</strong> as it remains linear in both time and memory.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 表示学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TransE - 简单但有效的知识图谱表示学习方法</title>
      <link href="/2021/11/19/shu-ju-ke-xue/transe-jian-dan-dan-you-xiao-de-zhi-shi-tu-pu-biao-shi-xue-xi-fang-fa/"/>
      <url>/2021/11/19/shu-ju-ke-xue/transe-jian-dan-dan-you-xiao-de-zhi-shi-tu-pu-biao-shi-xue-xi-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>来自论文 NIPS 2013年的 <a href="https://papers.nips.cc/paper/2013/hash/1cecc7a77928ca8133fa24680a88d2f9-Abstract.html">Translating Embeddings for Modeling Multi-relational Data</a>。</p><p>这个方法开创了KGE中的一种思考方式，虽然简单，但是值得一读，因为有时候越简单的方法，取得的效果可能没有人们想得那么差。</p><h1 id="针对的问题"><a href="#针对的问题" class="headerlink" title="针对的问题"></a>针对的问题</h1><p>The problem of <code>embedding entities and relationships of multirelational data</code> in low-dimensional vector spaces.</p><h2 id="针对的研究对象"><a href="#针对的研究对象" class="headerlink" title="针对的研究对象"></a>针对的研究对象</h2><p><code>Multi-relational data</code> refers to directed graphs whose nodes correspond to <code>entities</code> and <code>edges</code> of the form <code>(head, label, tail)</code> , denoted $(h, l, t)$ , each of which indicates that there exists a relationship of name <code>label</code> between the entities <code>head</code> and <code>tail</code>.</p><h2 id="之前研究存在问题"><a href="#之前研究存在问题" class="headerlink" title="之前研究存在问题"></a>之前研究存在问题</h2><ul><li>表达能力上升以计算成本上升为代价</li></ul><blockquote><p>The greater expressivity of these models comes <code>at the expense of substantial increases in model complexity</code> which results in modeling assumptions that are <code>hard to interpret</code>, and in <code>higher computational costs</code>.</p></blockquote><ul><li>正则化方法难以设计导致过拟合</li></ul><blockquote><p>such approaches are potentially subject to either <code>overﬁtting</code> since <code>proper regularization of such high-capacity models is hard to design</code>, </p></blockquote><ul><li>非凸优化导致欠拟合</li></ul><blockquote><p>or <code>underﬁtting</code> due to the <code>non-convex optimization problems</code> with many local minima that need to be solved to train them.</p></blockquote><h1 id="研究目标"><a href="#研究目标" class="headerlink" title="研究目标"></a>研究目标</h1><p>模型希望达到的目标：</p><ul><li>easy to train,</li><li>contains a reduced number of parameters,</li><li>and can scale up to very large databases</li></ul><p>in complex and heterogeneous multi-relational domains simple yet appropriate modeling assumptions can <strong>lead to better trade-offs between accuracy and scalability</strong>.</p><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>Relationships are represented as <code>translations</code> in the <code>embedding space</code>: if $(h, l, t)$ holds, then the embedding of the tail entity $t$ should be close to the embedding of the head entity $h$ plus some vector that depends on the relationship $l$ .</p><p>模型的基本想法是<code>head</code>的向量表示 $h$ 与<code>relation</code>的向量表示 $r$ 之和与<code>tail</code>的向量表示  $t$ 越接近越好，即：</p><p>$$<br>h+r \approx t<br>$$</p><p>这里的“接近”可以使用<code>L1</code>或<code>L2</code>范数进行衡量，这也是一个可以调节的超参数。</p><h2 id="方法过程"><a href="#方法过程" class="headerlink" title="方法过程"></a>方法过程</h2><p><img src="/images/transe/1.png" alt="算法过程"></p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>损失函数是使用了负抽样的max-margin函数（原文为：<code>a margin-based ranking criterion</code>）。</p><p>$$<br>L(y, y^{\prime}) = \max(0, margin - y + y^{\prime})<br>$$</p><ul><li>$y$ 是正样本的得分；</li><li>$y^{\prime}$ 是负样本的得分。</li></ul><p>然后使损失函数值最小化，当这两个分数之间的差距大于<code>margin</code>的时候就可以了(我们会设置这个值，通常是1，这个是超参数)。</p><p>由于我们使用距离来表示得分，所以我们在公式中加上一个减号，知识表示的损失函数为：</p><p>$$<br>L(h,r,t) = \max(0, d_{pos} - d_{neg} + margin)<br>$$</p><p>其中，$d$ 是：</p><p>$$<br>d = \Vert h+r -t \Vert<br>$$</p><p>这是<code>L1</code>或<code>L2</code>范数。至于如何得到负样本，则是将head实体或tail实体替换为三元组中的随机实体，具体的方法可以参考 <a href="https://lifehit.cn/2021/11/17/zhi-shi-tu-pu-biao-shi-xue-xi-xun-lian-fang-fa/">知识图谱表示学习：训练方法</a>。</p><h2 id="需要调节的参数"><a href="#需要调节的参数" class="headerlink" title="需要调节的参数"></a>需要调节的参数</h2><p>对于模型本身来说，只需要确定：</p><ul><li>实体和关系的维度：<code>embedding size</code></li><li>衡量接近程度的指标：<code>L1</code>或者<code>L2</code></li><li><code>margin</code></li></ul><p>即可。</p><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><h2 id="使用的数据集"><a href="#使用的数据集" class="headerlink" title="使用的数据集"></a>使用的数据集</h2><p><img src="/images/transe/2.png" alt="使用的数据集"></p><h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><ul><li><p>评估指标</p><ul><li><code>mean rank</code></li><li><code>hits@10</code></li></ul></li><li><p>过滤真实三元组</p></li></ul><p>这部分可以参考 <a href="https://lifehit.cn/2021/11/17/zhi-shi-tu-pu-biao-shi-xue-xi-ping-gu-fang-fa/">知识图谱表示学习：评估方法</a>。</p><h2 id="评估结果"><a href="#评估结果" class="headerlink" title="评估结果"></a>评估结果</h2><p><img src="/images/transe/3.png" alt="Link prediction 评估结果"></p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><ul><li><code>optimizer</code>: stochastic gradient descent</li><li><code>lr</code>: 0.001, 0.01, 0.1</li><li><code>margin</code>: 1, 2, 10</li><li><code>dimension k</code>: 20, 50</li><li><code>regularization</code>: L1, L2</li><li><code>epochs</code>: &lt;1000</li></ul><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul><li>simplicity</li><li>只适合处理一对一的关系，不适合一对多/多对一/多对多的关系。<blockquote><p>举个例子，有两个三元组（中国科学院大学，地点，北京）和（颐和园，地点，北京），使用TransE进行表示的话会得到中国科学院大学的表示向量和颐和园的表示向量很接近，甚至完全相同。但是它们的亲密度实际上可能没有这么大。</p></blockquote></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个方法从模型角度来看，很简单，但是要注意文章的目标是，取得预测性能和计算性能之间的平衡，也就说是比我强的没我快，比我快的没我强。</p><p>而且整个模型，很优美，没有任何繁琐的东西，是值得读的一篇入门的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 表示学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我还是重启了博客写作</title>
      <link href="/2021/11/18/si-kao-nei-sheng/wo-huan-shi-chong-qi-liao-bo-ke-xie-zuo/"/>
      <url>/2021/11/18/si-kao-nei-sheng/wo-huan-shi-chong-qi-liao-bo-ke-xie-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="以前的博客"><a href="#以前的博客" class="headerlink" title="以前的博客"></a>以前的博客</h1><p>博客的写作已经停了很久了，至于当初是如何开始的，已经有点记不清了，不过有一点可以明确的是：当初写博客一半是为了记录技术的积累，一半是有一定的功利性的，就是能够在找工作时写到简历上。最后找到的工作不错，不知道这个有没有起作用。</p><p>当初写博客时，由于是第一次，就直接在一个技术网站上开始了，这个网站，如果经常泡技术社区的人都会知道，CSDN，开始他提供了比较便捷的方式，你只要写就行了，所以对于新手还是挺友好的，类似的平台还有博客园，等等。</p><p>在这个平台上我也写作也慢慢稳定下来，截止到现在 2021年11月18日，目前的数据如下所示：</p><p><img src="/images/restart_blog/1.png" alt="以前的博客浏览数据1"><br><img src="/images/restart_blog/2.png" alt="以前的博客浏览数据2"></p><p>最后一篇文章是发布于2017年9月份，距今已经4年多了，然后我就停止了更新。说实话，这些数据是我没有想到的，因为当时是一边学技术，一边记录下自己的问题，没想到过得到很多人的反馈，虽然与很多的大佬不能比，但是还是有一些成就感的。在此，也为之前积极给与反馈的朋友表示感谢。</p><p>但是之后为啥停了呢？除了一些其他原因，主要有以下几个方面：</p><h2 id="CSDN的环境在变坏"><a href="#CSDN的环境在变坏" class="headerlink" title="CSDN的环境在变坏"></a>CSDN的环境在变坏</h2><p>不知道从什么时候开始，CSDN中的广告和写作的体验越来越不好了，当你看到辛辛苦苦写完的文章，旁边有一个让人不适的广告时，总觉得有点难受。</p><p>同时，还有一些技术上的原因，在写作的过程中，有一次，我发现写到一半的文章消失了，没有任何记录，这导致我对这个平台产生了不信任感，同时还包括整个平台技术质量的下降，之后我有任何问题，基本都是去Stack Overflow查找，除了一些软件安装上遇到的问题。</p><p>慢慢地，当你写的越多，会发现对这个平台的失望越多，而且沉没成本越高，不容易迁移。因此，希望，能有一个自己掌控的平台。</p><h2 id="专注于技术领域的限制"><a href="#专注于技术领域的限制" class="headerlink" title="专注于技术领域的限制"></a>专注于技术领域的限制</h2><p>之前写的博客，专注于纯技术领域，但是慢慢地，我发现，这种“自我设限”的方式，不利于自己的发展，因为人的思考是多方面的，因此，我希望从各个方面来记录个人的发展和对技术的思考，而不只是技术本身。</p><p>基于这种考虑，希望建立一种综合的博客体验，全面地记录技术、思考和阅读，以及自己的一些经历。</p><h1 id="为啥重启"><a href="#为啥重启" class="headerlink" title="为啥重启"></a>为啥重启</h1><p>重启博客的写作是不容易的，开始很难，但是坚持更难，不怕笑话，之前我尝试重启了一次，但是由于种种原因，最后没有坚持下去。但是，此时此刻，我觉得可能仍然没有准备好，但不是有一句话吗？<strong>做一件事最好的时刻是10年前，其次是现在。</strong> 纵然，现在仍然有很多的事情需要处理，但是我还是挤出时间，重建了这个博客平台。因为，我知道，有些东西，<strong>如果不现在记录下来，可能就永远没有记录的机会了。</strong></p><p>为啥要重启博客写作，说到底主要有两个方面原因：</p><h2 id="留下思考的legacy"><a href="#留下思考的legacy" class="headerlink" title="留下思考的legacy"></a>留下思考的legacy</h2><p>不像4年前那么功利性了，反倒是希望留下一些legacy，能够供以后来回忆，不管是技术，还是思考，阅读。</p><p>可能是年纪大了，学生时代的尾声慢慢来到了。有很多的内容输出，虽然也有一直在整理，但是都是躺在自己的Notion里，没有输出到公开的世界，可能都是自嗨，因此，也希望找一个出口，能够呈现自己的学习，思考和经历。</p><h2 id="促进学习和交流"><a href="#促进学习和交流" class="headerlink" title="促进学习和交流"></a>促进学习和交流</h2><p>最近看了很多学习过程方面的文章和书籍，深刻领会到一件事情：<strong>说不出来的知识，就是你还不懂的。</strong> 对于你能掌握的知识，最好是以简单和易懂的方式说出来，讲给别人听，如果别人懂了，那么你也懂了，如果别人不懂，其实你也不懂，因为每次学习一个新的知识，我们都倾向于骗自己，因为自己轻易就懂了，但是事实可能正好相反。</p><p>费曼学习方法，我在好多文章和书籍里都听到了这个方法，可以简单看<a href="https://learnku.com/articles/35137">这里</a>了解，便深入查看了一下，对于费曼这个人，大家可以去wiki查看，对于这种学习方法，简单来讲，即：</p><ul><li>学东西；</li><li>教给别人；</li><li>如果讲不清，回去重学；</li><li>再教，以把外行人教懂为目标；</li></ul><p>其中需要找到一个情景，来实现“教”这个步骤，我希望这个博客能充当这个媒介，当然不是传统的“教授”，而是作为一个将学到的知识进行总结、陈述和输出的平台，这样能让自己掌握的更加夯实。</p><h1 id="以后的发展"><a href="#以后的发展" class="headerlink" title="以后的发展"></a>以后的发展</h1><p>我也不知道未来会发展成什么样子，总之希望能坚持下去，我很钦佩阮一峰、陈皓等大神的持之以恒，或许这就是他们能走出一条对于技术人员来说，很成功的路。</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>在互联网的时代，我们是幸福的，这个博客平台的搭建，并没有消耗太多时间，因为有以下的技术支撑：</p><ul><li>Github</li><li>Hexo静态博客</li><li>Hexo主题 <a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a></li><li>万网域名</li><li>Google Analytics</li></ul>]]></content>
      
      
      <categories>
          
          <category> 思考内省 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱表示学习：评估方法</title>
      <link href="/2021/11/17/shu-ju-ke-xue/zhi-shi-tu-pu-biao-shi-xue-xi-ping-gu-fang-fa/"/>
      <url>/2021/11/17/shu-ju-ke-xue/zhi-shi-tu-pu-biao-shi-xue-xi-ping-gu-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>如何对知识图谱进行评估，其实知识图谱本身并不需要评估，因为其中的实体和关系已经确定，但是考虑到应用时的效率问题等，需要将它们表示成低维向量的形式，因此这种评估是针对表示为低维向量的知识图谱，来探求：低维向量的形式是否能完美代表之前的知识图谱。</p><h1 id="评估数据准备"><a href="#评估数据准备" class="headerlink" title="评估数据准备"></a>评估数据准备</h1><p>那么如何评估这种“完美程度”呢？我们知道在一些tabular数据中使用的模型，比如random forest，GBDT，来一组新的数据，因为有标记，我们预测新数据产生的输出，来与标记进行对比。模型学到的是不同类型数据之间的交互。这种情况下，是通过对新的数据进行prediction来评估模型的学习成果。</p><p>那么在知识图谱表示学习中，模型学到了什么？因为本质上是换了一种表示方法，所以模型学到的是针对同一事务的不同的表示形式，那么就要求在评估时，仍然有同一事务的存在，这么说有点抽象，举个例子：</p><table><thead><tr><th>$x_1$</th><th>$x_2$</th><th>$…$</th><th>$x_{i-1}$</th><th>$x_{i}$</th><th>$y$</th></tr></thead><tbody><tr><td>3</td><td>4</td><td>$…$</td><td>4</td><td>3</td><td>1</td></tr><tr><td>1</td><td>5</td><td>$…$</td><td>9</td><td>0</td><td>0</td></tr><tr><td>2</td><td>1</td><td>$…$</td><td>11</td><td>7</td><td>1</td></tr></tbody></table><p> 假设这是一个tabular数据的预测问题，例如：男生能否脱单。</p><p> 每个维度的向量$x_i$ 代表一种数据，比如：</p><ul><li>$x_1$ 代表你的学历；</li><li>$x_2$ 代表你的家庭背景；</li><li>等等，如此类推…</li></ul><p> 当进行评估时，你所需要的是再出现一个同样格式的数据，每一维的数据的意义和训练集的类似，比如：你不能说在评估时出现一个 $x_{i+1}$ 代表这个人是否会养猪，因为这种类型的数据不在训练集中。</p><p> 同样的，知识图谱表示学习中学到的是一个实体或者关系的低维向量表示，当训练集中出现的是: 高圆圆和Alex, 在评估时，你让我评估 新垣结衣和小约翰(均没有出现在训练集中)的关系。</p><p> 这一点是和之前的评估方法有所区别的。</p><p> 那么如何准备训练集和测试集呢？<strong>在评估数据准备时的一个原则：保证测试集中出现的实体和关系均在训练集中出现。</strong></p><blockquote><p>不同时出现，我评估谁去？谁知道小约翰和新垣结衣合不合适？但我们能评估高圆圆和Alex合不合适… </p></blockquote><h1 id="评估任务"><a href="#评估任务" class="headerlink" title="评估任务"></a>评估任务</h1><p>在KGE评估时，一般采取的是<code>Link prediction</code>任务，在准备时，可以采取的策略：</p><ul><li>在原始的知识图谱上随机删除一些link，然后在评估时预测这些link是否存在，这种情况下，需要计算预测的准确率；</li><li>还有一种方法是，将<code>link prediction</code>视为<code>learn to rank</code>任务，通<strong>过排序的指标进行评估，这种方式目前是主流的方法</strong>，下文主要阐述这种方法；</li></ul><p>对于这种方法，首先确定需要进行评估的数据集 $\mathcal{E}$ ，因为有时候进行评估的数据集可能并不是原始的完整的数据集，然后针对数据集中的三元组，进行两种类型的替换，如下：</p><ul><li><p>$(h, r, ?)$ ：取 $\mathcal{E}$ 中的所有实体，替换？，然后计算 $(h, r, t)$ 在其中的排序，越靠前越好；</p></li><li><p>$(?, r, t)$ ：取 $\mathcal{E}$ 中的所有实体，替换？，然后计算 $(h, r, t)$ 在其中的排序，越靠前越好；</p></li></ul><h1 id="评估指标-Rank-based-method"><a href="#评估指标-Rank-based-method" class="headerlink" title="评估指标(Rank-based method)"></a>评估指标(Rank-based method)</h1><h2 id="Hits-K"><a href="#Hits-K" class="headerlink" title="Hits@K"></a>Hits@K</h2><p>hits@k根据出现在排序列表中的前k个实体中，真实实体排序的位置进行评估。</p><p>具体计算方式如下：</p><p>$$<br>\text{hits@}k = \frac{1}{|\mathcal{I}|} \sum \limits_{r \in \mathcal{I}} \mathbb{I}[r \leq k]<br>$$</p><ul><li>$\mathcal{I}$ 表示一组排序的结果；</li><li>$|\mathcal{I}|$ 表示一组排序的结果的数量；</li><li>$\mathbb{I}$ 为指示函数；</li><li>$k$ 为界定的范围，常为1, 3, 5, 10</li><li>该值越接近1，说明学习的效果越好；</li><li>这里的<code>r</code>指的是<code>rank</code>;</li></ul><p>一个例子说明：</p><p>当有3个正样本用于生成负样本时，同时考虑替换head和tail，可以生成6个负样本，也就可以得到6个排名结果。</p><table><thead><tr><th>正样本</th><th>head负样本</th><th>tail负样本</th><th>head负样本排序</th><th>tail负样本排序</th></tr></thead><tbody><tr><td>$(h_1, r_1, t_1)$</td><td>$(h_1, r_1, ?)$</td><td>$(?, r_1, t_1)$</td><td>8</td><td>4</td></tr><tr><td>$(h_2, r_2, t_2)$</td><td>$(h_2, r_2, ?)$</td><td>$(?, r_2, t_2)$</td><td>2</td><td>1</td></tr><tr><td>$(h_3, r_3, t_3)$</td><td>$(h_3, r_3, ?)$</td><td>$(?, r_3, t_3)$</td><td>90</td><td>1</td></tr></tbody></table><p>则计算如下：</p><p>$$<br>hits@1 = \frac{1}{6} \times (0 + 0 + 0 + 1 + 0 + 1) = 0.3333<br>$$</p><p>$$<br>hits@3 = \frac{1}{6} \times (0 + 0 + 1 + 1 + 0 + 1) = 0.50<br>$$</p><p>$$<br>hits@5 = \frac{1}{6} \times (0 + 1 + 1 + 1 + 0 + 1) = 0.6667<br>$$</p><p>如果你实际计算时会发现一个问题，比如对于 $(h_1, r_1, ?)$，它的排序为8，但是由于比1， 3， 5都大，所以仍然记为0，但是它比 $(h_3, r_3, ?)$ 的排序为90，要好很多，但是对于 $rank &gt; k$ 的，该指标一视同仁，也是一个缺陷。</p><h2 id="Mean-Rank-MR"><a href="#Mean-Rank-MR" class="headerlink" title="Mean Rank(MR)"></a>Mean Rank(MR)</h2><p>正如名字体现的，是triples所有排序的算术平均值，这个值的范围是: [1, 所有负样本的数量]。</p><ul><li>1 表明是最理想的情况，所有的triples的排序都是1；</li><li>所有负样本的数量：最坏的情况，所有的排序都是最后一个；</li><li>这个指标越低越好；</li></ul><p>$$<br>\text{score} =\frac{1}{|\mathcal{I}|} \sum \limits_{r \in \mathcal{I}} r<br>$$</p><p>根据上述的6个负样本，计算如下：</p><p>$$<br>\text{MR} = \frac{1}{6} \times (8 + 4 + 2 + 1 + 90 + 1) = 17.6667<br>$$</p><p>从计算方式上来看，这个评估指标比<code>Hits@K</code>好的地方在于：</p><blockquote><p>it is sensitive to any model performance changes, not only what occurs under a certain cutoff and therefore reflects average performance.</p></blockquote><p>但是它的缺陷也很明显，虽然有一定的解释性，但是由于它的边界取决于负样本的数量，但是MR=10，对于负样本为20或者200000的模型，其性能指示含义完全不同。</p><h2 id="Mean-reciprocal-rank-MRR"><a href="#Mean-reciprocal-rank-MRR" class="headerlink" title="Mean reciprocal rank(MRR)"></a>Mean reciprocal rank(MRR)</h2><p>MRR是所有排名的倒数的算术平均值，具体计算如下：</p><p>$$<br>\text{score} =\frac{1}{|\mathcal{I}|} \sum_{r \in \mathcal{I}} r^{-1}<br>$$</p><p>根据上述的6个负样本，计算如下：</p><p>$$<br>\text{MR} = \frac{1}{6} \times (\frac{1}{8} + \frac{1}{4} + \frac{1}{2} + \frac{1}{1} + \frac{1}{90} + \frac{1}{1}) = 0.4810<br>$$</p><ul><li>这个指标在 $[0, 1]$ 之间;</li><li>是对MR的一种改进，使得可以对异常值不太敏感，这里指对高rank的异常值不敏感，但是去开始对低rank值敏感；</li></ul><p>同样的问题，对于一个模型，如果观察到MRR指标为0.01， 那么这个模型是好还是不好？</p><p>这种结论很难直接下，这个值意味着，当去掉outliers时，平均排名为 100(1/0.01) 左右，这个结果可能是好的，也可能是坏的，这取决于使用的负样本的数量。</p><ul><li>当使用了100万的负样本, 那么这个结果很好，因为在100万中排名100，是很好的；</li><li>当使用了负样本只有100个，说明test triples在跟corruptions一起排名时得到的结果很差；</li></ul><p>在真实的数据集上，应该仔细看看hits@k这个指标，之后再判断模型的好坏。</p><p>其中k的选择，应该取决于针对每个test triple生成的负样本的数量。</p><blockquote><p>其实主要的评估指标，包括：<code>MRR</code>, <code>hits@k</code>, 已经是经常使用的了，例如在：<a href="https://paperswithcode.com/task/link-prediction">paperswithcode</a>和<a href="https://www.jiqizhixin.com/sota/tech-task/90c2aa81-2fb1-4363-a379-53edc69b3898">机器之心</a>的SOTA中都是以这几种组作为benchmark的。</p></blockquote><h2 id="其他的指标"><a href="#其他的指标" class="headerlink" title="其他的指标"></a>其他的指标</h2><p>针对上述常用的指标，也有一些改进的衡量指标，比如：</p><ul><li>Inverse Geometric Mean Rank</li><li>Adjusted Mean Rank</li><li>Adjusted Mean Rank Index</li></ul><p>这些指标可以参考 <a href="https://pykeen.readthedocs.io/en/stable/tutorial/understanding_evaluation.html">其他衡量指标</a></p><h1 id="深入评估细节"><a href="#深入评估细节" class="headerlink" title="深入评估细节"></a>深入评估细节</h1><h2 id="如何计算rank"><a href="#如何计算rank" class="headerlink" title="如何计算rank?"></a>如何计算rank?</h2><p>上边我们默认已经知道rank，但是rank是如何计算的，不就是排序列表的索引吗？</p><p>对于一个模型，输出针对triples的分数如下：</p><table><thead><tr><th>Triples</th><th>Score</th><th>Rank(optimistic)</th><th>Rank(pessimistic)</th><th>Rank(realistic)</th></tr></thead><tbody><tr><td>(高圆圆，喜欢，XXX)</td><td>0.9628</td><td>1</td><td>1</td><td>1</td></tr><tr><td>(高圆圆，喜欢，Alex)</td><td>0.9405</td><td>2</td><td>3</td><td>2.5</td></tr><tr><td>(高圆圆，喜欢，赵又廷)</td><td>0.9405</td><td>3</td><td>2</td><td>2</td></tr><tr><td>(高圆圆，喜欢，小约翰)</td><td>0.0001</td><td>4</td><td>4</td><td>4</td></tr></tbody></table><p>但是会出现一个问题：如果模型针对不同的triples输出同样的分数时，如何计算rank？这时候有三种方式：</p><ul><li><code>optimistic</code>：乐观的方式，当正样本和其他的负样本有同样的分数时，则排名取第一个；</li><li><code>pessimistic</code>：悲观的方式，当正样本和其他的负样本有同样的分数时，则排名取最后一个；</li><li><code>realistic</code>：务实的方式，当正样本和其他的负样本有同样的分数时，则排名取<code>optimistic</code>和<code>pessimistic</code>的平均排名；</li></ul><h2 id="rank选边"><a href="#rank选边" class="headerlink" title="rank选边"></a>rank选边</h2><p>上述我们一直默认，当生成负样本时，是针对head和tail同时进行的，但是其实可以任选一边，即：</p><ul><li>只针对head生成负样本；</li><li>只针对tail生成负样本；</li></ul><p>但是一般情况下，我们都是针对两边同时生成负样本。</p><p>但是指针对以便进行负样本的生成是有意义的，因为这样可以评估模型对于head和tail的预测差异。</p><h2 id="过滤已知triples"><a href="#过滤已知triples" class="headerlink" title="过滤已知triples"></a>过滤已知triples</h2><p>这个很明显，当生成负样本时，我们发现，针对(高圆圆，喜欢，Alex)，替换head，得到新的负样本的head可以任意替换，那么，恰巧生成一个负样本 (孙艺珍，喜欢，Alex)，这就尴尬了，因为这是一个正样本，当评估时必然会得到很高的分数，导致得到排名很前的rank，这就导致(高圆圆，喜欢，Alex)的排名靠后了，因此为了正确地衡量模型的性能，因此需要过滤掉这些正确的样本，因为它会忽略这些一直的triples带来的负面影响。</p><p>但是这种filtering的使用时机是很重要的：<strong>一个原则是评估的结果不会影响到模型的训练过程</strong>。根据这个原则，不可以使用filtering：</p><ul><li>Early stopping：不使用test data进行正样本的过滤，以免泄露信息；</li><li>hyperparameter optimization：不使用test data进行正样本的过滤，以免泄露信息；</li></ul><h2 id="实体和关系限定"><a href="#实体和关系限定" class="headerlink" title="实体和关系限定"></a>实体和关系限定</h2><p>这个问题需要阐述的是，上边根据LCWA或者sLCWA，可以生成针对所有实体或者关系的负样本，但是依赖于具体的任务，我们不想这么做，比如：在医疗知识图谱中，每个实体会有额外的实体类型，比如:</p><p>(氯吡格雷，治疗，过敏)，氯吡格雷是一种药物，可以治疗过敏，但是实体中有二甲双胍，这也是一种药品，但是根据上述的假设，则可以生成负样本：(氯吡格雷，治疗，二甲双胍)，这显然是没有意义的，因为在不符合实际，因为这种情况下，当生成负样本时，我们一般希望规定，生成的负样本时符合实际的，比如：(氯吡格雷，治疗，过敏性鼻炎)。</p><p>这种情况下，需要完成两步工作：</p><ul><li>重新生成评估数据；</li><li>针对重新生成的评估数据，来计算衡量指标；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 表示学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱表示学习：训练方法</title>
      <link href="/2021/11/17/shu-ju-ke-xue/zhi-shi-tu-pu-biao-shi-xue-xi-xun-lian-fang-fa/"/>
      <url>/2021/11/17/shu-ju-ke-xue/zhi-shi-tu-pu-biao-shi-xue-xi-xun-lian-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="前提假设"><a href="#前提假设" class="headerlink" title="前提假设"></a>前提假设</h1><h2 id="Open-World-Assumption-OWA"><a href="#Open-World-Assumption-OWA" class="headerlink" title="Open World Assumption(OWA)"></a>Open World Assumption(OWA)</h2><p>开放世界假设，其含义在于暗含的假定为是未知的事实而不是假的，这也是“开放”这个词的含义，这么理解起来有点抽象，一个例子：宇宙内有除了人类的外星人，这个描述在Open World Assumption条件下，不是假的，你只能说它是未知的，这个问题的答案是“开放”的。</p><h2 id="Closed-World-Assumption-CWA"><a href="#Closed-World-Assumption-CWA" class="headerlink" title="Closed World Assumption(CWA)"></a>Closed World Assumption(CWA)</h2><p>封闭世界假设，与开放对立，即：所有未知的都是假的。同样上述的例子：宇宙内有除了人类的外星人，这个描述在Closed World Assumption条件下，我们均认为它是错误的。</p><h2 id="Local-Closed-World-Assumption-LCWA"><a href="#Local-Closed-World-Assumption-LCWA" class="headerlink" title="Local Closed World Assumption(LCWA)"></a>Local Closed World Assumption(LCWA)</h2><p>这个是什么意思呢？与Closed World Assumption相关，这涉及到局部的情况。同样上述的例子：宇宙内有除了人类的外星人，比如：对于不同的人类，这个描述在Local Closed World Assumption条件下，不同的人可能有不同的回答，对于NASA或者国家航天局来说，他们可能知道但是不说，因此他们对这个的回答可能是正确的，而对于我们来说，一般来说是错误的，因为你肯定不知道。这种情况导致不同的人群对于同样的问题出现认知的不同，所以Closed World Assumption假设过于绝对了，因此引入了Local Closed World Assumption，即：对于所有未知的知识中的一部分认为是错误的（因为有人认为那是对的）。</p><h2 id="Stochastic-Local-Closed-World-Assumption-sLCWA"><a href="#Stochastic-Local-Closed-World-Assumption-sLCWA" class="headerlink" title="Stochastic Local Closed World Assumption(sLCWA)"></a>Stochastic Local Closed World Assumption(sLCWA)</h2><p>这个假设，是在Local Closed World Assumption基础之上构建的。其实这个词相比于上述三者使用的较少，<strong>它需要和具体的采样策略结合来看</strong>。因为人类的知识没有办法具体的统计出来，因此日常接触到的知识均可以视为Local Knowledge, 而基于Local Closed World Assumption，所有不属于Local Knowledge的知识都是错误的。Stochastic Local Closed World Assumption则告诉我们，如果在这些“错误”的知识中进行采样，来帮助训练。</p><h1 id="不同假设对于训练的影响"><a href="#不同假设对于训练的影响" class="headerlink" title="不同假设对于训练的影响"></a>不同假设对于训练的影响</h1><p>这种假设条件对于知识图谱嵌入的影响如下：</p><table><thead><tr><th>Assumptions</th><th>影响</th><th>采用情况</th><th>说明</th></tr></thead><tbody><tr><td>Open World Assumption</td><td>会导致欠拟合under-fitting，也即over-generalization)</td><td>一般不用</td><td>直观理解，当一个模型对于一个自己认知之外事务，不明确表达态度时，其实是一种“缺乏自信”的表现，也会对所有已知和未知的事务同样保持“中庸”。</td></tr><tr><td>Closed World Assumption</td><td>会导致over-fitting，即泛化程度很低</td><td>一般不用</td><td>这种假设太过绝对，只要我不知道，就是错误的，有点过于“自负”，这种模型除了自己知道的事务，对其他均不认可。</td></tr><tr><td>Local Closed World Assumption</td><td>根据已有的知识，生成一部分“假”知识</td><td>可用</td><td></td></tr><tr><td>Stochastic Local Closed World Assumption</td><td>根据已有的知识，生成一部分“假”知识，从这些假知识中进行采样</td><td>可用</td><td></td></tr></tbody></table><h1 id="如何生成“假”知识？"><a href="#如何生成“假”知识？" class="headerlink" title="如何生成“假”知识？"></a>如何生成“假”知识？</h1><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>来自于 <a href="https://pykeen.readthedocs.io/en/stable/reference/training.html">source</a>。</p><blockquote><p>Throughout the following explanations of training loops, we will assume the set of entities $\mathcal{E}$ , set of relations $\mathcal{R}$ , set of possible triples $\mathcal{T} = \mathcal{E} \times \mathcal{R} \times \mathcal{E}$. We stratify $\mathcal{T}$ into the disjoint union of positive triples $\mathcal{T^{+}} \subseteq \mathcal{T}$ and negative triples $\mathcal{T^{-}} \subseteq \mathcal{T}$ such that $\mathcal{T^{+}} \cap \mathcal{T^{-}} = \emptyset$ and $\mathcal{T^{+}} \cup \mathcal{T^{-}} = \mathcal{T}$ .</p></blockquote><h2 id="“朴素”的方法"><a href="#“朴素”的方法" class="headerlink" title="“朴素”的方法"></a>“朴素”的方法</h2><p>对于一个已有的知识图谱而言，根据Closed World Assumption，任何不在该知识图谱内的知识或者三元组都是假知识。</p><p>一种“朴素”的负样本的生成办法是：</p><p>对于三元组，可能的组合有以下几种：</p><ul><li>N(head): 代表head实体的种类数量；</li><li>N(rel): 代表relation的种类数量；</li><li>N(tail)：代表tail实体的种类数量；</li></ul><p>则可能的三元组的数量为：</p><p>$$<br>N(head) \times N(rel) \times N(tail)<br>$$</p><p>当删除知识图谱内的三元组时，就可以认为是所有的负样本。这种负样本的数量是巨大的。</p><p>一种可以解决方法是：采样。具体的采样方法有很多种，这里不赘述了。</p><p>但是有一种情况，我们的模型需要<strong>更容易地对真知识进行判断</strong>，举个例子：</p><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTM15gYJOEGxQqr5jBsWUzpAw6RJjvCzus8MA&usqp=CAU" alt="高圆圆"></p><p>对比，高圆圆比娜扎漂亮，我们假设它是对的，当出现凤姐时，模型已经认识高圆圆，它能得出高圆圆比凤姐漂亮。但是当得到的负样本为：梅根福克斯与克劳馥时，你觉得模型对：</p><ul><li>高圆圆与凤姐</li><li>梅根福克斯与克劳馥</li></ul><p>哪个容易判断。</p><h2 id="LCWA下的负样本生成"><a href="#LCWA下的负样本生成" class="headerlink" title="LCWA下的负样本生成"></a>LCWA下的负样本生成</h2><p>基于上述的情况，在Local Closed World Assumption下，<strong>负样本的生成基于以下原则：任意替换三元组的任意一个位置，得到的负样本不属于知识图谱本身，即认为是负样本。</strong></p><p>根据这个原则，可以有三种类型的操作：</p><ul><li><p>head generation: $(h, r, t)$ -&gt; $(h, r, t_i)$;</p><p>   In this setting, for any triple $(h, r, t) \in \mathcal{K}$ that has been observed, a set<br>   $\mathcal{T^{-}} (h, r) $ of negative examples is created by considering all triples $(h, r, t_i) \notin \mathcal{K}$ as false.</p></li><li><p>relation generation: $(h, r, t)$ -&gt; $(h, r_i, t)$; </p><p>   In this setting, for any triple $(h, r, t) \in \mathcal{K}$ that has been observed, a set<br>   $\mathcal{T^{-}} (h, t) $ of negative examples is created by considering all triples $(h, r_i, t) \notin \mathcal{K}$ as false.</p></li><li><p>tail generation: $(h, r, t)$ -&gt; $(h_i, r, t)$;</p><p>   In this setting, for any triple $(h, r, t) \in \mathcal{K}$ that has been observed, a set<br>   $\mathcal{T^{-}} (r, t) $ of negative examples is created by considering all triples $(h_i, r, t) \notin \mathcal{K}$ as false.</p></li></ul><p>一般情况下，在Local Closed World Assumption下，很多的实现都只会考虑head generation和relation generation，不会考虑tail generation。</p><h2 id="sLCWA下的负样本生成"><a href="#sLCWA下的负样本生成" class="headerlink" title="sLCWA下的负样本生成"></a>sLCWA下的负样本生成</h2><p>从Local Closed World Assumption中的三种情况下进行的集合进行采样，即：</p><ul><li>$(h, r, t)$ -&gt; $(h, r, t_i)$</li><li>$(h, r, t)$ -&gt; $(h, r_i, t)$</li><li>$(h, r, t)$ -&gt; $(h_i, r, t)$</li></ul><p>但从实际来看，有时候只需要$(h, r, t)$ -&gt; $(h, r, t_i)$和$(h, r, t)$ -&gt; $(h_i, r, t)$，而没有考虑关系的替换，然后从这两者的集合中进行采样。</p><table><thead><tr><th>Assumptions</th><th>Local Closed World Assumption</th><th>Stochastic Local Closed World Assumption</th></tr></thead><tbody><tr><td>负样本来源</td><td>$(h, r, t)$ -&gt; $(h, r, t_i)$， $(h, r, t)$ -&gt; $(h, r_i, t)$</td><td>$(h, r, t)$ -&gt; $(h, r, t_i)$，$(h, r, t)$ -&gt; $(h_i, r, t)$</td></tr><tr><td>是否要采样</td><td>不需要</td><td>需要</td></tr><tr><td>过滤正样本</td><td>需要</td><td>需要</td></tr></tbody></table><h2 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h2><p>这个具体的帮助理解的例子来自于:<br><a href="https://arxiv.org/abs/2006.13365">Bringing Light Into the Dark: A Large-scale Evaluation of Knowledge Graph Embedding Models Under a Unified Framework</a></p><p><img src="https://pykeen.readthedocs.io/en/stable/_images/training_approaches.png"></p><p>该图对比了负样本在：</p><ul><li>Local Closed World Assumption</li><li>Stochastic Local Closed World Assumption<br>两种生成策略。</li></ul><p>对于同一种关系 <code>works_at</code>, 红色部分是true triples。</p><ul><li>在LCWA生成的是深蓝色对应的负样本，它们都没在原始的知识图谱上。</li><li>在sLCWA生成的是浅蓝色对应的负样本，并从其中采样，它们都没在原始的知识图谱上。</li><li>黄色部分则不在负样本的考虑之列。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 表示学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - Convolutional 2D Knowledge Graph Embeddings</title>
      <link href="/2021/11/14/shu-ju-ke-xue/convkb/"/>
      <url>/2021/11/14/shu-ju-ke-xue/convkb/</url>
      
        <content type="html"><![CDATA[<h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>Link prediction是在知识图谱中预测实体之间的关系的任务，在查询扩展和语义关系预测中需要解决的，也是本论文致力于解决的。</p><p>在解决Link prediction, 其核心考虑因素在于：</p><blockquote><p>link predictors should scale in a manageable way with respect to <strong>both the number of parameters and computational costs</strong> to be applicable in real-world scenarios.</p></blockquote><p>同时需要考虑计算成本，还是考虑模型本身的预测性能，而参数数量是模型性能的一个指标。</p><p>之前方法的问题在于：</p><blockquote><p>Previous work on link prediction has <strong>focused on shallow, fast models</strong> which can scale to large knowledge graphs. However, these models <strong>learn less expressive features</strong> than deep, multi-layer models which potentially limits performance.</p></blockquote><p>简单来讲，之前的方法过于关注在大型知识图谱上进行快速的学习，这需要网络不太复杂。但是其架构学习到的特征不够丰富，性能不够强。</p><p>为了提高知识图谱上的预测性能，从而提高表现力，在不使用深层模型的前提下，只能提高embedding size，但是难以应用到大型知识图谱上。</p><p>换一种思路，使用深度模型，就可以减少embedding size，因为可以学到高层特征，但是在过往的模型中，深度模型中的使用的架构都是全连接层，因此会造成过拟合问题。</p><p>以上问题的一种解决办法是：</p><blockquote><p>use parameter efﬁcient, fast operators which can be composed into deep networks.</p></blockquote><p>因此，自然而然，卷积的操作就被引入了，因为以下特点：</p><ul><li>parameter efﬁcient</li><li>fast to compute: highly optimised GPU implementations</li></ul><p>本文提出来的模型：ConvE, a multi-layer convolutional network model for link prediction，这是一个基于卷积的多层架构。它的优点如下：</p><ul><li><strong>highly parameter efﬁcient</strong>: yielding the same performance as <strong>DistMult</strong> and <strong>R-GCN</strong> with 8x and 17x fewer parameters;</li><li><strong>particularly effective at modelling nodes with high indegree</strong>: common in highlyconnected, complex knowledge graphs such as Freebase and YAGO3;</li></ul><h1 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h1><h2 id="2-1-1D-vs-2D-Convolutions"><a href="#2-1-1D-vs-2D-Convolutions" class="headerlink" title="2.1 1D vs 2D Convolutions"></a>2.1 1D vs 2D Convolutions</h2><p>NLP任务中，多数使用1D卷积进行操作，即在文本的序列方向上进行卷积操作，本文使用2D卷积，不仅在文本序列方向进行操作，同时还在embedding的纵向上进行操作，这使用卷积操作捕捉到的交互信息更丰富。</p><p>这种操作的优点在于： increases the expressiveness of our model through additional points of interaction between embeddings.</p><p>这种操作如何理解？</p><p>当把1D的embedding 进行拼接时，你仍然需要得到1D的embedding，那么拼接的方法只能是在一维上，如下例：</p><p><img src="/images/conve/lex0.png"></p><p>其中假如你的卷积核k=3, 那么能捕捉到的交互只有最临近的a和b, 除非你讲卷积核的尺寸增加，这样才能捕捉到更多的交互。</p><p>当换到2D时，由于是在二维的方向上进行拼接和堆叠，因此其方式可以有多种，因此当卷积进行操作时，可以捕捉的信息可以是左右方向的，也可以是上下方向的，如下图：</p><p><img src="/images/conve/lex1.png"></p><p>如果两种元素代表的意义不同, 那么交换它们的拼接方式还能进一步的提升交互次数:</p><p><img src="/images/conve/lex2.png"></p><p>因此在2D条件下，捕捉到的交互信息数量是不单单与卷积核有关，而且还与矩阵的尺寸有关。</p><h2 id="2-2-问题形式化"><a href="#2-2-问题形式化" class="headerlink" title="2.2 问题形式化"></a>2.2 问题形式化</h2><p>link prediction 可以认为是 a pointwise learning to rank problem。具体而言，对每个输入的三元组 triples: $x = (s, r, o)$, 目标是 learning a scoring function $\psi(x)$, 其结果正比于x为true的likelihood。</p><h2 id="2-3-Neural-Link-Predictors"><a href="#2-3-Neural-Link-Predictors" class="headerlink" title="2.3 Neural Link Predictors"></a>2.3 Neural Link Predictors</h2><p>这个组件是干嘛的，深度学习中总有一些为了唬人提出的名词，其实这个predictors就是一个多层神经网络，包括：</p><ul><li>encoding component: 对 $x = (s, r, o)$, 该部分将subject和object映射为embeddings, $e_s$, $e_o$; </li><li>scoring component: 使用 $\psi_r$ 对embeddings评分，即: $\psi(s, r, o) = \psi_r(e_s, e_o)$ </li></ul><p>一些经常使用的典型predictors如下: </p><p><img src="/images/conve/1.png" alt="经常使用的典型predictors"></p><h2 id="2-4-模型主要内容"><a href="#2-4-模型主要内容" class="headerlink" title="2.4 模型主要内容"></a>2.4 模型主要内容</h2><h3 id="2-4-1-Scoring-function"><a href="#2-4-1-Scoring-function" class="headerlink" title="2.4.1 Scoring function"></a>2.4.1 Scoring function</h3><p>scoring function定义如下:<br>$$<br>\psi_{r}\left(\mathbf{e}_s, \mathbf{e}_o\right)=f\left(\operatorname{vec}\left(f\left(\left[\overline{\mathbf{e}_s} ; \overline{\mathbf{r}_r}\right] \ast \omega\right)\right) \mathbf{W}\right) \mathbf{e}_o<br>$$</p><p>一些符号如下:</p><ul><li><p>$\mathbf{e}_s, \mathbf{e}_o$ 分别代表头实体和尾实体的Embedding；</p></li><li><p>$\overline{\mathbf{e}_s}, \overline{\mathbf{r}_r}$ 分别代表Reshape后的头实体和关系向量，这种操作如下：如果 $\mathbf{e}_s, \mathbf{r}_r \in \mathbb{R}^k$, 那么 $\overline{\mathbf{e}_s}, \overline{\mathbf{r}_r} \in \mathbb{R}^{k_w \times k_h} $, 则 $k = k_w  k_h$</p></li><li><p>$\omega$ 代表卷积核；</p></li><li><p>$\mathbf{W}$ 代表投影矩阵；</p></li></ul><h3 id="2-4-2-模型架构"><a href="#2-4-2-模型架构" class="headerlink" title="2.4.2 模型架构"></a>2.4.2 模型架构</h3><p><img src="/images/conve/2.png" alt="ConvE"></p><p><code>ConvE</code>的整个训练过程如下.</p><ul><li>先通过Embedding的方式分别获得头实体表示 $\mathbf{e}_s$ 和关系表示 $\mathbf{r}_r$ ；</li><li>将头实体和关系表示先<code>Concat</code>起来, 然后将其<code>Reshape</code>到某一种尺寸, 此时头实体和关系的表示记为 $\left[ \overline{\mathbf{e}_s} ; \overline{\mathbf{r}_r} \right]$；</li><li>接着利用卷积抽取Reshape后的二维向量, 也就是对头实体和关系的交互信息进行捕捉；</li><li>利用卷积(可以是任意数量的卷积核)抽取完信息后, 将所有的特征打平成一个一维向量；</li><li>通过投影矩阵 $\mathbf{W}$ 投影到一个中间层中，输出的尺寸与embedding size相同，以便与尾实体表示 $\mathbf{e}_o$ 做内积, 获得相似度, 即Logits；</li><li>这种方式通过内积来比较所获向量与尾实体的相似度, 越相似得分越高.</li><li>然后将Logits经过 $\sigma$ 函数, 得到每个实体的概率：  $$p=\sigma(\psi_r\left(\mathbf{e}_s, \mathbf{e}_o \right))$$</li></ul><p>优化时的损失函数采用BCE(binary cross-entropy loss)：</p><p>$$\mathcal{L}(p, t)=-\frac{1}{N} \sum_i\left(t_i \cdot \log \left(p_i \right)+\left(1-t_i \right) \cdot \log \left(1-p_i \right)\right)$$</p><p>$t$ 是尾实体的one-hot vector. 对于和输入的 $(s, r, ?)$ 匹配的位置为1，其余为0.</p><h3 id="2-4-3-训练tips"><a href="#2-4-3-训练tips" class="headerlink" title="2.4.3 训练tips"></a>2.4.3 训练tips</h3><h4 id="2-4-3-1-基本tips"><a href="#2-4-3-1-基本tips" class="headerlink" title="2.4.3.1 基本tips"></a>2.4.3.1 基本tips</h4><ul><li>rectiﬁed linear units: as the non-linearity $f$, 加快训练；</li><li>batch normalization: after each layer to stabilise</li><li>regularise: dropout</li><li>optimiser: Adam</li><li>label smoothing: to lessen overﬁtting due to saturation of output non-linearities at the labels</li></ul><h4 id="2-4-3-2-加速评估tips"><a href="#2-4-3-2-加速评估tips" class="headerlink" title="2.4.3.2 加速评估tips"></a>2.4.3.2 加速评估tips</h4><p>卷积操作消耗大量时间</p><blockquote><p>convolution consumes about 75-90% of the total computation time, thus it is important to minimise the number of convolution operations to speed up computation</p></blockquote><p>思路1：增加batch size加速，但是CNN会使得GPU的内存超过限制；</p><p>解决办法：1-N scoring</p><p>ConvE最后的输出, 能获得对所有实体相关的Logits, 这样就能<strong>对所有的尾实体同时打分</strong>, <strong>而不用考虑采样的问题</strong>. 在原文中这种打分方式被称为<strong>1-N Scoring</strong>.</p><p>过去评估时，需要采样负样本，进行1-1评估。现在这种方式能极大地加快Evaluation的速度, 因为负采样只能对单一的三元组打分, 而这种方式能同时对所有的尾实体同时打分。这种思想能够应用于所有的1-1 scoring Model.</p><p>这种方式其实本质上利用GPU并行执行的特点，在架构上将训练和评估同时考虑，通过将平衡计算性能和收敛速度，来使得评估过程加快。</p><h1 id="3-实验评估"><a href="#3-实验评估" class="headerlink" title="3. 实验评估"></a>3. 实验评估</h1><h2 id="3-1-数据集"><a href="#3-1-数据集" class="headerlink" title="3.1 数据集"></a>3.1 数据集</h2><table><thead><tr><th>数据集</th><th>来源</th><th>关系</th><th>实体</th><th>三元组</th><th>说明</th></tr></thead><tbody><tr><td>WN18</td><td>a subset of WordNet</td><td>18</td><td>40943</td><td>151442</td><td>consist of hyponym and hypernym relations and, for such a reason, WN18 tends to follow a strictly hierarchical structure. 用WN18RR替代。</td></tr><tr><td>FB15k</td><td>a subset of Freebase</td><td>1345</td><td>14951</td><td>——</td><td>A large fraction of content in this knowledge graph describes facts about movies, actors, awards, sports, and sport teams. 用FB15k-237替代。</td></tr><tr><td>YAGO3-10</td><td>a subset of YAGO3</td><td>37</td><td>123182</td><td>entities which have a minimum of 10 relations each</td><td>Most of the triples deal with descriptive attributes of people, such as citizenship, gender, and profession.</td></tr><tr><td>Countries</td><td></td><td></td><td></td><td></td><td>a benchmark dataset that is useful to evaluate a model’s ability to learn long-range dependencies between entities and relations. It consists of three sub-tasks which increase in difﬁculty in a step-wise fashion, where the minimum pathlength to ﬁnd a solution increases from 2 to 4.</td></tr></tbody></table><h2 id="3-2-超参"><a href="#3-2-超参" class="headerlink" title="3.2 超参"></a>3.2 超参</h2><ul><li><p>选择方法: <code>grid search</code> according to the <code>mean reciprocal rank (MRR)</code> on the validation set</p></li><li><p>选定范围:</p><ul><li><code>embedding dropout</code>: 0.0, 0.1, 0.2</li><li><code>feature map dropout</code>: 0.0, 0.1, 0.2, 0.3</li><li><code>projection layer dropout</code>: 0.0, 0.1, 0.3, 0.5</li><li><code>embedding size</code>: 100, 200</li><li><code>batch size</code>: 64, 128, 256</li><li><code>learning rate</code>: 0.001, 0.003</li><li><code>label smoothing</code>: 0.0, 0.1, 0.2, 0.3</li></ul></li><li><p>最佳参数:</p><ul><li>WN18, YAGO3-10 and FB15k<ul><li><code>embedding dropout</code>: 0.2</li><li><code>feature map dropout</code>: 0.2</li><li><code>projection layer dropout</code>: 0.3</li><li><code>embedding size</code>: 200</li><li><code>batch size</code>: 128</li><li><code>learning rate</code>: 0.001</li><li><code>label smoothing</code>: 0.1</li></ul></li><li>Countries dataset<ul><li><code>embedding dropout</code>: 0.3</li><li><code>hidden dropout</code>: 0.5</li><li><code>label smoothing</code>: 0</li></ul></li><li><code>early stopping</code> according to the <code>mean reciprocal rank</code> (WN18, FB15k, YAGO3-10) and <code>AUC-PR</code> (Countries) statistics on the validation set</li></ul></li></ul><h2 id="3-3-结果"><a href="#3-3-结果" class="headerlink" title="3.3 结果"></a>3.3 结果</h2><p>实验中进行评估时，有几件注意事项：</p><ul><li><p>由于数据出现leakage，因此使用了rule-based method来识别逆向关系作为对照，同时在数据集包括有无逆向关系)中进行评估；</p></li><li><p>使用了<code>filtered setting</code>;</p><blockquote><p>Rank test triples against all other candidate triples not appearing in the training, validation, or test set.</p></blockquote><blockquote><p>Candidates are obtained by permuting either the subject or the object of a test triple with all entities in the knowledge graph.</p></blockquote></li></ul><h3 id="3-3-1-从参数效率看"><a href="#3-3-1-从参数效率看" class="headerlink" title="3.3.1 从参数效率看"></a>3.3.1 从参数效率看</h3><p><img src="/images/conve/3.png" alt="参数数量和性能(ConvE vs. DistMult)"></p><h3 id="3-3-2-结果-含有逆向关系"><a href="#3-3-2-结果-含有逆向关系" class="headerlink" title="3.3.2 结果(含有逆向关系)"></a>3.3.2 结果(含有逆向关系)</h3><p><img src="/images/conve/4.png" alt="结果(含有逆向关系)"></p><h3 id="3-3-3-结果-不含逆向关系"><a href="#3-3-3-结果-不含逆向关系" class="headerlink" title="3.3.3 结果(不含逆向关系)"></a>3.3.3 结果(不含逆向关系)</h3><p>这里将数据集中存在逆向关系的三元组全部删除了，来避免leakage造成的负面影响。</p><p><img src="/images/conve/5.png" alt="结果(不含逆向关系)1"></p><p><img src="/images/conve/6.png" alt="结果(不含逆向关系)2"></p><h2 id="3-4-分析"><a href="#3-4-分析" class="headerlink" title="3.4 分析"></a>3.4 分析</h2><h3 id="3-4-1-消融实验"><a href="#3-4-1-消融实验" class="headerlink" title="3.4.1 消融实验"></a>3.4.1 消融实验</h3><p>为了查看，哪部分组件在整个架构中的作用最重要，消融实验显示：</p><p><img src="/images/conve/7.png" alt="消融实验结果"></p><ul><li>hidden dropout的影响最大;</li><li>但是label smoothing的影响几乎可以忽略；</li></ul><h3 id="3-4-2-从图的结构分析优点"><a href="#3-4-2-从图的结构分析优点" class="headerlink" title="3.4.2 从图的结构分析优点"></a>3.4.2 从图的结构分析优点</h3><h4 id="3-4-2-1-假设1"><a href="#3-4-2-1-假设1" class="headerlink" title="3.4.2.1 假设1"></a>3.4.2.1 假设1</h4><p>datasets contain nodes with very high relation-speciﬁc indegree时，<code>ConvE</code>效果更好，而indegree较小时，一些模型足以应对<code>DistMult</code>。</p><blockquote><p>Our hypothesis is that deeper models, that is, models that learn multiple layers of features, like ConvE, have an advantage over shallow models, like DistMult, to capture all these constraints.</p></blockquote><ul><li>验证：通过将数据中indegree中的过大或者过小的node删除，然后分别使用ConvE和DistMult进行实验，验证了上述假设。</li></ul><h4 id="3-4-2-2-假设2"><a href="#3-4-2-2-假设2" class="headerlink" title="3.4.2.2 假设2"></a>3.4.2.2 假设2</h4><p>平均PageRank越高的graph，ConvE的性能相比于<code>DistMult</code>越好；</p><blockquote><p>This gives additional evidence that models that are deeper have an advantage when modelling nodes with high (recursive) indegree.</p></blockquote><ul><li>验证：通过计算各个数据集的平均pagerank值，然后计算pagerank值与(convE - DistMult)差值计算相关性，验证了上述假设，这个假设2与假设1其实可以看成等价。</li></ul><h1 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h1><ul><li><p><a href="https://github.com/TimDettmers/ConvE">原文实现</a></p></li><li><p><a href="https://github.com/Accenture/AmpliGraph">AmpliGraph</a></p></li></ul><h1 id="5-问题"><a href="#5-问题" class="headerlink" title="5. 问题"></a>5. 问题</h1><ol><li>与CV中CNN的应用对比，模型仍是浅层，未来会增加深度的卷积模型。</li><li>2D卷积的解释；</li><li>如何更多地捕捉embedding之间的交互，例如通过增加大型结构；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 表示学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《美国陷阱》中阿尔斯通被肢解背后的经济战</title>
      <link href="/2021/11/13/du-shu-gan-wu/mei-guo-xian-jing-zhong-a-er-si-tong-bei-zhi-jie-bei-hou-de-jing-ji-zhan/"/>
      <url>/2021/11/13/du-shu-gan-wu/mei-guo-xian-jing-zhong-a-er-si-tong-bei-zhi-jie-bei-hou-de-jing-ji-zhan/</url>
      
        <content type="html"><![CDATA[<p>疫情在家，除了完成正常的工作学习外，由于没啥好的娱乐项目，读书是一种廉价的消遣方式。正巧遇到一本书《美国陷阱》，其中的情节和阴谋论恐怕电影都拍不出来，甚至可以当成悬疑小说来读。</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/1.png" alt="《美国陷阱》"></p><h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h1><p>最近几年，美国加大对中国的打压力度，尤其是科技领域，其中以华为最为大家所熟悉。那么最为人所知伎俩即，扣押孟晚舟（任正非的女儿和华为的高管）。大家肯定跌破眼镜，这种流氓式的手段，对于被称为“世界最大的民主国家”的美国，怎么干得出来？</p><p>当然，理由还是要有的，不然无法说服世界舆论，其实估计也没人信。因为这种套路也不是第一次了，本书讲得就是同样的套路，应用到另一个公司的另一个人身上。</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/2.png" alt="两起事件的对比"></p><p>而本书，讲得就是阿尔斯通的故事，而且是由当事人弗雷德里克-皮耶鲁齐自己陈述的。因此对于我们具有极大的参考价值。</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/3.png" alt="这位老哥比孟晚舟惨得多"></p><h1 id="2-阿尔斯通与中国"><a href="#2-阿尔斯通与中国" class="headerlink" title="2. 阿尔斯通与中国"></a>2. 阿尔斯通与中国</h1><p>阿尔斯通是法国一家有战略意义的工业巨头，关于它的内容，大家可以在网上搜索，我这里不过多阐述，大家认识到这是一家工业巨头就可以了，法国的核电站都是它来维护的，舰艇的燃气轮机也是它提供的。</p><p>而他与中国的渊源也是颇深，三峡水利工程、向家坝水利工程等好多项目，都有它的参与，<strong>甚至书中还披露，当然是阿尔斯通的认罪协议中，阿尔斯通曾经为参与台北地铁项目，而贿赂相关负责人。</strong></p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/4.png" alt="阿尔斯通"></p><h1 id="3-书中主要内容"><a href="#3-书中主要内容" class="headerlink" title="3. 书中主要内容"></a>3. 书中主要内容</h1><p>为了大家能够明白书中的主要线索，我首先用图的方式表达其中涉及到的参与人和机构。</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/5.png" alt="当事人和相关关系"></p><ol><li>首先，美国司法部质控阿尔斯通违反《反腐败法》，逮捕作者，也就是皮耶鲁齐，希望他认罪，在阿尔斯通内部充当“间谍”，以便掌控该企业的内部信息，作者拒绝，被监禁；</li><li>陆续有其他阿尔斯通的高管被逮捕，公司CEO惶恐，希望摆脱诉讼和入狱；</li><li>通用电气介入，摆出了可以帮助阿尔斯通摆脱当前困局的慈善面目，公司CEO为脱罪，达成秘密协议（推测，当事人都矢口否认，但作者强烈暗示这种行为），将阿尔斯通能源部门出售给通用电气（是该公司最有价值的资产）；</li><li>法国政府对这种行为保持暧昧态度，后来知晓，通用电气和阿尔斯通花费将近3亿欧元进行公关，还有一层原因，马克龙（现任法国总统，时任经济部长）相信阿尔斯通CEO与美国司法部、通用电气有交易，但是没有证据；同时受限于大西洋主义以及对美国强大实力的深深恐惧；</li><li>“肢解”交易达成，作者被判入狱30个月。</li></ol><p>从上述过程中，从头到尾，<strong>作者的角色和所处的地位，相较于整个事件，简直微不足道！所以，实际上他当了一个背锅侠和替罪羊！</strong></p><h1 id="4-带给我们的思考和启示"><a href="#4-带给我们的思考和启示" class="headerlink" title="4. 带给我们的思考和启示"></a>4. 带给我们的思考和启示</h1><p><strong>第一点</strong>，战争的形式已经发生变化了，从之前枪炮相加，血肉横飞到网络世界的攻防，可能并没有人死亡，但是损失可能更大。<strong>这本书中提到的有两点很值得注意，一个是舆论公关战，一个就是法律战。</strong></p><p>通用电气和阿尔斯通为促成收购，在媒体和网络上，大肆说明该收购带来的好处，比如增加就业岗位，帮助阿尔斯通摆脱诉讼，同时游说法国政界和企业界的精英。结果，一个曾经在戴高乐将军领导下致力于独立自主的法国居然在外人收购自己的核心资产时，居然沉默是“金”，简直可怕！想想我们这个社会，这样的人会在少数吗？</p><p>法律战，也即本事件的起因，违反《反海外腐败法》。这个法是个什么东西呢？简单来说，美国之外国家的公司，如果使用了与美国相关的工具，则全部收受到该法律的管辖。是不是，有点治外法权的意味呢！比如，在我们国家犯罪，却用美国的法律诉讼，是不是有点滑稽，这种域外法的行使，使得美国的“全球警察”地位坐实了。而且，还让人产生错觉，好像是我错了（虽然在本书中提到的阿尔斯通确实有腐败行为）！</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/6.png" alt="《反海外腐败法》"></p><p><strong>第二点</strong>，我想引述书中的一句话，</p><blockquote><p>我们不能上当受骗。不管谁当美国总统，无论他是民主党人还是共和党人，华盛顿都会维护少数工业巨头的利益</p></blockquote><p>有人曾经，觉得美国民主党上台，对我们可能会温和一点（可能法国人也是这么想的），还是放弃这种幻想吧！这是体制决定的，不是简单的人事变动能够改变的，美国政府和企业巨头的纠缠不断的联系导致“旋转门”的不断上演，所以我们还是做好准备吧！</p><p><strong>第三点</strong>，“人权”和“自由”这种过于抽象的东西，每个人都有自己的理解，比如说那个只喝矿泉水的归国人员，它的解释就为“特权”。<strong>而且每个人的理解都会倾向于自己的利益</strong>，比如作者在狱中的遭遇，美国的监狱的确是没有“人权”，你能相信监狱是私人的，所以当然是需要盈利的，“人权”多费钱啊，与资本主义的核心目标——攫取利益不符啊，当事情与他们的利益不符时，就会有这样的论调。当人权在敌对国家遭到威胁时，这时候美国这个道德楷模就出来了。</p><p><img src="/images/%E7%BE%8E%E5%9B%BD%E9%99%B7%E9%98%B1/7.png" alt="你品，你细品！"></p><p>第四点，爱国主义，这种东西在人们的脑海中是正面的东西，我也倾向于这样认为。但是有一点在书中提及，声称“自己生于斯，长于斯”的人，向大家彰显自己的爱国举动，真是是所谓的“爱国人士”吗，或许阿尔斯通CEO柏珂龙的话有助于我们思考，</p><blockquote><p>我是法国择优选拔人才体制的产物。借此机会，我想说，我的父母都是移民。自从在阿尔斯通任职后，我在法国创造了将近1.5万个就业岗位，对此我感到非常自豪。每个人都必须为法国就业做出一份贡献。我已经努力做出了微薄的贡献。</p></blockquote><p>不要忘记，就是他私下与通用电气密谋，肢解了自己服务的“工业明珠”！</p><p>在这本书中，还有很多值得人们思考的东西，包括友情、爱情、劳资关系、糖衣炮弹、爱国主义等等，建议大家去看一下，会收获不一样的东西！其中，对个人来说，最想提及的一点是，找一个好妻子真的是很重要的事情，尤其是像这位老哥遭遇监禁这样的遭遇时，更能体现这一点。</p><h1 id="5-Q-amp-A"><a href="#5-Q-amp-A" class="headerlink" title="5. Q&amp;A"></a>5. Q&amp;A</h1><p>看本书时，我一直不明白的有几个问题，后来弄明白了，在这里列出来同大家分享。</p><p><strong>1) 美国为啥可以管理国外的犯罪？怎么管？</strong></p><p>这与美国在国际上巨大的影响力和超强的实力有关，比如：做国际贸易需要美元结算，没有美元的话没办法进行交易，大家伙都不认，这也是我们一直推进人民币国际化的原因之一。因此，你只要涉及到美元交易，就归美国管，因为美元是美国发行的，具体怎么管，国际贸易会有清算，主要的清算中心在美国，通俗点讲，不听话的话，你就没办法收到货款，也没办法进口。这里，顺便提一句，你觉得Facebook的Libra能成功吗？</p><p>还有一点，除了中国外，世界主要的信息技术公司都是美国公司，所以只要你用了Gmail、Facebook等就都和美国有关系了。</p><p>其实，立什么法不重要，重要的是要有执行能力，这是美国厉害的地方。比如，有一天，你说全世界都得听我的，人家以为你有病呢，但是有人不听时，你有办法治人家，这时大家才服你，最起码表面上服你！</p><p><strong>2) 大西洋主义 VS 亲欧洲主义</strong></p><p>简单来讲，大西洋主义，就是西欧和北美互相合作，保护共同的安全和价值观，但是被认为是美国操纵欧洲的工具，尤其是对于盟友，美国的小动作也在不断的情况下。亲欧洲主义，强调欧洲一体化，摆脱美国的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 读书感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
            <tag> 政治 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
